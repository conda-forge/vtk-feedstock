diff --git a/Documentation/release/dev/update-ioss-v2025-08-27.md b/Documentation/release/dev/update-ioss-v2025-08-27.md
new file mode 100644
index 0000000000000000000000000000000000000000..c391a334c03ecb3c8ba664e9ab98f96763254c57
--- /dev/null
+++ b/Documentation/release/dev/update-ioss-v2025-08-27.md
@@ -0,0 +1,4 @@
+## Ioss: Update to seacas v2025-08-28
+
+VTK's `Ioss` third-party library has been updated
+to match [seacas v2025-08-28](https://github.com/sandialabs/seacas/releases/tag/v2025-08-28).
diff --git a/IO/IOSS/vtkIOSSCellGridReaderInternal.cxx b/IO/IOSS/vtkIOSSCellGridReaderInternal.cxx
index 57c767d51a444cc00b5d94942ae2c0db3f7827d9..5dad8a3bee49e7f93379a73b5737c69124194b04 100644
--- a/IO/IOSS/vtkIOSSCellGridReaderInternal.cxx
+++ b/IO/IOSS/vtkIOSSCellGridReaderInternal.cxx
@@ -350,9 +350,9 @@ std::vector<vtkSmartPointer<vtkCellGrid>> vtkIOSSCellGridReaderInternal::GetNode
   }
   // Fetch the IDs of the file-global points included in the node-set,
   // offsetting by -1 so they are 0-indexed:
-  auto transform = std::unique_ptr<Ioss::Transform>(Ioss::TransformFactory::create("offset"));
+  auto transform = Ioss::TransformFactory::create("offset");
   transform->set_property("offset", -1);
-  auto ids_raw = vtkIOSSUtilities::GetData(group_entity, "ids_raw", transform.get());
+  auto ids_raw = vtkIOSSUtilities::GetData(group_entity, "ids_raw", transform);
   ids_raw->SetNumberOfComponents(1);
 
   // Add the ID array to a vtkDataSetAttributes instance corresponding to
diff --git a/IO/IOSS/vtkIOSSCellGridUtilities.cxx b/IO/IOSS/vtkIOSSCellGridUtilities.cxx
index 6a2ddb6020cd148fd7fdb2878fe2ad56ebfd21e4..de52bb4ed9808ed458977b1c982a5edb538e4306 100644
--- a/IO/IOSS/vtkIOSSCellGridUtilities.cxx
+++ b/IO/IOSS/vtkIOSSCellGridUtilities.cxx
@@ -280,9 +280,9 @@ bool GetConnectivity(const Ioss::GroupingEntity* group_entity, vtkCellGrid* grid
   if (!sourceSpec.Connectivity)
   {
     std::vector<int> permutation;
-    auto transform = std::unique_ptr<Ioss::Transform>(Ioss::TransformFactory::create("offset"));
+    auto transform = Ioss::TransformFactory::create("offset");
     transform->set_property("offset", -1);
-    auto ids_raw = vtkIOSSUtilities::GetData(group_entity, "connectivity_raw", transform.get());
+    auto ids_raw = vtkIOSSUtilities::GetData(group_entity, "connectivity_raw", transform);
     if (spec_index < 0)
     {
       // Transfer ownership to a vtkDataSetAttributes instance:
diff --git a/IO/IOSS/vtkIOSSReaderInternal.cxx b/IO/IOSS/vtkIOSSReaderInternal.cxx
index 1b01171cbfd3e4d505ed5f0f775e46d07e251d93..ba934c30294cd85971f0e82b664b3b409fdd82b5 100644
--- a/IO/IOSS/vtkIOSSReaderInternal.cxx
+++ b/IO/IOSS/vtkIOSSReaderInternal.cxx
@@ -1266,11 +1266,10 @@ void vtkIOSSReaderInternal::GenerateElementAndSideIds(vtkDataSet* dataset, Ioss:
               << "[.\n";
 #endif
     // ioss element_side_raw is 1-indexed; make it 0-indexed for VTK.
-    auto transform = std::unique_ptr<Ioss::Transform>(Ioss::TransformFactory::create("offset"));
+    auto transform = Ioss::TransformFactory::create("offset");
     transform->set_property("offset", -1);
 
-    auto element_side_raw =
-      vtkIOSSUtilities::GetData(sideBlock, "element_side_raw", transform.get());
+    auto element_side_raw = vtkIOSSUtilities::GetData(sideBlock, "element_side_raw", transform);
     auto sideBlockType = sideBlock->topology()->base_topology_permutation_name();
     (void)element_side_raw;
     std::ostringstream sideElemName;
@@ -1814,6 +1813,13 @@ bool vtkIOSSReaderInternal::GetGeometry(
   extents[4] = static_cast<int>(sblock.get_property("offset_k").get_int());
   extents[5] = extents[4] + static_cast<int>(sblock.get_property("nk").get_int());
 
+  // if extents are all 0, then the block has data, then you need to redo extents,
+  // so that extents 1, 3, and 5 are minus 1
+  if (std::all_of(extents, extents + 6, [](int e) { return e == 0; }))
+  {
+    extents[1] = extents[3] = extents[5] = -1;
+  }
+
   assert(
     sblock.get_property("node_count").get_int() == vtkStructuredData::GetNumberOfPoints(extents));
   assert(
diff --git a/IO/IOSS/vtkIOSSUtilities.cxx b/IO/IOSS/vtkIOSSUtilities.cxx
index daba44f56e6baa4fa137808f889d58c42cce5bf8..354ae63e7b4a050643aa3d2bcd0feaafe51a3610 100644
--- a/IO/IOSS/vtkIOSSUtilities.cxx
+++ b/IO/IOSS/vtkIOSSUtilities.cxx
@@ -294,7 +294,7 @@ vtkSmartPointer<vtkDataArray> GetData(const Ioss::GroupingEntity* entity,
   }
   if (transform)
   {
-    field.add_transform(transform);
+    field.add_transform(transform); // The raw pointer is stored as a shared pointer internally
     field.transform(array->GetVoidPointer(0));
   }
 
@@ -702,9 +702,9 @@ vtkSmartPointer<vtkCellArray> GetConnectivity(
     // for nodesets, we create a cell array with single cells.
 
     // ioss ids_raw is 1-indexed, let's make it 0-indexed for VTK.
-    auto transform = std::unique_ptr<Ioss::Transform>(Ioss::TransformFactory::create("offset"));
+    auto transform = Ioss::TransformFactory::create("offset");
     transform->set_property("offset", -1);
-    auto ids_raw = vtkIOSSUtilities::GetData(group_entity, "ids_raw", transform.get());
+    auto ids_raw = vtkIOSSUtilities::GetData(group_entity, "ids_raw", transform);
     ids_raw->SetNumberOfComponents(1);
 
     vtkSmartPointer<vtkCellArray> cellArray = vtkSmartPointer<vtkCellArray>::New();
@@ -722,11 +722,10 @@ vtkSmartPointer<vtkCellArray> GetConnectivity(
   vtkSmartPointer<vtkCellArray> cellArray = vtkSmartPointer<vtkCellArray>::New();
 
   // ioss connectivity_raw is 1-indexed, let's make it 0-indexed for VTK.
-  auto transform = std::unique_ptr<Ioss::Transform>(Ioss::TransformFactory::create("offset"));
+  auto transform = Ioss::TransformFactory::create("offset");
   transform->set_property("offset", -1);
 
-  auto connectivity_raw =
-    vtkIOSSUtilities::GetData(group_entity, "connectivity_raw", transform.get());
+  auto connectivity_raw = vtkIOSSUtilities::GetData(group_entity, "connectivity_raw", transform);
 
   auto vtk_cell_points =
     vtkIOSSUtilities::GetNumberOfPointsInCellType(vtk_topology_type, ioss_cell_points);
diff --git a/ThirdParty/ioss/CMakeLists.txt b/ThirdParty/ioss/CMakeLists.txt
index 815efe2bbb5d44a2500fad46f74b3832cd7b1094..d36a90e286609079ef00b58500c72586eaa0fa48 100644
--- a/ThirdParty/ioss/CMakeLists.txt
+++ b/ThirdParty/ioss/CMakeLists.txt
@@ -7,9 +7,9 @@ vtk_module_third_party(
     SPDX_COPYRIGHT_TEXT
       "Copyright(C) 1999-2017 National Technology & Engineering Solutions of Sandia, LLC (NTESS)"
     SPDX_DOWNLOAD_LOCATION
-      "git+https://gitlab.kitware.com/third-party/seacas.git@ioss/for/vtk-20250313-v2025-02-27/seacas/libraries/ioss/"
+      "git+https://gitlab.kitware.com/third-party/seacas.git@ioss/for/vtk-20250924-v2025-08-28/seacas/libraries/ioss/"
     VERSION
-      "2025-02-27"
+      "2025-08-28"
     STANDARD_INCLUDE_DIRS
   EXTERNAL
     PACKAGE SEACASIoss
diff --git a/ThirdParty/ioss/update.sh b/ThirdParty/ioss/update.sh
index a9473cc0891594c97dbda7ec7423c91341ce2c85..359dacc6464c1908d3120facf5a939b64ec5af79 100755
--- a/ThirdParty/ioss/update.sh
+++ b/ThirdParty/ioss/update.sh
@@ -8,7 +8,7 @@ readonly name="ioss"
 readonly ownership="Seacas Upstream <kwrobot@kitware.com>"
 readonly subtree="ThirdParty/$name/vtk$name"
 readonly repo="https://gitlab.kitware.com/third-party/seacas.git"
-readonly tag="ioss/for/vtk-20250313-v2025-02-27"
+readonly tag="ioss/for/vtk-20250924-v2025-08-28"
 readonly paths="
 packages/seacas/libraries/ioss/src/CMakeLists.vtk.txt
 packages/seacas/libraries/ioss/cmake/SEACASIoss_config.h.in
diff --git a/ThirdParty/ioss/vtkioss/CMakeLists.txt b/ThirdParty/ioss/vtkioss/CMakeLists.txt
index 2f03c0e416aea1ba59f5b63ebdb7b0d246389a40..097d7c8d0e9c887d1603891a6e2aa5b78de77772 100644
--- a/ThirdParty/ioss/vtkioss/CMakeLists.txt
+++ b/ThirdParty/ioss/vtkioss/CMakeLists.txt
@@ -216,6 +216,7 @@ if (SEACAS_HAVE_EXONULL)
     exonull/Ioexnl_DatabaseIO
     exonull/Ioexnl_Internals
     exonull/Ioexnl_IOFactory
+    exonull/Ioexnl_SuperElement
     exonull/Ioexnl_Utils)
 endif ()
 
diff --git a/ThirdParty/ioss/vtkioss/Ioss_BasisVariableType.h b/ThirdParty/ioss/vtkioss/Ioss_BasisVariableType.h
index 3636aa783bf97d99dc414451cdab33067eb6effa..b4516120887dc18c6e7f3a59e9fa2d1194339299 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_BasisVariableType.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_BasisVariableType.h
@@ -1,5 +1,5 @@
 /*
- * Copyright(C) 2024 National Technology & Engineering Solutions
+ * Copyright(C) 2024, 2025 National Technology & Engineering Solutions
  * of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
  * NTESS, the U.S. Government retains certain rights in this software.
  *
@@ -33,7 +33,7 @@ namespace Ioss {
     std::vector<BasisComponent> basies;
   };
 
-  class IOSS_EXPORT BasisVariableType : public VariableType
+  class IOSS_EXPORT BasisVariableType final : public VariableType
   {
   public:
     //  'which' is 1-based
diff --git a/ThirdParty/ioss/vtkioss/Ioss_CodeTypes.h b/ThirdParty/ioss/vtkioss/Ioss_CodeTypes.h
index 477f0ed56322ad4148883aea55d32691815db0f2..911ed1907904ae47a53b9c666f4476e50679da6f 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_CodeTypes.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_CodeTypes.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -31,8 +31,11 @@ inline std::string IOSS_VECTOR_2D() { return {"vector_2d"}; }
 inline std::string IOSS_VECTOR_3D() { return {"vector_3d"}; }
 inline std::string IOSS_SYM_TENSOR() { return {"sym_tensor_33"}; }
 
-#if defined(BUILT_IN_SIERRA)
-#define MAP_USE_SORTED_VECTOR
+#if __has_include("SEACASIoss_config.h")
+// This is a CMake build
+#include "SEACASIoss_config.h"
+#else
+// This is not a CMake build
 #define SEACAS_HAVE_MPI
 /* #undef IOSS_THREADSAFE */
 /* #undef SEACAS_HAVE_KOKKOS */
@@ -41,8 +44,6 @@ inline std::string IOSS_SYM_TENSOR() { return {"sym_tensor_33"}; }
 #define SEACAS_HAVE_CGNS
 /* #undef SEACAS_HAVE_FAODEL */
 #define SEACAS_HAVE_PAMGEN
-#else
-#include "SEACASIoss_config.h"
 #endif
 
 #if defined(IOSS_THREADSAFE)
@@ -60,19 +61,9 @@ inline std::string IOSS_SYM_TENSOR() { return {"sym_tensor_33"}; }
 #if defined(SEACAS_HAVE_MPI)
 #include <vtk_mpi.h>
 using Ioss_MPI_Comm = MPI_Comm;
-#define IOSS_PAR_UNUSED(x)
 #define ADIOS2_USE_MPI 1
 #else
 using Ioss_MPI_Comm = int;
-#if (__cplusplus >= 201703L)
-// For C++17, we rely on IOSS_MAYBE_UNUSED instead.  Can eventually remove all IOSS_PAR_UNUSED...
-#define IOSS_PAR_UNUSED(x)
-#else
-#define IOSS_PAR_UNUSED(x)                                                                         \
-  do {                                                                                             \
-    (void)(x);                                                                                     \
-  } while (0)
-#endif
 #endif
 
 #ifdef SEACAS_HAVE_KOKKOS
@@ -112,6 +103,12 @@ using Kokkos_Complex = Kokkos::complex<double>;
 #define IOSS_DEBUG_OUTPUT 0
 #endif
 
+#ifdef NDEBUG
+#define IOSS_ASSERT_USED(x) (void)x
+#else
+#define IOSS_ASSERT_USED(x)
+#endif
+
 // For use to create a no-op get or put_field_internal function...
 #define IOSS_NOOP_GFI(type)                                                                        \
   int64_t get_field_internal(const type *, const Ioss::Field &, void *, size_t) const override     \
diff --git a/ThirdParty/ioss/vtkioss/Ioss_Compare.C b/ThirdParty/ioss/vtkioss/Ioss_Compare.C
index 6e13819fe936c33f7b1a57b4fd12cd29cc9369af..487bc9f471bc1fae91c6a5f0b1dcbce5322bab10 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_Compare.C
+++ b/ThirdParty/ioss/vtkioss/Ioss_Compare.C
@@ -185,19 +185,24 @@ bool Ioss::Compare::compare_database(Ioss::Region &input_region_1, Ioss::Region
     cs2_names = input_region_2.get_database()->internal_change_set_describe();
   }
 
-  for (const auto &cs1_name : cs1_names) {
-    auto it = std::find(cs2_names.cbegin(), cs2_names.cend(), cs1_name);
-    if (it == cs2_names.cend()) {
-      fmt::print(Ioss::WarnOut(), "Skipping change set {}, not found in input #2.\n", cs1_name);
-      continue;
-    }
+  if (cs1_names.empty() && cs2_names.empty()) {
+    overall_result &= compare_database_internal(input_region_1, input_region_2, options);
+  }
+  else {
+    for (const auto &cs1_name : cs1_names) {
+      auto it = std::find(cs2_names.cbegin(), cs2_names.cend(), cs1_name);
+      if (it == cs2_names.cend()) {
+        fmt::print(Ioss::WarnOut(), "Skipping change set {}, not found in input #2.\n", cs1_name);
+        continue;
+      }
 
-    bool success1 = open_change_set(cs1_name, input_region_1);
-    bool success2 = open_change_set(cs1_name, input_region_2);
-    if (!success1 || !success2) {
-      continue;
+      bool success1 = open_change_set(cs1_name, input_region_1);
+      bool success2 = open_change_set(cs1_name, input_region_2);
+      if (!success1 || !success2) {
+        continue;
+      }
+      overall_result &= compare_database_internal(input_region_1, input_region_2, options);
     }
-    overall_result &= compare_database_internal(input_region_1, input_region_2, options);
   }
   return overall_result;
 }
diff --git a/ThirdParty/ioss/vtkioss/Ioss_CompositeVariableType.h b/ThirdParty/ioss/vtkioss/Ioss_CompositeVariableType.h
index 2b8169a3c1d2f155c9c7a170c363a95290f99d16..243a39999c8ee6d9ecb7e1e1cbfef63bca97297b 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_CompositeVariableType.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_CompositeVariableType.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2020, 2022, 2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2020, 2022, 2024, 2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -14,7 +14,7 @@
 #include <string>              // for string
 
 namespace Ioss {
-  class IOSS_EXPORT CompositeVariableType : public VariableType
+  class IOSS_EXPORT CompositeVariableType final : public VariableType
   {
   public:
     IOSS_NODISCARD static std::string   composite_name(const std::string &base, int copies);
diff --git a/ThirdParty/ioss/vtkioss/Ioss_ConcreteVariableType.h b/ThirdParty/ioss/vtkioss/Ioss_ConcreteVariableType.h
index b5f63421c94a276634c71ea1f23f22a59cf94c18..610a6d01a0710aa6da9ed0db894502fe4baccaa0 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_ConcreteVariableType.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_ConcreteVariableType.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2020, 2022, 2023, 2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2020, 2022, 2023, 2024, 2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -22,7 +22,7 @@ namespace Ioss {
   };
 
 #define MAKE_CLASS(X)                                                                              \
-  class IOSS_EXPORT X : public VariableType                                                        \
+  class IOSS_EXPORT X final : public VariableType                                                  \
   {                                                                                                \
   public:                                                                                          \
     IOSS_NODISCARD std::string label(int which, const char suffix_sep = '_') const override;       \
@@ -38,7 +38,7 @@ namespace Ioss {
   private:                                                                                         \
   }
 
-  class IOSS_EXPORT Invalid_Storage : public VariableType
+  class IOSS_EXPORT Invalid_Storage final : public VariableType
   {
   public:
     Invalid_Storage(const Invalid_Storage &) = delete;
@@ -55,7 +55,7 @@ namespace Ioss {
     Invalid_Storage();
   };
 
-  class IOSS_EXPORT Scalar : public VariableType
+  class IOSS_EXPORT Scalar final : public VariableType
   {
   public:
     Scalar(const Scalar &) = delete;
diff --git a/ThirdParty/ioss/vtkioss/Ioss_ConstructedVariableType.h b/ThirdParty/ioss/vtkioss/Ioss_ConstructedVariableType.h
index 2a5b02271f9a4c29a00c14c2bedc8ab209a796c4..41ecb32ba1baf55d05f527cd9e38cc4d5fda0a10 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_ConstructedVariableType.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_ConstructedVariableType.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2020, 2022, 2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2020, 2022, 2024, 2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -13,7 +13,7 @@
 #include <string>              // for string
 
 namespace Ioss {
-  class IOSS_EXPORT ConstructedVariableType : public VariableType
+  class IOSS_EXPORT ConstructedVariableType final : public VariableType
   {
   public:
     IOSS_NODISCARD std::string label(int which, char suffix_sep = '_') const override;
diff --git a/ThirdParty/ioss/vtkioss/Ioss_CopyDatabase.C b/ThirdParty/ioss/vtkioss/Ioss_CopyDatabase.C
index 82198c537c1a369294bbdf90c436c422a53cea7c..8f788d5c8aefa04f4df96c68112808e608693986 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_CopyDatabase.C
+++ b/ThirdParty/ioss/vtkioss/Ioss_CopyDatabase.C
@@ -1,9 +1,12 @@
-// Copyright(C) 2021, 2022, 2023, 2024 National Technology & Engineering Solutions
+// Copyright(C) 2021, 2022, 2023, 2024, 2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
 // See packages/seacas/LICENSE for details
 
+#include <numeric>
+#include <random>
+
 #include "Ioss_CopyDatabase.h"
 #include "Ioss_DataPool.h"
 #include "Ioss_FaceGenerator.h"
@@ -259,7 +262,7 @@ void Ioss::copy_database(Ioss::Region &region, Ioss::Region &output_region,
   auto max_field = calculate_maximum_field_size(region);
   if (options.verbose && rank == 0) {
     std::string label = "MiB";
-    double      size  = (double)max_field.first / 1024 / 1024;
+    double      size  = static_cast<double>(max_field.first) / 1024.0 / 1024.0;
     if (size > 1024.0) {
       label = "GiB";
       size /= 1024.0;
@@ -310,7 +313,7 @@ void Ioss::copy_database(Ioss::Region &region, Ioss::Region &output_region,
   // to the output region based on values in `options`
   std::vector<int> selected_steps = get_selected_steps(region, options);
 
-  int step_count = (int)region.get_property("state_count").get_int();
+  int step_count = static_cast<int>(selected_steps.size() - 1);
 #ifdef SEACAS_HAVE_MPI
   int min_step_count = dbi->util().global_minmax(step_count, Ioss::ParallelUtils::DO_MIN);
   int max_step_count = dbi->util().global_minmax(step_count, Ioss::ParallelUtils::DO_MAX);
@@ -323,8 +326,8 @@ void Ioss::copy_database(Ioss::Region &region, Ioss::Region &output_region,
   }
 #endif
   for (int istep = 1; istep <= step_count; istep++) {
-    if (selected_steps[istep] == 1) {
-      transfer_step(region, output_region, data_pool, istep, options, rank);
+    if (selected_steps[istep] != 0) {
+      transfer_step(region, output_region, data_pool, selected_steps[istep], options, rank);
     }
   }
 
@@ -349,7 +352,7 @@ namespace {
     // This routine checks all steps of the input database and selects those which
     // meet the requirements specified in `options`.  The returned (1-based) vector will have a
     // value of `1` if the step is to be output and `0` if skipped.
-    int              step_count = (int)region.get_property("state_count").get_int();
+    int              step_count = static_cast<int>(region.get_property("state_count").get_int());
     std::vector<int> selected_steps(step_count + 1);
 
     // If user specified a list of times to transfer to output database,
@@ -368,7 +371,23 @@ namespace {
           }
         }
         if (selected_step > 0) {
-          selected_steps[selected_step] = 1;
+          selected_steps[selected_step] = selected_step;
+        }
+      }
+    }
+    else if (!options.selected_steps.empty()) {
+      for (const auto &step : options.selected_steps) {
+        if (step == 0 || abs(step) > step_count) {
+          fmt::print(std::cerr,
+                     "WARNING: Step {} is out of range. Must be non-zero and maximum of {}.\n",
+                     step, step_count);
+          continue;
+        }
+        if (step > 0) {
+          selected_steps[step] = step;
+        }
+        else {
+          selected_steps[step_count + 1 + step] = step_count + 1 + step;
         }
       }
     }
@@ -376,7 +395,7 @@ namespace {
       // User did not select specific times to be output...
       // Just select them all
       for (int i = 1; i <= step_count; i++) {
-        selected_steps[i] = 1;
+        selected_steps[i] = i;
       }
     }
 
@@ -390,6 +409,26 @@ namespace {
         selected_steps[istep] = 0;
       }
     }
+
+    if (options.shuffle_times) {
+      std::random_device rd;
+      std::mt19937       g(rd());
+      std::shuffle(selected_steps.begin() + 1, selected_steps.end(), g);
+    }
+
+    if (options.sort_times) {
+      std::vector<std::pair<double, size_t>> times;
+      for (size_t i = 1; i <= selected_steps.size() - 1; i++) {
+        times.emplace_back(region.get_state_time(i), selected_steps[i]);
+      }
+      std::sort(times.begin(), times.end(), [](auto &a, auto &b) { return a.first < b.first; });
+
+      size_t i = 1;
+      for (auto &[time, step] : times) {
+        selected_steps[i++] = step;
+      }
+    }
+
     return selected_steps;
   }
 
@@ -409,10 +448,10 @@ namespace {
     if (options.define_geometry && options.boundary_sideset) {
       Ioss::FaceGenerator face_generator(region);
       if (region.get_database()->int_byte_size_api() == 4) {
-        face_generator.generate_faces((int)0, false);
+        face_generator.generate_faces(static_cast<int>(0), false);
       }
       else {
-        face_generator.generate_faces((int64_t)0, false);
+        face_generator.generate_faces(static_cast<int64_t>(0), false);
       }
 
       // Get vector of all boundary faces which will be output as the skin...
@@ -671,10 +710,10 @@ namespace {
         if (ss != nullptr) {
           auto *sb = ss->get_side_block("boundary");
           if (output_region.get_database()->int_byte_size_api() == 4) {
-            output_boundary_sideset(sb, boundary, (int)0);
+            output_boundary_sideset(sb, boundary, static_cast<int>(0));
           }
           else {
-            output_boundary_sideset(sb, boundary, (int64_t)0);
+            output_boundary_sideset(sb, boundary, static_cast<int64_t>(0));
           }
         }
       }
diff --git a/ThirdParty/ioss/vtkioss/Ioss_DatabaseIO.C b/ThirdParty/ioss/vtkioss/Ioss_DatabaseIO.C
index ead55c88f747f0534151637709b90bda34b60e90..dc48d318aaee1f7c9d4d46896c4d95d7f305c6de 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_DatabaseIO.C
+++ b/ThirdParty/ioss/vtkioss/Ioss_DatabaseIO.C
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -144,9 +144,8 @@ namespace {
     }
   }
 
-  void calc_bounding_box(size_t ndim, size_t node_count, std::vector<double> &coordinates,
-                         double &xmin, double &ymin, double &zmin, double &xmax, double &ymax,
-                         double &zmax)
+  void calc_bounding_box(size_t ndim, std::vector<double> &coordinates, double &xmin, double &ymin,
+                         double &zmin, double &xmax, double &ymax, double &zmax)
   {
     xmin = DBL_MAX;
     ymin = DBL_MAX;
@@ -156,6 +155,7 @@ namespace {
     ymax = -DBL_MAX;
     zmax = -DBL_MAX;
 
+    size_t node_count = coordinates.size() / ndim;
     for (size_t i = 0; i < node_count; i++) {
       xmin = my_min(xmin, coordinates[ndim * i + 0]);
       xmax = my_max(xmax, coordinates[ndim * i + 0]);
@@ -347,7 +347,12 @@ namespace Ioss {
       }
     }
 
+    Utils::check_set_bool_property(properties, "LOWERCASE_VARIABLE_NAMES", lowerCaseVariableNames);
+    Utils::check_set_bool_property(properties, "LOWERCASE_DATABASE_NAMES", lowerCaseDatabaseNames);
+
+    // Not sure why I spelled it this way...
     Utils::check_set_bool_property(properties, "LOWER_CASE_VARIABLE_NAMES", lowerCaseVariableNames);
+    Utils::check_set_bool_property(properties, "LOWER_CASE_DATABASE_NAMES", lowerCaseDatabaseNames);
     Utils::check_set_bool_property(properties, "USE_GENERIC_CANONICAL_NAMES",
                                    useGenericCanonicalName);
     Utils::check_set_bool_property(properties, "IGNORE_DATABASE_NAMES", ignoreDatabaseNames);
@@ -654,7 +659,7 @@ namespace Ioss {
   bool DatabaseIO::begin_state(int state, double time)
   {
     IOSS_FUNC_ENTER(m_);
-    progress(__func__);
+    progress("DatabaseIO::begin_state(int state, double time)");
     if (m_timeStateInOut) {
       m_stateStart = std::chrono::steady_clock::now();
     }
@@ -668,7 +673,7 @@ namespace Ioss {
       auto finish = std::chrono::steady_clock::now();
       log_time(m_stateStart, finish, state, time, is_input(), singleProcOnly, util_);
     }
-    progress(__func__);
+    progress("DatabaseIO::end_state(int state, double time)");
     return res;
   }
 
@@ -1347,11 +1352,10 @@ namespace Ioss {
   {
     std::vector<double> coordinates;
     nb->get_field_data("mesh_model_coordinates", coordinates);
-    auto nnode = nb->entity_count();
-    auto ndim  = nb->get_property("component_degree").get_int();
+    auto ndim = nb->get_property("component_degree").get_int();
 
     double xmin, ymin, zmin, xmax, ymax, zmax;
-    calc_bounding_box(ndim, nnode, coordinates, xmin, ymin, zmin, xmax, ymax, zmax);
+    calc_bounding_box(ndim, coordinates, xmin, ymin, zmin, xmax, ymax, zmax);
 
     std::vector<double> minmax;
     minmax.reserve(6);
@@ -1371,30 +1375,28 @@ namespace Ioss {
 
   AxisAlignedBoundingBox DatabaseIO::get_bounding_box(const Ioss::StructuredBlock *sb) const
   {
-    auto ndim = sb->get_property("component_degree").get_int();
+    std::vector<double> coordinates;
+    sb->get_field_data("mesh_model_coordinates", coordinates);
 
-    std::pair<double, double> xx;
-    std::pair<double, double> yy;
-    std::pair<double, double> zz;
+    auto ndim = sb->get_property("component_degree").get_int();
 
-    std::vector<double> coordinates;
-    sb->get_field_data("mesh_model_coordinates_x", coordinates);
-    auto x = std::minmax_element(coordinates.cbegin(), coordinates.cend());
-    xx     = std::make_pair(*(x.first), *(x.second));
+    double xmin, ymin, zmin, xmax, ymax, zmax;
+    calc_bounding_box(ndim, coordinates, xmin, ymin, zmin, xmax, ymax, zmax);
 
-    if (ndim > 1) {
-      sb->get_field_data("mesh_model_coordinates_y", coordinates);
-      auto y = std::minmax_element(coordinates.cbegin(), coordinates.cend());
-      yy     = std::make_pair(*(y.first), *(y.second));
-    }
+    std::vector<double> minmax;
+    minmax.reserve(6);
+    minmax.push_back(xmin);
+    minmax.push_back(ymin);
+    minmax.push_back(zmin);
+    minmax.push_back(-xmax);
+    minmax.push_back(-ymax);
+    minmax.push_back(-zmax);
 
-    if (ndim > 2) {
-      sb->get_field_data("mesh_model_coordinates_z", coordinates);
-      auto z = std::minmax_element(coordinates.cbegin(), coordinates.cend());
-      zz     = std::make_pair(*(z.first), *(z.second));
-    }
+    util().global_array_minmax(minmax, Ioss::ParallelUtils::DO_MIN);
 
-    return {xx.first, yy.first, zz.first, xx.second, yy.second, zz.second};
+    AxisAlignedBoundingBox bbox(minmax[0], minmax[1], minmax[2], -minmax[3], -minmax[4],
+                                -minmax[5]);
+    return bbox;
   }
 
 #ifndef DOXYGEN_SKIP_THIS
diff --git a/ThirdParty/ioss/vtkioss/Ioss_DatabaseIO.h b/ThirdParty/ioss/vtkioss/Ioss_DatabaseIO.h
index 98efe580e7f6ded2892c23f020db455678e31e15..d348fb6a3d4c07614cd5fb67d1a5fa15d023b959 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_DatabaseIO.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_DatabaseIO.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -290,7 +290,7 @@ namespace Ioss {
     /** \brief If a database type supports internal change sets, open the change set
      *         specified [zero-based] index
      *
-     *  \param[in] child_index The [zero-based] index of the internal change set to open.
+     *  \param[in] set_index The [zero-based] index of the internal change set to open.
      *  \returns True if successful.
      */
     bool open_internal_change_set(int set_index)
@@ -340,7 +340,7 @@ namespace Ioss {
     bool begin(Ioss::State state)
     {
       IOSS_FUNC_ENTER(m_);
-      progress(__func__);
+      progress("Ioss::DatabaseIO::begin(Ioss::State state)");
       return begin_nl(state);
     }
 
@@ -357,7 +357,7 @@ namespace Ioss {
     bool end(Ioss::State state)
     {
       IOSS_FUNC_ENTER(m_);
-      progress(__func__);
+      progress("Ioss::DatabaseIO::end(Ioss::State state)");
       return end_nl(state);
     }
 
@@ -527,11 +527,28 @@ namespace Ioss {
       return duplicateFieldBehavior;
     }
 
+    void set_lowercase_variable_names(bool true_false) const
+    {
+      lowerCaseVariableNames = true_false;
+    }
+
+    void set_lowercase_database_names(bool true_false) const
+    {
+      lowerCaseDatabaseNames = true_false;
+    }
+
+    // Retain for backward compatibility
     void set_lower_case_variable_names(bool true_false) const
     {
       lowerCaseVariableNames = true_false;
     }
 
+    // Retain for backward compatibility
+    void set_lower_case_database_names(bool true_false) const
+    {
+      lowerCaseDatabaseNames = true_false;
+    }
+
     /* \brief Set the method used to split sidesets into homogeneous blocks.
      *
      *  \param[in] split_type The desired method.
@@ -767,7 +784,8 @@ namespace Ioss {
     mutable bool usingDataWarp{false};
     bool         isParallel{false}; //!< true if running in parallel
 
-    mutable bool lowerCaseVariableNames{true};
+    mutable bool lowerCaseVariableNames{false};
+    mutable bool lowerCaseDatabaseNames{false};
     bool         usingParallelIO{false};
 
     // List of element blocks that should be omitted or included from
diff --git a/ThirdParty/ioss/vtkioss/Ioss_Decomposition.C b/ThirdParty/ioss/vtkioss/Ioss_Decomposition.C
index 30fa04968c2b9fe5952e821370183d4c39983dd8..0dfa01abb1f3e7f456acb5978ee5ef7ac21e4600 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_Decomposition.C
+++ b/ThirdParty/ioss/vtkioss/Ioss_Decomposition.C
@@ -1,5 +1,5 @@
 /*
- * Copyright(C) 1999-2024 National Technology & Engineering Solutions
+ * Copyright(C) 1999-2025 National Technology & Engineering Solutions
  * of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
  * NTESS, the U.S. Government retains certain rights in this software.
  *
@@ -12,6 +12,7 @@
 #include "Ioss_ParallelUtils.h"
 #include "Ioss_Sort.h"
 #include "Ioss_Utils.h"
+#include "tokenize.h"
 #include <algorithm>
 #include <cassert>
 #include "vtk_fmt.h"
@@ -296,6 +297,38 @@ namespace Ioss {
       Utils::check_set_bool_property(props, "ENABLE_TRACING", m_showProgress);
     }
 
+    // Difficult to specify an integer vector through the IOSS_PROPERTIES environment variable,
+    // so if a string, parse into integer ids or if a single int, use it as is.
+    if (props.exists("DECOMP_OMITTED_BLOCK_IDS")) {
+      auto property = props.get("DECOMP_OMITTED_BLOCK_IDS");
+      if (property.get_type() == Ioss::Property::STRING) {
+        std::string id_string = property.get_string();
+        auto        omit_str  = Ioss::tokenize(id_string, ",");
+        for (const auto &str : omit_str) {
+          auto id = std::stoi(str);
+          m_omittedBlocks.push_back(id);
+        }
+      }
+      else if (property.get_type() == Ioss::Property::INTEGER) {
+        m_omittedBlocks.push_back(property.get_int());
+      }
+      else if (property.get_type() == Ioss::Property::VEC_INTEGER) {
+        std::vector<int> blocks = property.get_vec_int();
+        m_omittedBlocks.resize(blocks.size());
+        std::copy(blocks.begin(), blocks.end(), m_omittedBlocks.begin());
+      }
+      else {
+        IOSS_ERROR(fmt::format("ERROR: Unrecognized type for `DECOMP_OMITTED_BLOCK_IDS` property.  "
+                               "Should be VEC_INTEGER. Ignored.\n"));
+      }
+    }
+    if (props.exists("DECOMP_OMITTED_BLOCK_NAMES")) {
+      auto name_string = props.get("DECOMP_OMITTED_BLOCK_NAMES").get_string();
+      auto names       = Ioss::tokenize(name_string, ",");
+      for (const auto &name : names) {
+        m_omittedBlockNames.push_back(name);
+      }
+    }
     if (props.exists("PARMETIS_COMMON_NODE_COUNT") &&
         props.get("PARMETIS_COMMON_NODE_COUNT").get_int() > 0) {
       m_commonNodeCount = props.get("PARMETIS_COMMON_NODE_COUNT").get_int();
@@ -309,6 +342,19 @@ namespace Ioss {
     }
   }
 
+  template IOSS_EXPORT void
+  Decomposition<int>::set_block_omissions(const Ioss::NameList &omissions);
+  template IOSS_EXPORT void
+  Decomposition<int64_t>::set_block_omissions(const Ioss::NameList &omissions);
+
+  template <typename INT>
+  void Decomposition<INT>::set_block_omissions(const Ioss::NameList &omissions)
+  {
+    for (const auto &name : omissions) {
+      m_omittedBlockNames.push_back(name);
+    }
+  }
+
   template IOSS_EXPORT void
   Decomposition<int>::generate_entity_distributions(size_t global_node_count,
                                                     size_t global_element_count);
@@ -1096,6 +1142,9 @@ namespace Ioss {
           sizeof(ZOLTAN_ID_TYPE), lib_global_id_type_size));
     }
 
+    if (!m_omittedBlocks.empty()) {
+      zz.Set_Param("OBJ_WEIGHT_DIM", "1");
+    }
     zz.Set_Param("NUM_GID_ENTRIES", std::to_string(num_global));
     zz.Set_Param("NUM_LID_ENTRIES", "0");
     zz.Set_Param("LB_METHOD", m_method);
diff --git a/ThirdParty/ioss/vtkioss/Ioss_Decomposition.h b/ThirdParty/ioss/vtkioss/Ioss_Decomposition.h
index be62eb77d7174396cb6ba5df23022b2bfb56e239..f9275ac547bfe73f7ea6b1043e8343ecc6fdb29d 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_Decomposition.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_Decomposition.h
@@ -1,5 +1,5 @@
 /*
- * Copyright(C) 1999-2024 National Technology & Engineering Solutions
+ * Copyright(C) 1999-2025 National Technology & Engineering Solutions
  * of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
  * NTESS, the U.S. Government retains certain rights in this software.
  *
@@ -186,6 +186,8 @@ namespace Ioss {
     Decomposition &operator=(Decomposition const &) = default;
     Decomposition &operator=(Decomposition &&)      = default;
 
+    void set_block_omissions(const Ioss::NameList &omissions);
+
     IOSS_NODISCARD size_t global_node_count() const { return m_globalNodeCount; }
     IOSS_NODISCARD size_t global_elem_count() const { return m_globalElementCount; }
     IOSS_NODISCARD size_t ioss_node_count() const { return nodeGTL.size(); }
@@ -819,7 +821,9 @@ namespace Ioss {
     // The global element at index 'I' (0-based) is on block B in the
     // file decomposition.
     // if m_fileBlockIndex[B] <= I && m_fileBlockIndex[B+1] < I
-    std::vector<size_t> m_fileBlockIndex;
+    std::vector<size_t>      m_fileBlockIndex;
+    std::vector<int64_t>     m_omittedBlocks;
+    std::vector<std::string> m_omittedBlockNames;
 
   private:
     // This processor "manages" the elements on the exodus mesh file from
diff --git a/ThirdParty/ioss/vtkioss/Ioss_DecompositionUtils.C b/ThirdParty/ioss/vtkioss/Ioss_DecompositionUtils.C
index d9e06aff15dbd77a890204a8ee0e31f6bde2fe01..8530faa8c619876596d59ed41a0b15687a805051 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_DecompositionUtils.C
+++ b/ThirdParty/ioss/vtkioss/Ioss_DecompositionUtils.C
@@ -1,5 +1,5 @@
 /*
- * Copyright(C) 2024 National Technology & Engineering Solutions
+ * Copyright(C) 2024, 2025 National Technology & Engineering Solutions
  * of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
  * NTESS, the U.S. Government retains certain rights in this software.
  *
@@ -161,7 +161,7 @@ namespace Ioss {
     auto hist_max = *std::max_element(histogram.begin(), histogram.end());
     for (size_t i = 0; i < hist_size; i++) {
       int         max_star = 50;
-      int         star_cnt = ((double)histogram[i] / hist_max * max_star);
+      int         star_cnt = (static_cast<double>(histogram[i]) / hist_max * max_star);
       std::string stars(star_cnt, '*');
       for (int j = 9; j < star_cnt;) {
         stars[j] = '|';
@@ -492,21 +492,22 @@ namespace Ioss {
       fmt::print("\nWork per processor:\n\tMinimum = {}, Maximum = {}, Median = {}, Ratio = "
                  "{:.3}\n\n",
                  fmt::group_digits(min_work), fmt::group_digits(max_work),
-                 fmt::group_digits(median), (double)(max_work) / min_work);
+                 fmt::group_digits(median), static_cast<double>(max_work) / min_work);
     }
     if (min_work == max_work) {
       fmt::print("Work on all processors is {}\n\n", fmt::group_digits(min_work));
     }
     else {
       int max_star = 40;
-      int min_star = max_star * ((double)min_work / (double)(max_work));
+      int min_star = max_star * (static_cast<double>(min_work) / static_cast<double>(max_work));
       min_star     = std::max(1, min_star);
       int delta    = max_star - min_star;
 
-      avg_work = (double)total_work / (double)proc_count;
+      avg_work = static_cast<double>(total_work) / static_cast<double>(proc_count);
       for (size_t i = 0; i < work_per_rank.size(); i++) {
         int star_cnt =
-            (double)(work_per_rank[i] - min_work) / (max_work - min_work) * delta + min_star;
+            static_cast<double>(work_per_rank[i] - min_work) / (max_work - min_work) * delta +
+            min_star;
         std::string stars(star_cnt, '*');
         auto tmp = fmt::format(fmt::runtime("\tProcessor {:{}}, work = {:{}}  ({:.2f})\t{}\n"), i,
                                proc_width, fmt::group_digits(work_per_rank[i]), work_width,
@@ -533,8 +534,8 @@ namespace Ioss {
     // "max_work" is done.  Penalty = max_work / avg_work.
     fmt::print("\nImbalance Penalty:\n\tMaximum Work = {}, Average Work = {}, Penalty (max/avg) "
                "= {:.2f}\n\n",
-               fmt::group_digits(max_work), fmt::group_digits((size_t)avg_work),
-               (double)max_work / avg_work);
+               fmt::group_digits(max_work), fmt::group_digits(static_cast<size_t>(avg_work)),
+               static_cast<double>(max_work) / avg_work);
 
     return std::make_pair(avg_work, median);
   }
diff --git a/ThirdParty/ioss/vtkioss/Ioss_Doxygen.h b/ThirdParty/ioss/vtkioss/Ioss_Doxygen.h
index f5132e2515ea0b8f8d365f156ce40072efacd64c..797f87acf9e46ac3f92e3b8f48851ca50fb01fc7 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_Doxygen.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_Doxygen.h
@@ -46,7 +46,8 @@ par_cgns         | Input/Output  | alias for parallel CGNS
   Property | Value    | Description
  ----------|:--------:|------------
  LOGGING   | on/[off] | enable/disable logging of field input/output
- LOWER_CASE_VARIABLE_NAMES | [on]/off | Convert all variable names read from input database to lowercase; replace ' ' with '_'
+ LOWERCASE_VARIABLE_NAMES | [on]/off | Convert all variable names read from input database to lowercase; replace ' ' with '_'
+ LOWERCASE_DATABASE_NAMES | on/[off] | Convert all block/set names read from input database to lowercase; replace ' ' with '_'
  USE_GENERIC_CANONICAL_NAMES | on/[off]  | use `block_{id}` as canonical name of an element block instead of the name (if any) stored on the database. The database name will be an alias.
  IGNORE_DATABASE_NAMES | on/[off] | Do not read any element block, nodeset, ... names if they exist on the database.  Use only the canonical generated names (entitytype + _ + id)
  IGNORE_ATTRIBUTE_NAMES   | on/[off] | Do not read the attribute names that may exist on an input database. Instead for an element block with N attributes, the fields will be named `attribute_1` ... `attribute_N`
@@ -64,6 +65,9 @@ PARALLEL_CONSISTENCY | [on]/off | On if the client will call Ioss functions cons
 RETAIN_FREE_NODES | [on]/off | In auto-decomp, will nodes not connected to any elements be retained.
 LOAD_BALANCE_THRESHOLD | {real} [1.4] | CGNS-Structured only -- Load imbalance permitted Load on Proc / Avg Load
 DECOMPOSITION_EXTRA | {name},{multiplier} | Specify the name of the element map or variable used if the decomposition method is `map` or `variable`.  If it contains a comma, the value following the comma is used to scale (divide) the values in the map/variable.  If it is 'auto', then all values will be scaled by `max_value/processorCount`
+DECOMP_OMITTED_BLOCK_IDS | {id_list} | A integer vector containing the
+element block ids that should be ignored during the parallel decomposition. The blocks will still appear in the decomposition, but will not affect the load balance. If specified via `IOSS_PROPERTIES` can be a comma-separated string of ids.
+DECOMP_OMITTED_BLOCK_NAMES | {name_list} | A comma-separated list of block names that should be ignored during the parallel decomposition. The blocks will still appear in the decomposition, but will not affect the load balance. 
 
 ### Valid values for Decomposition Method
 
@@ -130,6 +134,11 @@ PARALLEL_IO_MODE | netcdf4, hdf5, pnetcdf, (mpiio and mpiposix are deprecated)
  CYCLE_COUNT           | {cycle}  | If using FILE_PER_STATE, then use {cycle} different files and then overwrite. Otherwise, there will be a maximum of {cycle} time steps in the file. See below.
  OVERLAY_COUNT         | {overlay}| If using FILE_PER_STATE, then put {overlay} timesteps worth of data into each file before going to next file. Otherwise, each output step in the file will be overwritten {overlay} times. See below.
  ENABLE_DATAWARP       | on/[off] | If the system supports Cray DataWarp (burst buffer), should it be used for buffering output files.
+## Deprecated Database-Related Properties
+ Property        | Value  | Description
+-----------------|:------:|-----------------------------------------------------------
+ LOWER_CASE_VARIABLE_NAMES | [on]/off | Use LOWERCASE_VARIABLE_NAMES
+ LOWER_CASE_DATABASE_NAMES | on/[off] | Use LOWERCASE_DATABASE_NAMES
 
 ### Cycle and Overlay Behavior:
 (Properties `CYCLE_COUNT`, `OVERLAY_COUNT`, and `FILE_PER_STATE`)
@@ -224,7 +233,7 @@ throughout the file.
  ENABLE_TRACING | on/[off] | show memory and elapsed time during some IOSS calls (mainly decomp).
  DECOMP_SHOW_PROGRESS | on/[off] | use `ENABLE_TRACING`.
  DECOMP_SHOW_HWM      | on/[off] | show high-water memory during autodecomp
- IOSS_TIME_FILE_OPEN_CLOSE | on/[off] | show elapsed time during parallel-io file open/close/create
+ IOSS_TIME_FILE_OPEN_CLOSE | on/[off] | show elapsed time during parallel-io file open/close/create/flush
  CHECK_PARALLEL_CONSISTENCY | on/[off] | check Ioss::GroupingEntity parallel consistency
  TIME_STATE_INPUT_OUTPUT | on/[off] | show the elapsed time for reading/writing each timestep's data
 
diff --git a/ThirdParty/ioss/vtkioss/Ioss_EdgeBlock.h b/ThirdParty/ioss/vtkioss/Ioss_EdgeBlock.h
index 7db45414b9adec006dbaff0f02ca08f25302b59d..9b28a9485dbe245be480c66723ac07955944b22d 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_EdgeBlock.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_EdgeBlock.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2020, 2022, 2023, 2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2020, 2022, 2023, 2024, 2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -26,7 +26,7 @@ namespace Ioss {
 
   /** \brief A collection of element edges with the same topology.
    */
-  class IOSS_EXPORT EdgeBlock : public EntityBlock
+  class IOSS_EXPORT EdgeBlock final : public EntityBlock
   {
   public:
     EdgeBlock(DatabaseIO *io_database, const std::string &my_name, const std::string &edge_type,
diff --git a/ThirdParty/ioss/vtkioss/Ioss_EdgeSet.h b/ThirdParty/ioss/vtkioss/Ioss_EdgeSet.h
index 2c168bf9b659cf36e351c8405681efbc8a7d13e7..eb6a2ab7ed31225d63cb6450ae0d48b2f8e2e2bd 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_EdgeSet.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_EdgeSet.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2020, 2022, 2023, 2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2020, 2022, 2023, 2024, 2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -27,7 +27,7 @@ namespace Ioss {
 
   /** \brief A collection of element edges.
    */
-  class IOSS_EXPORT EdgeSet : public EntitySet
+  class IOSS_EXPORT EdgeSet final : public EntitySet
   {
   public:
     EdgeSet(); // Used for template typing only
diff --git a/ThirdParty/ioss/vtkioss/Ioss_ElementBlock.h b/ThirdParty/ioss/vtkioss/Ioss_ElementBlock.h
index e1fdf3e0faa58abde0f980242cc41129fa2127bf..de5358193f8f28eac23150bae7371ed84e2d9ee5 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_ElementBlock.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_ElementBlock.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -26,7 +26,7 @@ namespace Ioss {
 
   /** \brief A collection of elements having the same topology.
    */
-  class IOSS_EXPORT ElementBlock : public EntityBlock
+  class IOSS_EXPORT ElementBlock final : public EntityBlock
   {
   public:
     ElementBlock(DatabaseIO *io_database, const std::string &my_name,
diff --git a/ThirdParty/ioss/vtkioss/Ioss_ElementSet.h b/ThirdParty/ioss/vtkioss/Ioss_ElementSet.h
index 35fab130f93267d049ff90433e3212c7f2d3725f..7fcceab2ba8a5d1b2ace3ded1f2e4903a09d0417 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_ElementSet.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_ElementSet.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2020, 2022, 2023, 2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2020, 2022, 2023, 2024, 2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -27,7 +27,7 @@ namespace Ioss {
 
   /** \brief A collection of elements.
    */
-  class IOSS_EXPORT ElementSet : public EntitySet
+  class IOSS_EXPORT ElementSet final : public EntitySet
   {
   public:
     ElementSet(); // Used for template typing only
diff --git a/ThirdParty/ioss/vtkioss/Ioss_EntityBlock.C b/ThirdParty/ioss/vtkioss/Ioss_EntityBlock.C
index 24141953c8cb92a65a6aee8d3f9f4136de934085..25fd96f077e4b0d8f29d37d68e05b6845f9522db 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_EntityBlock.C
+++ b/ThirdParty/ioss/vtkioss/Ioss_EntityBlock.C
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2023 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
diff --git a/ThirdParty/ioss/vtkioss/Ioss_EntityBlock.h b/ThirdParty/ioss/vtkioss/Ioss_EntityBlock.h
index e0d0d145f977cc58205f4561d3b3e02713981ffd..ecb357eee86f079ed9c08a6817346a86d2e3c549 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_EntityBlock.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_EntityBlock.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2020, 2022, 2023, 2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2020, 2022, 2023, 2024, 2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -55,7 +55,7 @@ namespace Ioss {
      */
     IOSS_NODISCARD bool contains(size_t local_id) const
     {
-      return idOffset < local_id && local_id <= idOffset + entityCount;
+      return idOffset < local_id && local_id <= idOffset + entity_count();
     }
     /** \brief Set the 'offset' for the block.
      *
diff --git a/ThirdParty/ioss/vtkioss/Ioss_FaceBlock.h b/ThirdParty/ioss/vtkioss/Ioss_FaceBlock.h
index ae3fc984b757e5f594ed52f1eb418817ad0fe67c..cc03a650188c42703b753f6bbb83f47f4eefdbf8 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_FaceBlock.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_FaceBlock.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2020, 2022, 2023, 2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2020, 2022, 2023, 2024, 2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -26,7 +26,7 @@ namespace Ioss {
 
   /** \brief A collection of element faces with the same topology.
    */
-  class IOSS_EXPORT FaceBlock : public EntityBlock
+  class IOSS_EXPORT FaceBlock final : public EntityBlock
   {
   public:
     FaceBlock(DatabaseIO *io_database, const std::string &my_name, const std::string &face_type,
diff --git a/ThirdParty/ioss/vtkioss/Ioss_FaceGenerator.C b/ThirdParty/ioss/vtkioss/Ioss_FaceGenerator.C
index 75dee68f3d9e88cc813872c6f658fba5eab8ae82..52b0a8ef48ac690cb099d6c324ea51e10be364b7 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_FaceGenerator.C
+++ b/ThirdParty/ioss/vtkioss/Ioss_FaceGenerator.C
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -108,10 +108,6 @@ namespace {
                               IOSS_MAYBE_UNUSED Ioss::FaceUnorderedSet &faces,
                               IOSS_MAYBE_UNUSED const std::vector<size_t> &hash_ids, INT /*dummy*/)
   {
-    IOSS_PAR_UNUSED(region);
-    IOSS_PAR_UNUSED(faces);
-    IOSS_PAR_UNUSED(hash_ids);
-
 #ifdef SEACAS_HAVE_MPI
     size_t proc_count = region.get_database()->util().parallel_size();
 
diff --git a/ThirdParty/ioss/vtkioss/Ioss_FaceSet.h b/ThirdParty/ioss/vtkioss/Ioss_FaceSet.h
index 73faecfae9ae5002ef438f7c337bf4b06dc65776..51b6937a6d127b676d48eb1e1d8aa8d73e0cc019 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_FaceSet.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_FaceSet.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2020, 2022, 2023, 2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2020, 2022, 2023, 2024, 2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -27,7 +27,7 @@ namespace Ioss {
 
   /** \brief A collection of element faces.
    */
-  class IOSS_EXPORT FaceSet : public EntitySet
+  class IOSS_EXPORT FaceSet final : public EntitySet
   {
   public:
     FaceSet(); // Used for template typing only
diff --git a/ThirdParty/ioss/vtkioss/Ioss_Field.C b/ThirdParty/ioss/vtkioss/Ioss_Field.C
index 7fdbe575ed577e57f0f2b60614bca7894b0eb5cc..e368b4eee5328c0045a9d74f443cd0291d787b35 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_Field.C
+++ b/ThirdParty/ioss/vtkioss/Ioss_Field.C
@@ -47,17 +47,20 @@ namespace Ioss {
     }
     auto storage = fld.raw_storage()->name();
     if (storage == "scalar") {
-      fmt::print(os, "\tField: {}, Storage: {}\t{}\t{}\n", fld.get_name(),
+      fmt::print(os, "\tField: {}, Storage: {},\t{},\t{}\n", fld.get_name(),
                  fld.raw_storage()->name(), fld.type_string(), fld.role_string());
     }
     else {
+      auto suffix0 = fld.get_suffix_separator(0);
+      auto suffix1 = fld.get_suffix_separator(1);
+      suffix0      = suffix0 == 1 ? '_' : suffix0;
+      suffix1      = suffix1 == 1 ? '_' : suffix1;
       fmt::print(os,
                  "\tField: {}, Storage: {} ({}),\t{},\t{}, Sep1: '{}', Sep2: '{}'\n"
                  "\t\t\tComponents ({}): {}\n",
                  fld.get_name(), fld.raw_storage()->name(), fld.raw_storage()->type_string(),
-                 fld.type_string(), fld.role_string(), fld.get_suffix_separator(0),
-                 fld.get_suffix_separator(1), fld.get_component_count(Field::InOut::INPUT),
-                 fmt::join(components, ", "));
+                 fld.type_string(), fld.role_string(), suffix0, suffix1,
+                 fld.get_component_count(Field::InOut::INPUT), fmt::join(components, ", "));
     }
     return os;
   }
@@ -303,7 +306,7 @@ bool Ioss::Field::add_transform(Transform *my_transform)
     size_ = size;
   }
 
-  transforms_.push_back(my_transform);
+  transforms_.emplace_back(my_transform);
   return true;
 }
 
diff --git a/ThirdParty/ioss/vtkioss/Ioss_Field.h b/ThirdParty/ioss/vtkioss/Ioss_Field.h
index 2c61e512217f5316b292838cb67c721f50c456db..f0e2a4b93f7471a435ef581071719c3e0bca13b5 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_Field.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_Field.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -7,10 +7,13 @@
 #pragma once
 
 #include "Ioss_CodeTypes.h"
-#include <cstddef> // for size_t
+#include "Ioss_Transform.h"
+
+#include <cstddef>
+#include <memory>
 #include <stdint.h>
-#include <string> // for string
-#include <vector> // for vector
+#include <string>
+#include <vector>
 
 #include "ioss_export.h"
 #include "vtk_ioss_mangle.h"
@@ -235,9 +238,9 @@ namespace Ioss {
     const VariableType *rawStorage_{nullptr};   // Storage type of raw field
     const VariableType *transStorage_{nullptr}; // Storage type after transformation
 
-    std::vector<Transform *> transforms_{};
-    char                     suffixSeparator1_{1}; // Value = 1 means unset; use database default.
-    char                     suffixSeparator2_{1}; // Value = 1 means unset; use database default.
+    std::vector<std::shared_ptr<Transform>> transforms_{};
+    char         suffixSeparator1_{1};      // Value = 1 means unset; use database default.
+    char         suffixSeparator2_{1};      // Value = 1 means unset; use database default.
     bool         sufficesUppercase_{false}; // True if the suffices are uppercase on database...
     mutable bool zeroCopyable_{false};      // True if the field is zero-copyable.
 
diff --git a/ThirdParty/ioss/vtkioss/Ioss_FileInfo.C b/ThirdParty/ioss/vtkioss/Ioss_FileInfo.C
index ded57b377ec5a073caf6f9da6d64f84518a000d6..97c5e4bbb40644f4669f5e45d68a2387e9d9fe2d 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_FileInfo.C
+++ b/ThirdParty/ioss/vtkioss/Ioss_FileInfo.C
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -91,8 +91,6 @@ namespace Ioss {
   int FileInfo::parallel_exists(IOSS_MAYBE_UNUSED Ioss_MPI_Comm communicator,
                                 IOSS_MAYBE_UNUSED std::string &where) const
   {
-    IOSS_PAR_UNUSED(communicator);
-    IOSS_PAR_UNUSED(where);
     int sum = exists_ ? 1 : 0;
 
 #ifdef SEACAS_HAVE_MPI
@@ -169,6 +167,44 @@ namespace Ioss {
     return false;
   }
 
+  std::string_view FileInfo::filesystem_type() const
+  {
+#if !defined(__IOSS_WINDOWS__)
+    auto tmp_path = pathname();
+    if (tmp_path.empty()) {
+      char *current_cwd = getcwd(nullptr, 0);
+      tmp_path          = std::string(current_cwd);
+      free(current_cwd);
+    }
+    char *path = ::realpath(tmp_path.c_str(), nullptr);
+    if (path != nullptr) {
+
+      struct statfs stat_fs;
+      // We want to run `statfs` on the path; not the filename since it might not exist.
+      if (statfs(path, &stat_fs) == -1) {
+        free(path);
+        std::ostringstream errmsg;
+        errmsg << "ERROR: Could not run statfs on '" << filename_ << "'.\n";
+        IOSS_ERROR(errmsg);
+      }
+      free(path);
+
+#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
+      return stat_fs.f_fstypename;
+#else
+      /* linux statfs defines that 0x6969 is NFS filesystem */
+      if (stat_fs.f_type == 0x0BD00BD0)
+        return "lustre";
+      if (stat_fs.f_type == 0x47504653)
+        return "gpfs";
+      if (stat_fs.f_type == 0x6969)
+        return "nfs";
+#endif
+    }
+#endif
+    return "unknown";
+  }
+
   //: Return TRUE if file is on an NFS filesystem...
   bool FileInfo::is_nfs() const
   {
@@ -388,7 +424,6 @@ namespace Ioss {
   void FileInfo::create_path(const std::string              &filename,
                              IOSS_MAYBE_UNUSED Ioss_MPI_Comm communicator)
   {
-    IOSS_PAR_UNUSED(communicator);
 #ifdef SEACAS_HAVE_MPI
     int                error_found = 0;
     std::ostringstream errmsg;
diff --git a/ThirdParty/ioss/vtkioss/Ioss_FileInfo.h b/ThirdParty/ioss/vtkioss/Ioss_FileInfo.h
index c29c32b6795ec92e2ecc846cce17b4d2c5329ce9..a6ed96fa78271b846f4ff0fb2a56113870888b8f 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_FileInfo.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_FileInfo.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2020, 2022, 2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2020, 2022, 2024, 2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -75,6 +75,8 @@ namespace Ioss {
 
     IOSS_NODISCARD off_t size() const; //!< File size in bytes. Only if is_file() == true
 
+    IOSS_NODISCARD std::string_view
+    filesystem_type() const; //!< Best guess at filesystem type (nfs, lustre, gpfs, unknown)
     IOSS_NODISCARD std::string filename() const;  //!< Complete filename including path
     IOSS_NODISCARD std::string basename() const;  //!< strip path and extension
     IOSS_NODISCARD std::string tailname() const;  //!< basename() + extension()
diff --git a/ThirdParty/ioss/vtkioss/Ioss_Getline.C b/ThirdParty/ioss/vtkioss/Ioss_Getline.C
index 299c22e2f6b64007d74fbf4e0da0be8a50ab1c2f..b6f862ed0e07be25f7ded2c3d120cf2cb1f19829 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_Getline.C
+++ b/ThirdParty/ioss/vtkioss/Ioss_Getline.C
@@ -1,6 +1,7 @@
 
 /*
- * Copyright (C) 1991, 1992, 1993, 2021, 2022, 2023, 2024 by Chris Thewalt (thewalt@ce.berkeley.edu)
+ * Copyright (C) 1991, 1992, 1993, 2021, 2022, 2023, 2024, 2025 by Chris Thewalt
+ * (thewalt@ce.berkeley.edu)
  *
  * Permission to use, copy, modify, and distribute this software
  * for any purpose and without fee is hereby granted, provided
@@ -125,7 +126,7 @@ namespace {
 #endif
 
 namespace {
-#if defined(__EMSCRIPTEN__) || defined(__unix__)
+#if defined(__EMSCRIPTEN__) || (defined(__unix__) && !defined(NO_TERMIOS))
 #ifdef __EMSCRIPTEN__
 #include <termios.h>
 #elif __unix__
@@ -137,7 +138,7 @@ namespace {
 
   void gl_char_init() /* turn off input echo */
   {
-#ifdef __unix__
+#if defined(__unix__) && !defined(NO_TERMIOS)
     tcgetattr(0, &io_old_termios);
     io_new_termios = io_old_termios;
     io_new_termios.c_iflag &= ~(BRKINT | ISTRIP | IXON | IXOFF);
@@ -151,7 +152,7 @@ namespace {
 
   void gl_char_cleanup() /* undo effects of gl_char_init */
   {
-#ifdef __unix__
+#if defined(__unix__) && !defined(NO_TERMIOS)
     tcsetattr(0, TCSANOW, &io_old_termios);
 #endif /* __unix__ */
   }
@@ -208,7 +209,7 @@ namespace {
   int gl_getc()
   /* get a character without echoing it to screen */
   {
-#ifdef __unix__
+#if defined(__unix__)
     char ch;
     int  c;
     while ((c = read(0, &ch, 1)) == -1) {
@@ -249,11 +250,9 @@ namespace {
     char ch = (char)(unsigned char)c;
 
     IOSS_MAYBE_UNUSED auto result = write(1, &ch, 1);
-    IOSS_PAR_UNUSED(result);
     if (ch == '\n') {
       ch     = '\r';
       result = write(1, &ch, 1); /* RAW mode needs '\r', does not hurt */
-      IOSS_PAR_UNUSED(result);
     }
   }
 
@@ -264,7 +263,6 @@ namespace {
     if (buf) {
       int                    len    = strlen(buf);
       IOSS_MAYBE_UNUSED auto result = write(1, buf, len);
-      IOSS_PAR_UNUSED(result);
     }
   }
 
@@ -274,7 +272,6 @@ namespace {
 
     gl_cleanup();
     IOSS_MAYBE_UNUSED auto result = write(2, buf, len);
-    IOSS_PAR_UNUSED(result);
     exit(1);
   }
 
diff --git a/ThirdParty/ioss/vtkioss/Ioss_Glob.h b/ThirdParty/ioss/vtkioss/Ioss_Glob.h
index 34b4fcd60626c3491d8343902e89cb2e0cd41824..1cd3f94400bbf6705639ef8407136b79ee2fdfa4 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_Glob.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_Glob.h
@@ -840,6 +840,7 @@ namespace Ioss::glob {
   template <class charT> class AstVisitor
   {
   public:
+    virtual ~AstVisitor() = default;
 // define all visitor methods for the nodes
 #define DECLARE_VIRTUAL_FUNC(type)                                                                 \
   virtual void Visit##type(type<charT> * /*node*/) {}
diff --git a/ThirdParty/ioss/vtkioss/Ioss_GroupingEntity.C b/ThirdParty/ioss/vtkioss/Ioss_GroupingEntity.C
index c455d460b329f53d6c3d1fe6fc79ed36b7439c3f..1f0224fcf27281c123752f2d4bf647e4ae59a2cd 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_GroupingEntity.C
+++ b/ThirdParty/ioss/vtkioss/Ioss_GroupingEntity.C
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -34,11 +34,11 @@
  */
 Ioss::GroupingEntity::GroupingEntity(Ioss::DatabaseIO *io_database, const std::string &my_name,
                                      int64_t entity_cnt)
-    : entityCount(entity_cnt), entityName(my_name), database_(io_database),
+    : entityName(my_name), database_(io_database), entityCount(entity_cnt),
       hash_(Ioss::Utils::hash(my_name))
 {
-  properties.add(Ioss::Property("name", my_name));
-  properties.add(Ioss::Property("entity_count", entity_cnt));
+  properties.add(Ioss::Property(this, "name", Ioss::Property::STRING));
+  properties.add(Ioss::Property(this, "entity_count", Ioss::Property::INTEGER));
   properties.add(Ioss::Property(this, "attribute_count", Ioss::Property::INTEGER));
 
   if (my_name != "null_entity") {
@@ -51,8 +51,8 @@ Ioss::GroupingEntity::GroupingEntity(Ioss::DatabaseIO *io_database, const std::s
 }
 
 Ioss::GroupingEntity::GroupingEntity(const Ioss::GroupingEntity &other)
-    : properties(other.properties), fields(other.fields), entityCount(other.entityCount),
-      entityName(other.entityName), attributeCount(other.attributeCount),
+    : properties(other.properties), fields(other.fields), entityName(other.entityName),
+      entityCount(other.entityCount), attributeCount(other.attributeCount),
       entityState(other.entityState), hash_(other.hash_)
 {
 }
@@ -99,20 +99,6 @@ Ioss::DatabaseIO *Ioss::GroupingEntity::get_database() const
   return database_;
 }
 
-/** \brief Get the file name associated with the database containing this entity.
- *
- *  \returns The file name.
- */
-std::string Ioss::GroupingEntity::get_filename() const
-{
-  // Ok for database_ to be nullptr at this point.
-  if (database_ == nullptr) {
-    return {};
-  }
-
-  return database_->get_filename();
-}
-
 void Ioss::GroupingEntity::set_database(Ioss::DatabaseIO *io_database)
 {
   assert(database_ == nullptr);   // Must be unset if we are setting it.
@@ -158,6 +144,12 @@ Ioss::Property Ioss::GroupingEntity::get_implicit_property(const std::string &my
 {
   // Handle properties generic to all GroupingEntities.
   // These include:
+  if (my_name == "entity_count") {
+    return {my_name, entityCount};
+  }
+  if (my_name == "name") {
+    return {my_name, entityName};
+  }
   if (my_name == "attribute_count") {
     count_attributes();
     return {my_name, static_cast<int>(attributeCount)};
diff --git a/ThirdParty/ioss/vtkioss/Ioss_GroupingEntity.h b/ThirdParty/ioss/vtkioss/Ioss_GroupingEntity.h
index 9eaef2efc89b24babfdf1b9f52b2a38d200eb88c..87ce45474947901c03d26b093d2305669781907c 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_GroupingEntity.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_GroupingEntity.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -131,8 +131,6 @@ namespace Ioss {
      */
     virtual void block_membership(Ioss::NameList & /* block_members */) {}
 
-    IOSS_NODISCARD std::string get_filename() const;
-
     /** \brief Get the name of the particular type of entity.
      *
      *  \returns The name of the particular type of entity.
@@ -258,7 +256,8 @@ namespace Ioss {
 
     IOSS_NODISCARD unsigned int hash() const { return hash_; }
 
-    IOSS_NODISCARD int64_t entity_count() const { return get_property("entity_count").get_int(); }
+    IOSS_NODISCARD int64_t entity_count() const;
+    int64_t                reset_entity_count(int64_t new_entity_count) const;
 
     // COMPARE GroupingEntities
     IOSS_NODISCARD bool operator!=(const GroupingEntity &rhs) const;
@@ -299,8 +298,6 @@ namespace Ioss {
     virtual int64_t internal_get_zc_field_data(const Field &field, void **data,
                                                size_t *data_size) const = 0;
 
-    int64_t entityCount = 0;
-
 #if defined(IOSS_THREADSAFE)
     mutable std::mutex m_;
 #endif
@@ -314,6 +311,7 @@ namespace Ioss {
 
     DatabaseIO *database_ = nullptr;
 
+    mutable int64_t entityCount    = 0;
     mutable int64_t attributeCount = 0;
     State           entityState    = STATE_CLOSED;
     unsigned int    hash_          = 0;
@@ -375,6 +373,15 @@ Ioss::GroupingEntity::get_optional_property(const std::string &property_name,
   return properties.get_optional(property_name, optional_value);
 }
 
+inline int64_t Ioss::GroupingEntity::entity_count() const { return entityCount; }
+
+inline int64_t Ioss::GroupingEntity::reset_entity_count(int64_t new_entity_count) const
+{
+  int64_t save_entity_count = entityCount;
+  entityCount               = new_entity_count;
+  return save_entity_count;
+}
+
 /** \brief Get the names of all properties in the property manager for this entity.
  *
  * \returns The property names in the property manager.
diff --git a/ThirdParty/ioss/vtkioss/Ioss_Map.C b/ThirdParty/ioss/vtkioss/Ioss_Map.C
index 1445070306b563387f3805be901563da33187735..77e2689d40dd8d55a511da724381cc13ad85f747 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_Map.C
+++ b/ThirdParty/ioss/vtkioss/Ioss_Map.C
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -589,15 +589,19 @@ void Ioss::Map::build_reorder_map_nl(int64_t start, int64_t count)
 // Sierra wants entities in a global system. These routines
 // take care of the mapping from local <-> global
 
-int64_t Ioss::Map::global_to_local(int64_t global, bool must_exist) const
+int64_t Ioss::Map::global_to_local(int64_t global, bool must_exist, bool output_error) const
 {
   IOSS_FUNC_ENTER(m_);
-  return global_to_local_nl(global, must_exist);
+  return global_to_local_nl(global, must_exist, output_error);
 }
 
-int64_t Ioss::Map::global_to_local_nl(int64_t global, bool must_exist) const
+int64_t Ioss::Map::global_to_local_nl(int64_t global, bool must_exist, bool output_error) const
 {
   int64_t local = global;
+
+  // The case where `must_exist==false && output_error == true` is for improving parallel error
+  // reporting, so for all intents, it is `must_exist == true` in the logic below...
+  bool should_exist = must_exist || output_error;
 #if defined USE_LAZY_REVERSE
   if (!is_sequential() && m_reverse.empty() && m_reorder.empty()) {
     auto *new_this = const_cast<Ioss::Map *>(this);
@@ -630,7 +634,7 @@ int64_t Ioss::Map::global_to_local_nl(int64_t global, bool must_exist) const
     }
 #endif
   }
-  else if (!must_exist && global > static_cast<int64_t>(m_map.size()) - 1) {
+  else if (!should_exist && global > static_cast<int64_t>(m_map.size()) - 1) {
     local = 0;
   }
   else {
@@ -656,5 +660,13 @@ int64_t Ioss::Map::global_to_local_nl(int64_t global, bool must_exist) const
                m_entityType, global, m_myProcessor, m_filename);
     IOSS_ERROR(errmsg);
   }
+  else if (local <= 0 && should_exist) {
+    fmt::print(stderr,
+               "ERROR: Ioss Mapping routines could not find a {0} with global id equal to {1} in "
+               "the {0} map\n"
+               "on processor {2}, filename '{3}'.\n"
+               "This should not happen, please report.\n",
+               m_entityType, global, m_myProcessor, m_filename);
+  }
   return local;
 }
diff --git a/ThirdParty/ioss/vtkioss/Ioss_Map.h b/ThirdParty/ioss/vtkioss/Ioss_Map.h
index fe0ef92d9761d247587319e6249994e8d02b4da7..0b190a76a138daa800708185032b399a1f355b09 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_Map.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_Map.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2020, 2022, 2023, 2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2020, 2022, 2023, 2024, 2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -16,7 +16,7 @@
 #include "ioss_export.h"
 #include "vtk_ioss_mangle.h"
 
-#define MAP_USE_STD
+#define MAP_USE_SORTED_VECTOR
 #if defined MAP_USE_STD
 #include <unordered_map>
 #elif defined MAP_USE_HOPSCOTCH
@@ -65,7 +65,8 @@ namespace Ioss {
     // Determines whether the input map is sequential (m_map[i] == i)
     IOSS_NODISCARD bool is_sequential(bool check_all = false) const;
 
-    IOSS_NODISCARD int64_t global_to_local(int64_t global, bool must_exist = true) const;
+    IOSS_NODISCARD int64_t global_to_local(int64_t global, bool must_exist = true,
+                                           bool output_error = false) const;
 
     template <typename INT>
     bool set_map(INT *ids, size_t count, size_t offset, bool in_define_mode = true);
@@ -101,7 +102,8 @@ namespace Ioss {
     template <typename INT> void map_data(INT *data, size_t count) const;
     template <typename INT> void map_implicit_data(INT *data, size_t count, size_t offset) const;
 
-    int64_t global_to_local_nl(int64_t global, bool must_exist = true) const;
+    int64_t global_to_local_nl(int64_t global, bool must_exist = true,
+                               bool output_error = false) const;
     void    build_reorder_map_nl(int64_t start, int64_t count);
     void    build_reverse_map_nl(int64_t num_to_get, int64_t offset);
 #if defined MAP_USE_SORTED_VECTOR
diff --git a/ThirdParty/ioss/vtkioss/Ioss_MeshCopyOptions.h b/ThirdParty/ioss/vtkioss/Ioss_MeshCopyOptions.h
index 5ec795cadcfbaa587a3754de5164511adc0c7436..edb9396e739a636688a84c5ec864498523723032 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_MeshCopyOptions.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_MeshCopyOptions.h
@@ -1,6 +1,6 @@
 #pragma once
 /*
- * Copyright(C) 1999-2024 National Technology & Engineering Solutions
+ * Copyright(C) 1999-2025 National Technology & Engineering Solutions
  * of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
  * NTESS, the U.S. Government retains certain rights in this software.
  *
@@ -15,6 +15,7 @@ namespace Ioss {
   struct IOSS_EXPORT MeshCopyOptions
   {
     std::vector<double>      selected_times{};
+    std::vector<int>         selected_steps{};
     std::vector<std::string> omitted_sets{};
     std::string              selected_change_sets{};
     double                   minimum_time{0.0};
@@ -36,6 +37,8 @@ namespace Ioss {
     bool output_summary{false};
     bool ints_64_bit{false};
     bool delete_timesteps{false};
+    bool sort_times{false};
+    bool shuffle_times{false};
     bool reverse{false};          // Used for testing CGNS
     bool add_proc_id{false};      // CGNS: Add proc_id field.
     bool boundary_sideset{false}; // Output a sideset of the boundary faces of the model
diff --git a/ThirdParty/ioss/vtkioss/Ioss_MeshType.h b/ThirdParty/ioss/vtkioss/Ioss_MeshType.h
index fc1038c4e86cba47fd52b26ff4411ff1fa3659da..de943c03939df8103ae8866c9f8ad625c255f68e 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_MeshType.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_MeshType.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2020, 2022 National Technology & Engineering Solutions
+// Copyright(C) 1999-2020, 2022, 2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -9,7 +9,7 @@
 #include "vtk_ioss_mangle.h"
 
 namespace Ioss {
-  /** \brief The mesh type -- structured, unstructured, hybrid (future), or unknown
+  /** \brief The mesh type -- structured, unstructured, or unknown
    */
-  enum class MeshType { UNKNOWN, STRUCTURED, UNSTRUCTURED, HYBRID };
+  enum class MeshType { UNKNOWN, STRUCTURED, UNSTRUCTURED };
 } // namespace Ioss
diff --git a/ThirdParty/ioss/vtkioss/Ioss_NamedSuffixVariableType.h b/ThirdParty/ioss/vtkioss/Ioss_NamedSuffixVariableType.h
index 34ca043518a0d1eded269f97c5ab51fadca36be3..ff858f0e3938831bf7cc6b3bffff127803999a8b 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_NamedSuffixVariableType.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_NamedSuffixVariableType.h
@@ -1,5 +1,5 @@
 /*
- * Copyright(C) 1999-2020, 2022, 2024 National Technology & Engineering Solutions
+ * Copyright(C) 1999-2020, 2022, 2024, 2025 National Technology & Engineering Solutions
  * of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
  * NTESS, the U.S. Government retains certain rights in this software.
  *
@@ -16,7 +16,7 @@
 #include "Ioss_VariableType.h"
 
 namespace Ioss {
-  class IOSS_EXPORT NamedSuffixVariableType : public VariableType
+  class IOSS_EXPORT NamedSuffixVariableType final : public VariableType
   {
   public:
     //  'which' is 1-based
diff --git a/ThirdParty/ioss/vtkioss/Ioss_NodeBlock.h b/ThirdParty/ioss/vtkioss/Ioss_NodeBlock.h
index e49724794c68ce8535a1ac46436dcc7844a8a8ef..b6d6bc553817c0898a45ceb85dbae1f3c816a923 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_NodeBlock.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_NodeBlock.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -30,7 +30,7 @@ namespace Ioss {
 
   /** \brief A collection of all nodes in the region.
    */
-  class IOSS_EXPORT NodeBlock : public EntityBlock
+  class IOSS_EXPORT NodeBlock final : public EntityBlock
   {
   public:
     NodeBlock(DatabaseIO *io_database, const std::string &my_name, int64_t node_count,
diff --git a/ThirdParty/ioss/vtkioss/Ioss_NodeSet.h b/ThirdParty/ioss/vtkioss/Ioss_NodeSet.h
index 141464c3efc49ece05a6ceff921921ef14d1de9b..9430143aea43065281098a33a8dbe7fefa0d7abf 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_NodeSet.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_NodeSet.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2020, 2022, 2023, 2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2020, 2022, 2023, 2024, 2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -26,7 +26,7 @@ namespace Ioss {
 
   /** \brief A collection of nodes.
    */
-  class IOSS_EXPORT NodeSet : public EntitySet
+  class IOSS_EXPORT NodeSet final : public EntitySet
   {
   public:
     NodeSet(); // Used for template typing only
diff --git a/ThirdParty/ioss/vtkioss/Ioss_ParallelUtils.C b/ThirdParty/ioss/vtkioss/Ioss_ParallelUtils.C
index 8240ae1600491ea13ea34faddacdda55d59c1def..babee0354e756595a4d8791d27856dd681880fe9 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_ParallelUtils.C
+++ b/ThirdParty/ioss/vtkioss/Ioss_ParallelUtils.C
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -96,7 +96,6 @@ void Ioss::ParallelUtils::add_environment_properties(Ioss::PropertyManager &prop
 bool Ioss::ParallelUtils::get_environment(const std::string &name, std::string &value,
                                           IOSS_MAYBE_UNUSED bool sync_parallel) const
 {
-  IOSS_PAR_UNUSED(sync_parallel);
 #ifdef SEACAS_HAVE_MPI
   char *result_string = nullptr;
 
@@ -163,7 +162,6 @@ bool Ioss::ParallelUtils::get_environment(const std::string     &name,
 {
   // Return true if 'name' defined, no matter what the value.
   // Return false if 'name' not defined.
-  IOSS_PAR_UNUSED(sync_parallel);
 #ifdef SEACAS_HAVE_MPI
   char *result_string = nullptr;
   int   string_length = 0;
@@ -260,7 +258,6 @@ void Ioss::ParallelUtils::hwm_memory_stats(int64_t &min, int64_t &max, int64_t &
 // Used by some applications for uniquely identifying an entity.
 int64_t Ioss::ParallelUtils::generate_guid(size_t id, IOSS_MAYBE_UNUSED int rank) const
 {
-  IOSS_PAR_UNUSED(rank);
 #ifdef SEACAS_HAVE_MPI
   static size_t lpow2 = 0;
   if (lpow2 == 0) {
@@ -278,8 +275,6 @@ int64_t Ioss::ParallelUtils::generate_guid(size_t id, IOSS_MAYBE_UNUSED int rank
 void Ioss::ParallelUtils::attribute_reduction(IOSS_MAYBE_UNUSED const int length,
                                               IOSS_MAYBE_UNUSED char      buffer[]) const
 {
-  IOSS_PAR_UNUSED(length);
-  IOSS_PAR_UNUSED(buffer);
 #ifdef SEACAS_HAVE_MPI
   if (1 < parallel_size()) {
     static_assert(sizeof(char) == 1, "");
@@ -376,7 +371,6 @@ template <typename T>
 T Ioss::ParallelUtils::global_minmax(T                 local_minmax,
                                      IOSS_MAYBE_UNUSED Ioss::ParallelUtils::MinMax which) const
 {
-  IOSS_PAR_UNUSED(which);
   T minmax = local_minmax;
 
 #ifdef SEACAS_HAVE_MPI
@@ -413,8 +407,6 @@ namespace Ioss {
   void ParallelUtils::broadcast(IOSS_MAYBE_UNUSED std::string &my_str,
                                 IOSS_MAYBE_UNUSED int          root) const
   {
-    IOSS_PAR_UNUSED(my_str);
-    IOSS_PAR_UNUSED(root);
 #ifdef SEACAS_HAVE_MPI
     if (parallel_size() > 1) {
       const int success = MPI_Bcast(const_cast<char *>(my_str.data()), (int)my_str.size() + 1,
@@ -430,8 +422,6 @@ namespace Ioss {
 template <typename T>
 void Ioss::ParallelUtils::broadcast(IOSS_MAYBE_UNUSED T &my_value, IOSS_MAYBE_UNUSED int root) const
 {
-  IOSS_PAR_UNUSED(my_value);
-  IOSS_PAR_UNUSED(root);
 #ifdef SEACAS_HAVE_MPI
   if (parallel_size() > 1) {
     const int success = MPI_Bcast((void *)&my_value, 1, mpi_type(T()), root, communicator_);
@@ -459,8 +449,6 @@ namespace Ioss {
   ParallelUtils::broadcast(IOSS_MAYBE_UNUSED std::vector<std::pair<int, int>> &my_value,
                            IOSS_MAYBE_UNUSED int                               root) const
   {
-    IOSS_PAR_UNUSED(my_value);
-    IOSS_PAR_UNUSED(root);
 #ifdef SEACAS_HAVE_MPI
     if (parallel_size() > 1) {
       const int success = MPI_Bcast(Data(my_value), (int)my_value.size() * 2, mpi_type(int(0)),
@@ -477,8 +465,6 @@ template <typename T>
 void Ioss::ParallelUtils::broadcast(IOSS_MAYBE_UNUSED std::vector<T> &my_value,
                                     IOSS_MAYBE_UNUSED int             root) const
 {
-  IOSS_PAR_UNUSED(my_value);
-  IOSS_PAR_UNUSED(root);
 #ifdef SEACAS_HAVE_MPI
   if (parallel_size() > 1) {
     const int success =
@@ -624,7 +610,6 @@ template <typename T>
 int Ioss::ParallelUtils::gather(int num_vals, IOSS_MAYBE_UNUSED int size_per_val,
                                 std::vector<T> &my_values, std::vector<T> &result) const
 {
-  IOSS_PAR_UNUSED(size_per_val);
 #ifdef SEACAS_HAVE_MPI
   std::vector<int> vals_per_proc;
   gather(num_vals, vals_per_proc);
diff --git a/ThirdParty/ioss/vtkioss/Ioss_ParallelUtils.h b/ThirdParty/ioss/vtkioss/Ioss_ParallelUtils.h
index acd77c0fa8deb8a3f5d0f5d7d4ae144013228115..9a1192166a7f2ef67c24764be94beeea4c29bd24 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_ParallelUtils.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_ParallelUtils.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -315,8 +315,6 @@ namespace Ioss {
   void ParallelUtils::global_array_minmax(IOSS_MAYBE_UNUSED std::vector<T> &local_minmax,
                                           IOSS_MAYBE_UNUSED MinMax          which) const
   {
-    IOSS_PAR_UNUSED(local_minmax);
-    IOSS_PAR_UNUSED(which);
 #ifdef SEACAS_HAVE_MPI
     if (parallel_size() > 1 && !local_minmax.empty()) {
       if (Ioss::SerializeIO::isEnabled() && Ioss::SerializeIO::inBarrier()) {
diff --git a/ThirdParty/ioss/vtkioss/Ioss_QuadratureVariableType.h b/ThirdParty/ioss/vtkioss/Ioss_QuadratureVariableType.h
index d4214b72d8142fb93ab2a074e3896aa9f421977e..f9dcd8869233341615fbe32dc6739bebfb2e3853 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_QuadratureVariableType.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_QuadratureVariableType.h
@@ -1,5 +1,5 @@
 /*
- * Copyright(C) 2024 National Technology & Engineering Solutions
+ * Copyright(C) 2024, 2025 National Technology & Engineering Solutions
  * of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
  * NTESS, the U.S. Government retains certain rights in this software.
  *
@@ -24,7 +24,7 @@ namespace Ioss {
     double weight;
   };
 
-  class IOSS_EXPORT QuadratureVariableType : public VariableType
+  class IOSS_EXPORT QuadratureVariableType final : public VariableType
   {
   public:
     //  'which' is 1-based
diff --git a/ThirdParty/ioss/vtkioss/Ioss_Region.C b/ThirdParty/ioss/vtkioss/Ioss_Region.C
index d354de87407471b3f7b656d74c9055477fa631d0..f329cd8e827f345f1ac946194a2e2ccfe6c1223a 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_Region.C
+++ b/ThirdParty/ioss/vtkioss/Ioss_Region.C
@@ -30,6 +30,7 @@
 #include "Ioss_Property.h"
 #include "Ioss_PropertyManager.h"
 #include "Ioss_Region.h"
+#include "Ioss_SerializeIO.h"
 #include "Ioss_SideBlock.h"
 #include "Ioss_SideSet.h"
 #include "Ioss_SmartAssert.h"
@@ -488,7 +489,7 @@ namespace Ioss {
       return MeshType::UNSTRUCTURED;
     }
     if (!elementBlocks.empty() && !structuredBlocks.empty()) {
-      return MeshType::HYBRID;
+      return MeshType::UNKNOWN;
     }
     if (!structuredBlocks.empty()) {
       return MeshType::STRUCTURED;
@@ -501,7 +502,6 @@ namespace Ioss {
   {
     switch (mesh_type()) {
     case MeshType::UNKNOWN: return "Unknown";
-    case MeshType::HYBRID: return "Hybrid";
     case MeshType::STRUCTURED: return "Structured";
     case MeshType::UNSTRUCTURED: return "Unstructured";
     }
@@ -595,8 +595,16 @@ namespace Ioss {
     int  num_width = Ioss::Utils::number_width(max_entity, true) + 2;
     int  sb_width  = Ioss::Utils::number_width(max_sb, true) + 2;
 
-    int  change_set_count = get_database()->num_internal_change_set();
-    auto change_set_name  = get_internal_change_set_name();
+    int         change_set_count = -1;
+    std::string change_set_name  = "unknown";
+
+    // If in file-per-rank parallel and serialize io is enabled, then usually only want summary on
+    // single rank. If called that way, then the following calls will fail since they expect all
+    // ranks to call...
+    if (!Ioss::SerializeIO::isEnabled()) {
+      change_set_count = get_database()->num_internal_change_set();
+      change_set_name  = get_internal_change_set_name();
+    }
     if (!change_set_name.empty() && change_set_name != "/") {
       change_set_name = ",\t[CS: " + change_set_name + "]";
     }
@@ -623,7 +631,7 @@ namespace Ioss {
         " Element side sets  = {16:{24}}\t Element sides = {22:{23}}\t Sideset    = {31:{25}}\n"
         " Assemblies         = {40:{24}}\t                 {38:{23}s}\t Assembly   = {41:{25}}\t{54:{25}}\n"
         " Blobs              = {42:{24}}\t                 {38:{23}s}\t Blob       = {43:{25}}\t{55:{25}}\n\n"
-        " Time steps         = {32:{24}}\n",
+        " Time steps         = {32:{24}}",
         get_database()->get_filename(), mesh_type_string(),                /* 0, 1 */
         fmt::group_digits(get_property("spatial_dimension").get_int()),
 	fmt::group_digits(get_property("node_count").get_int()),
@@ -680,6 +688,14 @@ namespace Ioss {
 	fmt::group_digits(num_asm_red_vars),
         fmt::group_digits(num_blob_red_vars),
 	change_set_name, change_set_count);
+
+    if (num_ts > 0) {
+      auto mm = std::minmax_element(stateTimes.begin(), stateTimes.end());
+      fmt::print("\t({} to {})\n", *mm.first, *mm.second);
+    }
+    else {
+      fmt::print("\n");
+    }
     // clang-format on
   }
 
@@ -1736,6 +1752,12 @@ namespace Ioss {
         aliases_[type].insert(std::make_pair(uname, canon));
       }
 
+      std::string fname = alias;
+      Ioss::Utils::fixup_name(fname);
+      if (fname != alias && fname != canon) {
+        aliases_[type].insert(std::make_pair(fname, canon));
+      }
+
       bool result;
       std::tie(std::ignore, result) = aliases_[type].insert(std::make_pair(alias, canon));
       return result;
diff --git a/ThirdParty/ioss/vtkioss/Ioss_Region.h b/ThirdParty/ioss/vtkioss/Ioss_Region.h
index 92494ab9a856777c8b4af43dbdbab79cdcd7580a..b1b0dad9719db14f6220f8c8fc56dc65711aceaf 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_Region.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_Region.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -90,7 +90,7 @@ namespace Ioss {
    * GroupingEntities is through the Region class; clients of the IO subsystem have no direct
    * access to the underlying GroupingEntities (other than the Region).
    */
-  class IOSS_EXPORT Region : public GroupingEntity
+  class IOSS_EXPORT Region final : public GroupingEntity
   {
   public:
     explicit Region(DatabaseIO *iodatabase = nullptr, const std::string &my_name = "");
diff --git a/ThirdParty/ioss/vtkioss/Ioss_SideBlock.h b/ThirdParty/ioss/vtkioss/Ioss_SideBlock.h
index 6db6205adf6b09c1f705ee67b6d72e5bbc6e5ef2..0b0c20b87f785c474ede40a6b75861877fabafbf 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_SideBlock.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_SideBlock.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -34,7 +34,7 @@ namespace Ioss {
 
   /** \brief A collection of element sides having the same topology.
    */
-  class IOSS_EXPORT SideBlock : public EntityBlock
+  class IOSS_EXPORT SideBlock final : public EntityBlock
   {
   public:
     friend class SideSet;
diff --git a/ThirdParty/ioss/vtkioss/Ioss_SideSet.h b/ThirdParty/ioss/vtkioss/Ioss_SideSet.h
index 18ab6375e6b9bce48321e0753209b30e50fc6c6c..8c5dc57d9ac409ebcc904c1203625f6c9dac8723 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_SideSet.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_SideSet.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2020, 2022, 2023, 2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2020, 2022, 2023, 2024, 2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -26,7 +26,7 @@ namespace Ioss {
 
   /** \brief A collection of element sides.
    */
-  class IOSS_EXPORT SideSet : public GroupingEntity
+  class IOSS_EXPORT SideSet final : public GroupingEntity
   {
   public:
     SideSet(DatabaseIO *io_database, const std::string &my_name);
diff --git a/ThirdParty/ioss/vtkioss/Ioss_StructuredBlock.C b/ThirdParty/ioss/vtkioss/Ioss_StructuredBlock.C
index 5137abc4b71b762f3f0b22e62955cc55c3ff8620..d0404e3d58892fde8464947993f15509b919c064 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_StructuredBlock.C
+++ b/ThirdParty/ioss/vtkioss/Ioss_StructuredBlock.C
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -455,7 +455,7 @@ namespace Ioss {
       if (quiet) {
         return false;
       }
-      fmt::print(Ioss::OUTPUT(), "StructuredBlock: N mismatch ({} vs. {})\n",
+      fmt::print(Ioss::OUTPUT(), "StructuredBlock {}: IJK mismatch ({} vs. {})\n", this->name(),
                  fmt::join(this->m_ijk, ":"), fmt::join(rhs.m_ijk, ":"));
       same = false;
     }
@@ -464,7 +464,7 @@ namespace Ioss {
       if (quiet) {
         return false;
       }
-      fmt::print(Ioss::OUTPUT(), "StructuredBlock: OFFSET mismatch ({} vs. {})\n",
+      fmt::print(Ioss::OUTPUT(), "StructuredBlock {}: OFFSET mismatch ({} vs. {})\n", this->name(),
                  fmt::join(this->m_offset, ":"), fmt::join(rhs.m_offset, ":"));
       same = false;
     }
@@ -473,8 +473,8 @@ namespace Ioss {
       if (quiet) {
         return false;
       }
-      fmt::print(Ioss::OUTPUT(), "StructuredBlock: Global N mismatch ({} vs. {})\n",
-                 fmt::join(this->m_ijkGlobal, ":"), fmt::join(rhs.m_ijkGlobal, ":"));
+      fmt::print(Ioss::OUTPUT(), "StructuredBlock {}: Global N mismatch ({} vs. {})\n",
+                 this->name(), fmt::join(this->m_ijkGlobal, ":"), fmt::join(rhs.m_ijkGlobal, ":"));
       same = false;
     }
 
@@ -482,8 +482,8 @@ namespace Ioss {
       if (quiet) {
         return false;
       }
-      fmt::print(Ioss::OUTPUT(), "StructuredBlock: Node Offset mismatch ({} vs. {})\n",
-                 this->m_nodeOffset, rhs.m_nodeOffset);
+      fmt::print(Ioss::OUTPUT(), "StructuredBlock {}: Node Offset mismatch ({} vs. {})\n",
+                 this->name(), this->m_nodeOffset, rhs.m_nodeOffset);
       same = false;
     }
 
@@ -491,8 +491,8 @@ namespace Ioss {
       if (quiet) {
         return false;
       }
-      fmt::print(Ioss::OUTPUT(), "StructuredBlock: Cell Offset mismatch ({} vs. {})\n",
-                 this->m_cellOffset, rhs.m_cellOffset);
+      fmt::print(Ioss::OUTPUT(), "StructuredBlock {}: Cell Offset mismatch ({} vs. {})\n",
+                 this->name(), this->m_cellOffset, rhs.m_cellOffset);
       same = false;
     }
 
@@ -500,8 +500,8 @@ namespace Ioss {
       if (!quiet) {
         return false;
       }
-      fmt::print(Ioss::OUTPUT(), "StructuredBlock: Node Global Offset mismatch ({} vs. {})\n",
-                 this->m_nodeGlobalOffset, rhs.m_nodeGlobalOffset);
+      fmt::print(Ioss::OUTPUT(), "StructuredBlock {}: Node Global Offset mismatch ({} vs. {})\n",
+                 this->name(), this->m_nodeGlobalOffset, rhs.m_nodeGlobalOffset);
       same = false;
     }
 
@@ -509,8 +509,8 @@ namespace Ioss {
       if (quiet) {
         return false;
       }
-      fmt::print(Ioss::OUTPUT(), "StructuredBlock: Cell Global Offset mismatch ({} vs. {})\n",
-                 this->m_cellGlobalOffset, rhs.m_cellGlobalOffset);
+      fmt::print(Ioss::OUTPUT(), "StructuredBlock {}: Cell Global Offset mismatch ({} vs. {})\n",
+                 this->name(), this->m_cellGlobalOffset, rhs.m_cellGlobalOffset);
       same = false;
     }
 
@@ -518,9 +518,16 @@ namespace Ioss {
       if (quiet) {
         return false;
       }
-      fmt::print(Ioss::OUTPUT(),
-                 "StructuredBlock: Block Local Node Index mismatch ({} entries vs. {} entries)\n",
-                 this->m_blockLocalNodeIndex.size(), rhs.m_blockLocalNodeIndex.size());
+      if (this->m_blockLocalNodeIndex.size() != rhs.m_blockLocalNodeIndex.size()) {
+        fmt::print(
+            Ioss::OUTPUT(),
+            "StructuredBlock {}: Block Local Node Index mismatch ({} entries vs. {} entries)\n",
+            this->name(), this->m_blockLocalNodeIndex.size(), rhs.m_blockLocalNodeIndex.size());
+      }
+      else {
+        fmt::print(Ioss::OUTPUT(),
+                   "StructuredBlock {}: Block Local Node Index contents mismatch.\n", this->name());
+      }
       same = false;
     }
 
@@ -530,7 +537,7 @@ namespace Ioss {
       if (quiet) {
         return false;
       }
-      fmt::print(Ioss::OUTPUT(), "StructuredBlock: Global ID Map mismatch\n");
+      fmt::print(Ioss::OUTPUT(), "StructuredBlock {}: Global ID Map mismatch\n", this->name());
 
       same = false;
     }
@@ -550,7 +557,8 @@ namespace Ioss {
                    return l.m_connectionName < r.m_connectionName;
                  });
       if (!vec_equal(lhzc, rhzc)) {
-        fmt::print(Ioss::OUTPUT(), "StructuredBlock: Zone Connectivity mismatch (size {} vs {})\n",
+        fmt::print(Ioss::OUTPUT(),
+                   "StructuredBlock {}: Zone Connectivity mismatch (size {} vs {})\n", this->name(),
                    this->m_zoneConnectivity.size(), rhs.m_zoneConnectivity.size());
         same = false;
       }
@@ -572,14 +580,15 @@ namespace Ioss {
                    return l.m_bcName < r.m_bcName;
                  });
       if (!vec_equal(lhbc, rhbc)) {
-        fmt::print(Ioss::OUTPUT(), "StructuredBlock: Boundary Conditions mismatch\n");
+        fmt::print(Ioss::OUTPUT(), "StructuredBlock {}: Boundary Conditions mismatch\n",
+                   this->name());
         same = false;
       }
     }
 
     if (!quiet) {
       if (!Ioss::EntityBlock::equal(rhs)) {
-        fmt::print(Ioss::OUTPUT(), "StructuredBlock: EntityBlock mismatch\n");
+        fmt::print(Ioss::OUTPUT(), "StructuredBlock {}: EntityBlock mismatch\n", this->name());
         same = false;
       }
     }
diff --git a/ThirdParty/ioss/vtkioss/Ioss_StructuredBlock.h b/ThirdParty/ioss/vtkioss/Ioss_StructuredBlock.h
index bf92115daa64fd0e473cfd4458009f65cfcd43c6..98fa4090abb4ad083c8d3aea4881e1a268baafc1 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_StructuredBlock.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_StructuredBlock.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -88,7 +88,7 @@ namespace Ioss {
 
   /** \brief A structured zone -- i,j,k
    */
-  class IOSS_EXPORT StructuredBlock : public EntityBlock
+  class IOSS_EXPORT StructuredBlock final : public EntityBlock
   {
   public:
     StructuredBlock(DatabaseIO *io_database, const std::string &my_name, int index_dim, int ni,
diff --git a/ThirdParty/ioss/vtkioss/Ioss_Utils.C b/ThirdParty/ioss/vtkioss/Ioss_Utils.C
index ffc330a531c9dac63a78d68d458b5e2c541a6279..cf99e21ea67df123142c67b08e14bed4322fc70a 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_Utils.C
+++ b/ThirdParty/ioss/vtkioss/Ioss_Utils.C
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -162,13 +162,13 @@ std::ostream &Ioss::Utils::get_debug_stream() { return *m_debugStream; }
 void Ioss::Utils::time_and_date(char *time_string, char *date_string, size_t length)
 {
   std::time_t t    = std::time(nullptr);
-  std::string time = fmt::format("{:%H:%M:%S}", fmt::localtime(t));
+  std::string time = fmt::format("{:%H:%M:%S}", *std::localtime(&t));
   std::string date;
   if (length >= 10) {
-    date = fmt::format("{:%Y/%m/%d}", fmt::localtime(t));
+    date = fmt::format("{:%Y/%m/%d}", *std::localtime(&t));
   }
   else {
-    date = fmt::format("{:%y/%m/%d}", fmt::localtime(t));
+    date = fmt::format("{:%y/%m/%d}", *std::localtime(&t));
   }
   copy_string(time_string, time, 9);
   copy_string(date_string, date, length + 1);
diff --git a/ThirdParty/ioss/vtkioss/Ioss_Utils.h b/ThirdParty/ioss/vtkioss/Ioss_Utils.h
index 44786c94abc90e7264ea81f685caf1c9a33e5a9e..b3804d5b7cba0f3eaa664457429d7b1d5bc84221 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_Utils.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_Utils.h
@@ -36,18 +36,26 @@ namespace Ioss {
   enum class ElementShape : unsigned int;
 } // namespace Ioss
 
-[[noreturn]] inline void IOSS_ERROR(const std::ostringstream &errmsg)
-{
-  throw std::runtime_error((errmsg).str());
-}
-
 [[noreturn]] inline void IOSS_ERROR(const std::string &errmsg) { throw std::runtime_error(errmsg); }
 
-#ifdef NDEBUG
-#define IOSS_ASSERT_USED(x) (void)x
-#else
-#define IOSS_ASSERT_USED(x)
+[[noreturn]] inline void IOSS_ERROR(const std::ostringstream &errmsg) { IOSS_ERROR(errmsg.str()); }
+
+[[noreturn]] inline void IOSS_ABORT(const std::string &errmsg)
+{
+  std::cerr << "ERROR: " << errmsg << "\n";
+#if defined(SEACAS_HAVE_MPI)
+  int parallelSize = 1;
+  MPI_Comm_size(MPI_COMM_WORLD, &parallelSize); // CHECK: ALLOW MPI_COMM_WORLD
+  if (parallelSize > 1) {
+    MPI_Abort(MPI_COMM_WORLD, 1); // CHECK: ALLOW MPI_COMM_WORLD
+    // MPI_Abort should not return, but if it does, we throw the exception...
+    // This helps quiet the compiler also.
+  }
 #endif
+  exit(EXIT_FAILURE);
+}
+
+[[noreturn]] inline void IOSS_ABORT(const std::ostringstream &errmsg) { IOSS_ABORT(errmsg.str()); }
 
 // We have been relying on the assumption that calling `.data()` on an empty vector
 // will return `nullptr`.  However, according to cppreference (based on the standard):
@@ -509,11 +517,11 @@ namespace Ioss {
      *  \param[in] sb Compute the offset for element sides in this SideBlock
      *  \returns The offset.
      */
+    IOSS_NODISCARD static int64_t get_side_offset(const Ioss::SideBlock *sb);
+
     IOSS_NODISCARD static int64_t get_side_offset(const Ioss::ElementTopology *parent_topo,
                                                   const Ioss::ElementTopology *side_topo);
 
-    IOSS_NODISCARD static int64_t get_side_offset(const Ioss::SideBlock *sb);
-
     IOSS_NODISCARD static unsigned int hash(const std::string &name);
 
     IOSS_NODISCARD static double timer();
diff --git a/ThirdParty/ioss/vtkioss/Ioss_VariableType.C b/ThirdParty/ioss/vtkioss/Ioss_VariableType.C
index 01091df2866cce48b369c6b87bd4c4e50778b307..ab1dad004f8239c5119552429237532e11f8284f 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_VariableType.C
+++ b/ThirdParty/ioss/vtkioss/Ioss_VariableType.C
@@ -159,15 +159,10 @@ namespace Ioss {
   bool VariableType::add_field_type_mapping(const std::string &raw_field,
                                             const std::string &raw_type)
   {
-    // See if storage type 'type' exists...
+    // Add storage type 'type' if it does not already exist...
     std::string field = Utils::lowercase(raw_field);
     std::string type  = Utils::lowercase(raw_type);
-    if (registry().find(type) == registry().end()) {
-      return false;
-    }
-
-    // Add mapping.
-    return registry().customFieldTypes.insert(std::make_pair(field, type)).second;
+    return registry().customFieldTypes.try_emplace(field, type).second;
   }
 
   bool VariableType::create_named_suffix_type(const std::string    &type_name,
diff --git a/ThirdParty/ioss/vtkioss/Ioss_Version.h b/ThirdParty/ioss/vtkioss/Ioss_Version.h
index 195eeb3b5bb88b64e43f3d68a3e87ce535616cd7..1f5547a4d7076789dd4414c59a96207ce69ff917 100644
--- a/ThirdParty/ioss/vtkioss/Ioss_Version.h
+++ b/ThirdParty/ioss/vtkioss/Ioss_Version.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2022, 2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2022, 2024, 2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -9,5 +9,5 @@
 #include "vtk_ioss_mangle.h"
 
 namespace Ioss {
-  inline const char *Version() { return "2024-10-09"; }
+  inline const char *Version() { return "2025-08-28"; }
 } // namespace Ioss
diff --git a/ThirdParty/ioss/vtkioss/catalyst/Iocatalyst_CatalystLogging.C b/ThirdParty/ioss/vtkioss/catalyst/Iocatalyst_CatalystLogging.C
index f2dd02216f7a36c3156d166e2508d6882e84d11d..a15bb8a16e13ce2978d06b07dacd4c20c9a143bb 100644
--- a/ThirdParty/ioss/vtkioss/catalyst/Iocatalyst_CatalystLogging.C
+++ b/ThirdParty/ioss/vtkioss/catalyst/Iocatalyst_CatalystLogging.C
@@ -6,6 +6,9 @@
 
 #include <Ioss_Utils.h>
 #include <catalyst/Iocatalyst_CatalystLogging.h>
+#include "vtk_fmt.h"
+#include VTK_FMT(fmt/format.h)
+#include VTK_FMT(fmt/ostream.h)
 #include <fstream>
 #include <iostream>
 #include <time.h>
@@ -46,9 +49,7 @@ namespace Iocatalyst {
       std::fstream logFile;
       logFile.open(getLogFilePath(), std::ios::out | std::ios::app);
       if (!logFile) {
-        std::ostringstream errmsg;
-        errmsg << "Unable to open Catalyst log file: " << getLogFilePath() << "\n";
-        IOSS_ERROR(errmsg);
+        fmt::print(Ioss::OUTPUT(), "\tUnable to open Catalyst log file: {}\n", getLogFilePath());
       }
       else {
         std::vector<std::string> headers = getLogFileHeaders();
diff --git a/ThirdParty/ioss/vtkioss/catalyst/Iocatalyst_CatalystManager.C b/ThirdParty/ioss/vtkioss/catalyst/Iocatalyst_CatalystManager.C
index 991c8b28faf1a2fd8c425ce38facecaf5d635a74..8b6eaf6b34cb2f0d0a208f405c78116620aeff57 100644
--- a/ThirdParty/ioss/vtkioss/catalyst/Iocatalyst_CatalystManager.C
+++ b/ThirdParty/ioss/vtkioss/catalyst/Iocatalyst_CatalystManager.C
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2021, 2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2021, 2024, 2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -78,7 +78,7 @@ namespace Iocatalyst {
     if (props.exists(CATALYST_SCRIPT)) {
       catalystProps.catalystPythonFilename = props.get(CATALYST_SCRIPT).get_string();
     }
-    else {
+    else if (!catalystProps.catalystBlockJSON.empty()) {
       catalystProps.catalystPythonFilename = this->getCatalystPythonDriverPath();
     }
 
@@ -117,6 +117,21 @@ namespace Iocatalyst {
     return catalystProps.catalystPipelineID;
   }
 
+  std::string CatalystManager::getCatalystPythonDriverPath()
+  {
+    std::string driverPath;
+    if (const char *ts = std::getenv(PHACTORI_DRIVER_SCRIPT_PATH.c_str())) {
+      driverPath = ts;
+    }
+    else {
+      std::ostringstream errmsg;
+      errmsg << "Error: environment variable " << PHACTORI_DRIVER_SCRIPT_PATH
+             << " not set to the full path of PhactoriDriver.py";
+      IOSS_ERROR(errmsg);
+    }
+    return driverPath;
+  }
+
   CatalystManager::CatalystProps &CatalystManager::getCatalystProps(CatalystPipelineID id)
   {
     if (catPipes.find(id) == catPipes.end()) {
@@ -295,8 +310,6 @@ namespace Iocatalyst {
   void CatalystManager::broadCastString(IOSS_MAYBE_UNUSED std::string &s,
                                         IOSS_MAYBE_UNUSED const Ioss::ParallelUtils &putils)
   {
-    IOSS_PAR_UNUSED(s);
-    IOSS_PAR_UNUSED(putils);
 #ifdef SEACAS_HAVE_MPI
     int size = s.size();
     putils.broadcast(size);
@@ -310,8 +323,6 @@ namespace Iocatalyst {
   void CatalystManager::broadCastStatusCode(IOSS_MAYBE_UNUSED bool &statusCode,
                                             IOSS_MAYBE_UNUSED const Ioss::ParallelUtils &putils)
   {
-    IOSS_PAR_UNUSED(statusCode);
-    IOSS_PAR_UNUSED(putils);
 #ifdef SEACAS_HAVE_MPI
 
     int code = statusCode;
diff --git a/ThirdParty/ioss/vtkioss/catalyst/Iocatalyst_CatalystManager.h b/ThirdParty/ioss/vtkioss/catalyst/Iocatalyst_CatalystManager.h
index b9c24c9db93e152b1156ee2fb9cd4bc87fd95ae6..77a3a47ba77583a81f712db2c44ef6870d207631 100644
--- a/ThirdParty/ioss/vtkioss/catalyst/Iocatalyst_CatalystManager.h
+++ b/ThirdParty/ioss/vtkioss/catalyst/Iocatalyst_CatalystManager.h
@@ -36,21 +36,22 @@ namespace Iocatalyst {
     inline static const std::string CATALYST_INPUT_DEFAULT    = "input";
     inline static const std::string CATALYST_MULTI_INPUT_PIPELINE_NAME =
         "CATALYST_MULTI_INPUT_PIPELINE_NAME";
-    inline static const std::string CATALYST_SCRIPT            = "CATALYST_SCRIPT";
-    inline static const std::string CATALYST_SCRIPT_EXTRA_FILE = "CATALYST_SCRIPT_EXTRA_FILE";
-    inline static const std::string CHANNELS                   = "channels";
-    inline static const std::string CYCLE                      = "cycle";
-    inline static const std::string DATA                       = "data";
-    inline static const std::string PHACTORI_JSON_SCRIPT       = "PHACTORI_JSON_SCRIPT";
-    inline static const std::string PIPELINES                  = "pipelines";
-    inline static const std::string FILENAME                   = "filename";
-    inline static const std::string FS                         = "/";
-    inline static const std::string IOSS                       = "ioss";
-    inline static const std::string SCRIPTS                    = "scripts";
-    inline static const std::string STATE                      = "state";
-    inline static const std::string TIME                       = "time";
-    inline static const std::string TIMESTEP                   = "timestep";
-    inline static const std::string TYPE                       = "type";
+    inline static const std::string CATALYST_SCRIPT             = "CATALYST_SCRIPT";
+    inline static const std::string CATALYST_SCRIPT_EXTRA_FILE  = "CATALYST_SCRIPT_EXTRA_FILE";
+    inline static const std::string CHANNELS                    = "channels";
+    inline static const std::string CYCLE                       = "cycle";
+    inline static const std::string DATA                        = "data";
+    inline static const std::string PHACTORI_JSON_SCRIPT        = "PHACTORI_JSON_SCRIPT";
+    inline static const std::string PIPELINES                   = "pipelines";
+    inline static const std::string FILENAME                    = "filename";
+    inline static const std::string FS                          = "/";
+    inline static const std::string IOSS                        = "ioss";
+    inline static const std::string SCRIPTS                     = "scripts";
+    inline static const std::string STATE                       = "state";
+    inline static const std::string TIME                        = "time";
+    inline static const std::string TIMESTEP                    = "timestep";
+    inline static const std::string TYPE                        = "type";
+    inline static const std::string PHACTORI_DRIVER_SCRIPT_PATH = "PHACTORI_DRIVER_SCRIPT_PATH";
 
     static CatalystManager &getInstance()
     {
@@ -58,7 +59,7 @@ namespace Iocatalyst {
       return instance;
     }
 
-    std::string getCatalystPythonDriverPath() { return "/todo/create/real/path"; }
+    std::string getCatalystPythonDriverPath();
 
     conduit_cpp::Node getInitializeConduit();
 
diff --git a/ThirdParty/ioss/vtkioss/catalyst/Iocatalyst_DatabaseIO.C b/ThirdParty/ioss/vtkioss/catalyst/Iocatalyst_DatabaseIO.C
index 10cf8ff1c90d2ecf3d9cb790861fdeb8197cd94c..a51c0435227663584764abf327e8f6937bb8b300 100644
--- a/ThirdParty/ioss/vtkioss/catalyst/Iocatalyst_DatabaseIO.C
+++ b/ThirdParty/ioss/vtkioss/catalyst/Iocatalyst_DatabaseIO.C
@@ -105,7 +105,6 @@ namespace Iocatalyst {
     inline static const std::string NIGLOBAL           = "ni_global";
     inline static const std::string NJGLOBAL           = "nj_global";
     inline static const std::string NKGLOBAL           = "nk_global";
-    inline static const std::string NODEBLOCKONE       = "nodeblock_1";
     inline static const std::string IDS                = "ids";
     inline static const std::string INDEX              = "index";
     inline static const std::string OFFSET_I           = "offset_i";
@@ -374,7 +373,7 @@ namespace Iocatalyst {
       const auto groupName      = getName(entityGroup);
       const auto num_to_get     = field.verify(data_size);
       const auto num_components = field.raw_storage()->component_count();
-      if (num_to_get > 0) {
+      if (num_to_get >= 0) {
         auto &&node = this->DBNode[getFieldPath(containerName, groupName, field.get_name())];
         node[detail::ROLE].set(static_cast<std::int8_t>(field.get_role()));
         node[detail::TYPE].set(static_cast<std::int8_t>(field.get_type()));
@@ -641,10 +640,15 @@ namespace Iocatalyst {
         return this->NodeMap;
       }
 
-      auto nbone_path = detail::NODEBLOCKS + detail::FS + detail::NODEBLOCKONE + detail::FS +
-                        detail::FIELDS + detail::FS + detail::IDS;
-      auto &&idsNode  = this->DBNode[nbone_path];
-      auto   node_ids = const_cast<void *>(idsNode[detail::VALUE].element_ptr(0));
+      if (this->DBNode[detail::NODEBLOCKS].number_of_children() == 0) {
+        std::ostringstream errmsg;
+        fmt::print(errmsg, "ERROR in {} no nodeblocks found, unable to create NodeMap\n", __func__);
+        IOSS_ERROR(errmsg);
+      }
+
+      auto &&idsNode = this->DBNode[detail::NODEBLOCKS][0][detail::FIELDS][detail::IDS];
+
+      auto node_ids = const_cast<void *>(idsNode[detail::VALUE].element_ptr(0));
       this->NodeMap.set_size(idsNode[detail::COUNT].as_int64());
       if (idsNode[detail::TYPE].as_int8() == Ioss::Field::BasicType::INT32) {
         this->NodeMap.set_map(reinterpret_cast<int32_t *>(node_ids),
@@ -769,11 +773,7 @@ namespace Iocatalyst {
     bool addProperties(conduit_cpp::Node parent, GroupingEntityT *entityGroup)
     {
       Ioss::NameList names;
-      // skip implicit properties.
-      entityGroup->property_describe(Ioss::Property::INTERNAL, &names);
-      entityGroup->property_describe(Ioss::Property::EXTERNAL, &names);
-      entityGroup->property_describe(Ioss::Property::ATTRIBUTE, &names);
-      entityGroup->property_describe(Ioss::Property::IMPLICIT, &names);
+      entityGroup->property_describe(&names);
 
       auto &&propertiesNode = parent[detail::PROPERTIES];
       for (const auto &name : names) {
@@ -799,9 +799,11 @@ namespace Iocatalyst {
           node[detail::VALUE].set(property.get_vec_double());
           break;
 
-        case Ioss::Property::BasicType::POINTER:
-        case Ioss::Property::BasicType::INVALID:
-        default: return false;
+        case Ioss::Property::BasicType::POINTER: break;
+
+        case Ioss::Property::BasicType::INVALID: break;
+
+        default: break;
         }
       }
       return true;
@@ -1159,12 +1161,7 @@ namespace Iocatalyst {
       auto &&child = parent[idx];
       auto block = detail::createEntityGroup<Ioss::StructuredBlock>(child, region->get_database());
       region->add(block);
-      auto parent = block->get_node_block().get_property(detail::IOSSCONTAINEDIN);
       this->readProperties(child[detail::PROPERTIES], block);
-      this->readProperties(
-          child[getName(&block->get_node_block()) + detail::FS + detail::PROPERTIES],
-          &block->get_node_block());
-      block->get_node_block().property_add(parent);
 
       // read fields (meta-data only)
       this->readFields(child[detail::FIELDS], block);
diff --git a/ThirdParty/ioss/vtkioss/cgns/Iocgns_DatabaseIO.C b/ThirdParty/ioss/vtkioss/cgns/Iocgns_DatabaseIO.C
index fe44c7db31a35810217bbd9edc5c369f69017a47..43dd59deb4984e23d642152dc5c2b70cf67c879a 100644
--- a/ThirdParty/ioss/vtkioss/cgns/Iocgns_DatabaseIO.C
+++ b/ThirdParty/ioss/vtkioss/cgns/Iocgns_DatabaseIO.C
@@ -4,7 +4,7 @@
 // * Single Base.
 // * ZoneGridConnectivity is 1to1 with point lists for unstructured
 
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -81,6 +81,79 @@
 // extern char hdf5_access[64];
 
 namespace {
+  extern "C" {
+  // From private CGNS header: `cgio_internal_type.h`
+  typedef struct _cgns_io_ctx_t
+  {
+    /* Flag indicating if HDF5 file accesses is PARALLEL or NATIVE */
+    char hdf5_access[64];
+#if CG_BUILD_PARALLEL
+    /* MPI-2 info object */
+    MPI_Comm pcg_mpi_comm;
+    int      pcg_mpi_comm_size;
+    int      pcg_mpi_comm_rank;
+    /* flag indicating if mpi_initialized was called */
+    int      pcg_mpi_initialized;
+    MPI_Info pcg_mpi_info;
+    int64_t  default_pio_mode;
+#endif
+  } cgns_io_ctx_t;
+
+  extern cgns_io_ctx_t ctx_cgio; /* located in cgns_io.c */
+  }
+
+  // There is a bug in the CGNS library (4.4.0 and before) where it
+  // has a global symbol `ctx_cgio` which controls whether
+  // file-per-rank access is being used, or parallel io (single file,
+  // multiple ranks).  In an application (like many IOSS uses) that
+  // uses both access methods in the same execution, this can result
+  // in hangs and corruprtion due to the wrong access type being used
+  // at the wrong time (collective for a file-per-rank typically).
+  //
+  // The code below is a kluge to workaround this shortcoming in the
+  // CGNS library.  Before each file-per-rank access of the underlying
+  // file, the code below access the CGNS global `ctx_cgio` and sets
+  // it to non-parallel access.  After the access, the destructor of
+  // the class sets the global back to its previous value.
+  //
+  // The CGNS developers are aware of the issue and are looking at
+  // options.  See https://github.com/CGNS/CGNS/issues/835
+  struct ParallelGuard
+  {
+    ParallelGuard(bool yes_no)
+    {
+#if CG_BUILD_PARALLEL
+      m_wasSet = strcmp(ctx_cgio.hdf5_access, "PARALLEL") == 0;
+      if (m_wasSet != yes_no) {
+        m_changed = true;
+        if (yes_no) {
+          strcpy(ctx_cgio.hdf5_access, "PARALLEL");
+        }
+        else {
+          strcpy(ctx_cgio.hdf5_access, "NATIVE");
+        }
+      }
+#endif
+    }
+    ~ParallelGuard()
+    {
+#if CG_BUILD_PARALLEL
+      if (m_changed) {
+        if (m_wasSet) {
+          strcpy(ctx_cgio.hdf5_access, "PARALLEL");
+        }
+        else {
+          strcpy(ctx_cgio.hdf5_access, "NATIVE");
+        }
+      }
+#endif
+    }
+#if CG_BUILD_PARALLEL
+    bool m_wasSet{false};
+    bool m_changed{false};
+#endif
+  };
+
   size_t global_to_zone_local_idx(size_t i, const Ioss::Map *block_map, const Ioss::Map &nodeMap,
                                   bool isParallel)
   {
@@ -645,7 +718,7 @@ namespace Iocgns {
 
 #if CG_BUILD_PARALLEL
       cgp_mpi_comm(Ioss::ParallelUtils::comm_self());
-      int ierr = cgp_open(decoded_filename().c_str(), mode, &m_cgnsFilePtr);
+      int ierr = cg_open(decoded_filename().c_str(), mode, &m_cgnsFilePtr);
       cgp_mpi_comm(util().communicator());
 #else
       int ierr = cg_open(decoded_filename().c_str(), mode, &m_cgnsFilePtr);
@@ -794,8 +867,6 @@ namespace Iocgns {
                                                size_t & /* num_node */)
   {
     SMART_ASSERT(isParallel);
-    IOSS_PAR_UNUSED(base);
-    IOSS_PAR_UNUSED(num_zones);
 #if CG_BUILD_PARALLEL
     // Each processor may have a different set of zones.  This routine
     // will sync the information such that at return, each procesosr
@@ -998,7 +1069,7 @@ namespace Iocgns {
       Ioss::IJK_t global_ijk;
       Ioss::IJK_t offset_ijk;
 
-      zone_data[id++]; // proc field. Not currently used.
+      id++; // proc field. Not currently used.
       unpack(id, Data(zone_data), local_ijk.data(), 3);
       unpack(id, Data(zone_data), global_ijk.data(), 3);
       unpack(id, Data(zone_data), offset_ijk.data(), 3);
@@ -1147,17 +1218,19 @@ namespace Iocgns {
 
       int idx = 0;
       for (const auto &sb : blocks) {
-        unsigned    assem_hash = assem_ids[idx++];
-        std::string name       = assembly_hash_map[assem_hash];
-        auto       *assembly   = get_region()->get_assembly(name);
-        assert(assembly != nullptr);
-        if (!sb->property_exists("assembly")) {
-          assembly->add(sb);
-          Ioss::StructuredBlock *new_sb = const_cast<Ioss::StructuredBlock *>(sb);
-          new_sb->property_add(Ioss::Property("assembly", assembly->name()));
+        unsigned assem_hash = assem_ids[idx++];
+        if (assem_hash > 0) {
+          std::string name     = assembly_hash_map[assem_hash];
+          auto       *assembly = get_region()->get_assembly(name);
+          assert(assembly != nullptr);
+          if (!sb->property_exists("assembly")) {
+            assembly->add(sb);
+            Ioss::StructuredBlock *new_sb = const_cast<Ioss::StructuredBlock *>(sb);
+            new_sb->property_add(Ioss::Property("assembly", assembly->name()));
+          }
+          SMART_ASSERT(sb->get_property("assembly").get_string() == assembly->name())
+          (sb->get_property("assembly").get_string())(assembly->name());
         }
-        SMART_ASSERT(sb->get_property("assembly").get_string() == assembly->name())
-        (sb->get_property("assembly").get_string())(assembly->name());
       }
     }
 #endif
@@ -1533,6 +1606,7 @@ namespace Iocgns {
           "ERROR: CGNS: Too many bases; only support files with a single bases at this time");
     }
 
+    ParallelGuard serial(0);
     get_step_times_nl();
 
     if (open_create_behavior() == Ioss::DB_APPEND) {
@@ -1574,10 +1648,6 @@ namespace Iocgns {
         else if (mesh_type == Ioss::MeshType::UNSTRUCTURED) {
           create_unstructured_block(base, zone, num_node);
         }
-#if IOSS_ENABLE_HYBRID
-        else if (mesh_type == Ioss::MeshType::HYBRID) {
-        }
-#endif
         else {
           IOSS_ERROR(fmt::format("ERROR: CGNS: Zone {} is not of type Unstructured or Structured "
                                  "which are the only types currently supported",
@@ -1586,7 +1656,7 @@ namespace Iocgns {
       }
     }
 
-    if (mesh_type == Ioss::MeshType::STRUCTURED || mesh_type == Ioss::MeshType::HYBRID) {
+    if (mesh_type == Ioss::MeshType::STRUCTURED) {
       num_node = finalize_structured_blocks();
     }
 
@@ -1862,6 +1932,7 @@ namespace Iocgns {
     };
     // End of lambda...
 
+    ParallelGuard serial(0);
     if (role == Ioss::Field::MESH) {
       if (field.get_name() == "mesh_model_coordinates_x") {
         // Use the lambda...
@@ -2000,6 +2071,7 @@ namespace Iocgns {
       return 0;
     }
 
+    ParallelGuard         serial(0);
     Ioss::Field::RoleType role = field.get_role();
     if (role == Ioss::Field::TRANSIENT) {
       // Get the StructuredBlock that this NodeBlock is contained in:
@@ -2069,7 +2141,8 @@ namespace Iocgns {
   int64_t DatabaseIO::get_field_internal(const Ioss::ElementBlock *eb, const Ioss::Field &field,
                                          void *data, size_t data_size) const
   {
-    size_t num_to_get = field.verify(data_size);
+    ParallelGuard serial(0);
+    size_t        num_to_get = field.verify(data_size);
     if (num_to_get > 0) {
 
       int                   base             = eb->get_property("base").get_int();
@@ -2209,7 +2282,8 @@ namespace Iocgns {
     int                   base = sb->get_property("base").get_int();
     int                   zone = Iocgns::Utils::get_db_zone(sb);
 
-    cgsize_t num_to_get = field.verify(data_size);
+    cgsize_t      num_to_get = field.verify(data_size);
+    ParallelGuard serial(0);
 
     // In this routine, if isParallel, then reading file-per-processor; not parallel io from single
     // file.
@@ -2398,9 +2472,10 @@ namespace Iocgns {
   int64_t DatabaseIO::get_field_internal(const Ioss::SideBlock *sb, const Ioss::Field &field,
                                          void *data, size_t data_size) const
   {
-    int base = sb->get_property("base").get_int();
-    int zone = Iocgns::Utils::get_db_zone(sb);
-    int sect = sb->get_property("section").get_int();
+    ParallelGuard serial(0);
+    int           base = sb->get_property("base").get_int();
+    int           zone = Iocgns::Utils::get_db_zone(sb);
+    int           sect = sb->get_property("section").get_int();
 
     int64_t num_to_get = field.verify(data_size);
     if (num_to_get > 0) {
@@ -2554,6 +2629,7 @@ namespace Iocgns {
 
     // In this routine, if isParallel, then writing file-per-processor; not parallel io to single
     // file.
+    ParallelGuard serial(0);
     if (isParallel && num_to_get == 0) {
       return 0;
     }
@@ -2664,7 +2740,8 @@ namespace Iocgns {
   int64_t DatabaseIO::put_field_internal(const Ioss::ElementBlock *eb, const Ioss::Field &field,
                                          void *data, size_t data_size) const
   {
-    size_t num_to_get = field.verify(data_size);
+    ParallelGuard serial(0);
+    size_t        num_to_get = field.verify(data_size);
     if (num_to_get > 0) {
 
       Ioss::Field::RoleType role = field.get_role();
@@ -2835,6 +2912,7 @@ namespace Iocgns {
       return put_field_internal_sub_nb(nb, field, data, data_size);
     }
 
+    ParallelGuard serial(0);
     // Instead of outputting a global nodeblock's worth of data,
     // the data is output a "zone" at a time.
     // The m_globalToBlockLocalNodeMap[zone] map is used (Ioss::Map pointer)
@@ -3007,6 +3085,7 @@ namespace Iocgns {
     int                         zone       = Iocgns::Utils::get_db_zone(sb);
     cgsize_t                    num_to_get = field.verify(data_size);
 
+    ParallelGuard serial(0);
     // In this routine, if isParallel, then writing file-per-processor; not parallel io to single
     // file.
     if (isParallel && num_to_get == 0) {
@@ -3070,6 +3149,7 @@ namespace Iocgns {
   int64_t DatabaseIO::put_field_internal(const Ioss::SideBlock *sb, const Ioss::Field &field,
                                          void *data, size_t data_size) const
   {
+    ParallelGuard            serial(0);
     const Ioss::EntityBlock *parent_block = sb->parent_block();
     if (parent_block == nullptr) {
       IOSS_ERROR(fmt::format(
diff --git a/ThirdParty/ioss/vtkioss/cgns/Iocgns_DatabaseIO.h b/ThirdParty/ioss/vtkioss/cgns/Iocgns_DatabaseIO.h
index 9cc8c5d36139b933c322e674382377d90ede65fa..5f11caaa75d184cd6b84fe68036151ab56c02b9b 100644
--- a/ThirdParty/ioss/vtkioss/cgns/Iocgns_DatabaseIO.h
+++ b/ThirdParty/ioss/vtkioss/cgns/Iocgns_DatabaseIO.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -55,7 +55,7 @@ namespace Ioss {
  */
 namespace Iocgns {
 
-  class IOCGNS_EXPORT DatabaseIO : public Ioss::DatabaseIO
+  class IOCGNS_EXPORT DatabaseIO final : public Ioss::DatabaseIO
   {
   public:
     enum class entity_type { NODE, ELEM };
diff --git a/ThirdParty/ioss/vtkioss/cgns/Iocgns_DecompositionData.C b/ThirdParty/ioss/vtkioss/cgns/Iocgns_DecompositionData.C
index 0fb657378c5af422ab8784a43a7cb73cb0b770ea..67f1164cfb162384454135a8a438182e555a1ec6 100644
--- a/ThirdParty/ioss/vtkioss/cgns/Iocgns_DecompositionData.C
+++ b/ThirdParty/ioss/vtkioss/cgns/Iocgns_DecompositionData.C
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -219,12 +219,6 @@ namespace Iocgns {
     else if (mesh_type == Ioss::MeshType::STRUCTURED) {
       decompose_structured(filePtr);
     }
-#if IOSS_ENABLE_HYBRID
-    else if (mesh_type == Ioss::MeshType::HYBRID) {
-      IOSS_ERROR("ERROR: CGNS: The mesh type is HYBRID which is not supported for parallel "
-                 "decomposition yet.");
-    }
-#endif
     else {
       IOSS_ERROR("ERROR: CGNS: The mesh type is not Unstructured or Structured "
                  "which are the only types currently supported");
diff --git a/ThirdParty/ioss/vtkioss/cgns/Iocgns_ParallelDatabaseIO.C b/ThirdParty/ioss/vtkioss/cgns/Iocgns_ParallelDatabaseIO.C
index 9f373db7d0c50fdaf7a15dd521022e6913654aac..e9fdb2d37ec6246b1e70e596a15d86e2c5aaedb7 100644
--- a/ThirdParty/ioss/vtkioss/cgns/Iocgns_ParallelDatabaseIO.C
+++ b/ThirdParty/ioss/vtkioss/cgns/Iocgns_ParallelDatabaseIO.C
@@ -3,7 +3,7 @@
 // * Single Base.
 // * ZoneGridConnectivity is 1to1 with point lists for unstructured
 
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -418,10 +418,6 @@ namespace Iocgns {
     else if (m_meshType == Ioss::MeshType::UNSTRUCTURED) {
       handle_unstructured_blocks();
     }
-#if IOSS_ENABLE_HYBRID
-    else if (mesh_type == Ioss::MeshType::HYBRID) {
-    }
-#endif
     else {
       std::ostringstream errmsg;
       fmt::print(errmsg, "ERROR: CGNS: Mesh is not Unstructured or Structured which are the only "
@@ -1209,11 +1205,9 @@ namespace Iocgns {
           size_t               ep_data_size = ent_proc.size() * sizeof(int64_t);
           get_field_internal(css, ep_field, Data(ent_proc), ep_data_size);
           for (size_t i = 0; i < ent_proc.size(); i += 2) {
-            int64_t node = ent_proc[i + 0];
-            int64_t proc = ent_proc[i + 1];
-            if (proc < idata[node - 1]) {
-              idata[node - 1] = proc;
-            }
+            int64_t node    = ent_proc[i + 0];
+            int64_t proc    = ent_proc[i + 1];
+            idata[node - 1] = std::min(idata[node - 1], proc);
           }
         }
         else {
@@ -1226,11 +1220,9 @@ namespace Iocgns {
           size_t           ep_data_size = ent_proc.size() * sizeof(int);
           get_field_internal(css, ep_field, Data(ent_proc), ep_data_size);
           for (size_t i = 0; i < ent_proc.size(); i += 2) {
-            int node = ent_proc[i + 0];
-            int proc = ent_proc[i + 1];
-            if (proc < idata[node - 1]) {
-              idata[node - 1] = proc;
-            }
+            int node        = ent_proc[i + 0];
+            int proc        = ent_proc[i + 1];
+            idata[node - 1] = std::min(idata[node - 1], proc);
           }
         }
       }
diff --git a/ThirdParty/ioss/vtkioss/cgns/Iocgns_ParallelDatabaseIO.h b/ThirdParty/ioss/vtkioss/cgns/Iocgns_ParallelDatabaseIO.h
index b67d1738650b5e12857c069ae417c4bc71bcfc08..3be0fc05db715688e4fcb2240b044b6e6dd435ab 100644
--- a/ThirdParty/ioss/vtkioss/cgns/Iocgns_ParallelDatabaseIO.h
+++ b/ThirdParty/ioss/vtkioss/cgns/Iocgns_ParallelDatabaseIO.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -54,7 +54,7 @@ namespace Ioss {
 
 namespace Iocgns {
 
-  class IOCGNS_EXPORT ParallelDatabaseIO : public Ioss::DatabaseIO
+  class IOCGNS_EXPORT ParallelDatabaseIO final : public Ioss::DatabaseIO
   {
   public:
     enum class entity_type { NODE, ELEM };
diff --git a/ThirdParty/ioss/vtkioss/cgns/Iocgns_Utils.C b/ThirdParty/ioss/vtkioss/cgns/Iocgns_Utils.C
index dd71b676b81d5bf6104e08275d67e16fa4a06c6b..9c322bccaf90f0c631b547c8d9749feb2961de41 100644
--- a/ThirdParty/ioss/vtkioss/cgns/Iocgns_Utils.C
+++ b/ThirdParty/ioss/vtkioss/cgns/Iocgns_Utils.C
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -536,19 +536,14 @@ Ioss::MeshType Iocgns::Utils::check_mesh_type(int cgns_file_ptr)
     }
 
     if (common_zone_type != zone_type) {
-#if IOSS_ENABLE_HYBRID
-      common_zone_type = CGNS_ENUMV(ZoneTypeUserDefined); // This is how we represent hybrid...
-      break;
-#else
-      IOSS_ERROR(fmt::format("ERROR: CGNS: Zone {} is not the same zone type as previous zones."
-                             " This is currently not allowed or supported (hybrid mesh).",
-                             zone));
-#endif
+      IOSS_ERROR(fmt::format(
+          "ERROR: CGNS: Zone {} is not the same zone type as previous zones."
+          " This is currently not allowed or supported (mixed structured/unstructured mesh).",
+          zone));
     }
   }
 
   switch (common_zone_type) {
-  case CGNS_ENUMV(ZoneTypeUserDefined): return Ioss::MeshType::HYBRID;
   case CGNS_ENUMV(Structured): return Ioss::MeshType::STRUCTURED;
   case CGNS_ENUMV(Unstructured): return Ioss::MeshType::UNSTRUCTURED;
   default: return Ioss::MeshType::UNKNOWN;
@@ -707,7 +702,6 @@ namespace {
     // 3 int[3] transform; (values range from -3 to +3 (could store as single int)
     // CGNS_MAX_NAME_LENGTH characters + 17 ints / connection.
 
-    IOSS_PAR_UNUSED(region);
 #if CG_BUILD_PARALLEL
     const int BYTE_PER_NAME = CGNS_MAX_NAME_LENGTH;
     const int INT_PER_ZGC   = 17;
@@ -1060,15 +1054,6 @@ void Iocgns::Utils::write_state_meta_data(int file_ptr, const Ioss::Region &regi
 size_t Iocgns::Utils::common_write_metadata(int file_ptr, const Ioss::Region &region,
                                             std::vector<size_t> &zone_offset, bool is_parallel_io)
 {
-#if !IOSS_ENABLE_HYBRID
-  // Make sure mesh is not hybrid...
-  if (region.mesh_type() == Ioss::MeshType::HYBRID) {
-    IOSS_ERROR(fmt::format("ERROR: CGNS: The mesh on region '{}' is of type 'hybrid'."
-                           " This is currently not allowed or supported.",
-                           region.name()));
-  }
-#endif
-
   region.get_database()->progress("\tEnter common_write_metadata");
   int base           = 0;
   int phys_dimension = region.get_property("spatial_dimension").get_int();
@@ -1076,8 +1061,8 @@ size_t Iocgns::Utils::common_write_metadata(int file_ptr, const Ioss::Region &re
 
   CGERR(cg_goto(file_ptr, base, "end"));
   std::time_t t    = std::time(nullptr);
-  std::string date = fmt::format("{:%Y/%m/%d}", fmt::localtime(t));
-  std::string time = fmt::format("{:%H:%M:%S}", fmt::localtime(t));
+  std::string date = fmt::format("{:%Y/%m/%d}", *std::localtime(&t));
+  std::string time = fmt::format("{:%H:%M:%S}", *std::localtime(&t));
 
   std::string code_version = region.get_optional_property("code_version", "unknown");
   std::string code_name    = region.get_optional_property("code_name", "unknown");
@@ -1260,7 +1245,7 @@ size_t Iocgns::Utils::common_write_metadata(int file_ptr, const Ioss::Region &re
     // TODO: Calculate it outside of the loop...
     // Need to handle possible range == 0,0,0.  Only affects the beg data...
     if (is_parallel_io) {
-      region.get_database()->progress("\t\tBoundary Conditions");
+      region.get_database()->progress(fmt::format("\t\tBoundary Conditions for zone {}.", name));
     }
     CGNSIntVector bc_range(sb->m_boundaryConditions.size() * 6);
     size_t        idx = 0;
@@ -1276,6 +1261,9 @@ size_t Iocgns::Utils::common_write_metadata(int file_ptr, const Ioss::Region &re
       for (size_t i = 0; i < 3; i++) {
         bc_range[idx++] = bc.m_rangeEnd[i];
       }
+      if (is_parallel_io) {
+        region.get_database()->progress(fmt::format("\t\tBC Range calculation, {}.", bc.m_bcName));
+      }
     }
 
     if (is_parallel_io) {
@@ -1319,7 +1307,7 @@ size_t Iocgns::Utils::common_write_metadata(int file_ptr, const Ioss::Region &re
     }
     // Transfer Zone Grid Connectivity...
     if (is_parallel_io) {
-      region.get_database()->progress("\t\tZone Grid Connectivity");
+      region.get_database()->progress(fmt::format("\t\tZone Grid Connectivity for Zone {}", name));
     }
 
     // Used to detect duplicate zgc names in parallel but non-parallel-io case
@@ -1402,6 +1390,10 @@ size_t Iocgns::Utils::common_write_metadata(int file_ptr, const Ioss::Region &re
           }
         }
 
+        if (is_parallel_io) {
+          region.get_database()->progress(
+              fmt::format("\t\tcg_1to1_write Name: {}, Donor: {}.", connect_name, donor_name));
+        }
         CGERR(cg_1to1_write(file_ptr, base, db_zone, connect_name.c_str(), donor_name.c_str(),
                             Data(owner_range), Data(donor_range), Data(zgc.m_transform), &zgc_idx));
 
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Beam2.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Beam2.h
index 34745fd54c5cef46586030acf4a1f1cdc9c10816..b68dbe81740febf54a13f7652de7f56f5a97401e 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Beam2.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Beam2.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Beam2 : public Ioss::ElementTopology
+  class IOSS_EXPORT Beam2 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Beam3.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Beam3.h
index 6c0c7e1f531f8095ed27be78c1d5ea9ee923c40b..eb9ddb757aced006666b1a025eed40a0b2c789e1 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Beam3.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Beam3.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Beam3 : public Ioss::ElementTopology
+  class IOSS_EXPORT Beam3 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Beam4.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Beam4.h
index db2c74b299ef5902a3faf964a50a59beb560731f..d34c452f7f8fc50a6f1fb31c93a5feb139a5828e 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Beam4.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Beam4.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Beam4 : public Ioss::ElementTopology
+  class IOSS_EXPORT Beam4 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Edge2.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Edge2.h
index 1f192336d58de917d27f346583a08bafb675e3da..39034a4d3c940cf4b32c6f62efaf8152b953745f 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Edge2.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Edge2.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Edge2 : public Ioss::ElementTopology
+  class IOSS_EXPORT Edge2 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Edge2D2.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Edge2D2.h
index c172ae05a4892afa255419e6a6db850cd4b4e5a9..a61eba586cc96971cb84cb1387de808f990627f1 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Edge2D2.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Edge2D2.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Edge2D2 : public Ioss::ElementTopology
+  class IOSS_EXPORT Edge2D2 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Edge2D3.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Edge2D3.h
index af40e140b3fbb2af226fa7a8e42b4b2191c6b479..1f46263a4a4896cd6bac19687571ac02da886e47 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Edge2D3.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Edge2D3.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Edge2D3 : public Ioss::ElementTopology
+  class IOSS_EXPORT Edge2D3 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Edge3.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Edge3.h
index 030033059ec8e17c5b8d265bd2ec44489d5806db..e195e21002d0aae246e752a606c5bd37989c47f8 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Edge3.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Edge3.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Edge3 : public Ioss::ElementTopology
+  class IOSS_EXPORT Edge3 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Edge4.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Edge4.h
index c369669b746b4d763af3c9c141ad0860cc8fa99e..344791f54eac52d0cb1ea8e202fe8900985bfa1d 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Edge4.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Edge4.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Edge4 : public Ioss::ElementTopology
+  class IOSS_EXPORT Edge4 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Hex16.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Hex16.h
index c7f31c1d8eb75a4a147d7f7500380ba6d9a35dab..da0e879383ff1cf12bf2d8a12f77f38ad8eb2d1c 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Hex16.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Hex16.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Hex16 : public Ioss::ElementTopology
+  class IOSS_EXPORT Hex16 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Hex20.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Hex20.h
index e4f9866d1990dc04fccacf44a00490d94a2439cc..aac12e0f778da7270c6ed9fcfc4babaaa671c6fe 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Hex20.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Hex20.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Hex20 : public Ioss::ElementTopology
+  class IOSS_EXPORT Hex20 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Hex27.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Hex27.h
index 85e1868dcd053be166dcaa63042935c3b1ddfa81..dfceeeadc3406fd6c5a86f444fe70823299c8c04 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Hex27.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Hex27.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Hex27 : public Ioss::ElementTopology
+  class IOSS_EXPORT Hex27 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Hex32.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Hex32.h
index 2ca04759bd2b60c5592c6dd3ca1ecad23b125e24..a41fe6475ffd222189999efb611054e2317eb7cf 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Hex32.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Hex32.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Hex32 : public Ioss::ElementTopology
+  class IOSS_EXPORT Hex32 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Hex64.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Hex64.h
index 5f419d2f18aa7019acbfa2499bac6017a1110da2..b63db92ba2342c708c89f8aee1966144f2de4606 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Hex64.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Hex64.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Hex64 : public Ioss::ElementTopology
+  class IOSS_EXPORT Hex64 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Hex8.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Hex8.h
index 6d0e13157cde94c0591dcbd1ed7532e31b846e87..8ba5ceaceb6f02fa873630fa82994fdd34f93ff4 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Hex8.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Hex8.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Hex8 : public Ioss::ElementTopology
+  class IOSS_EXPORT Hex8 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Hex9.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Hex9.h
index 197fcf103f8bb94f11c316048d5cc18de034481f..2f155c7355779ba9dc87a88e7790812a1de4f8bc 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Hex9.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Hex9.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Hex9 : public Ioss::ElementTopology
+  class IOSS_EXPORT Hex9 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Node.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Node.h
index 8a1d1cfc830ae3c9c049542ac63b4cb31c6a9819..a710ad8a9fd92ab09f10a914c5e2cbb85c5ab1d2 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Node.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Node.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Node : public Ioss::ElementTopology
+  class IOSS_EXPORT Node final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Pyramid13.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Pyramid13.h
index 9e4c4c56d9e06d680d039661f76469018a49cca9..d10445a7c1be73f85aedfdbf5f519642220847a7 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Pyramid13.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Pyramid13.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Pyramid13 : public Ioss::ElementTopology
+  class IOSS_EXPORT Pyramid13 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Pyramid14.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Pyramid14.h
index 7c036c8745ff067694f109eb582b3311768b692e..81f3f04e89bcb5ffe7c6a3b1ca2351e4fcb4b4cc 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Pyramid14.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Pyramid14.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Pyramid14 : public Ioss::ElementTopology
+  class IOSS_EXPORT Pyramid14 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Pyramid18.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Pyramid18.h
index c082225532e4a7a8e474b3fa7a715efe171d7085..798316b8666d89d4dddf11515ce8b339bd0df037 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Pyramid18.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Pyramid18.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Pyramid18 : public Ioss::ElementTopology
+  class IOSS_EXPORT Pyramid18 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Pyramid19.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Pyramid19.h
index 3aa8a591119b23073e580ccccbb4f1b2b9750cc2..bfd2f393b9f897a1a04233b2502f2f093b1b93a1 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Pyramid19.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Pyramid19.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Pyramid19 : public Ioss::ElementTopology
+  class IOSS_EXPORT Pyramid19 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Pyramid5.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Pyramid5.h
index d4155ab9ac42b47d5091df6e3ad77068c963a29c..d313fca452b060e645070a9fa5bfdeafcc62b87d 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Pyramid5.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Pyramid5.h
@@ -14,7 +14,7 @@
 #include "vtk_ioss_mangle.h"
 
 namespace Ioss {
-  class IOSS_EXPORT Pyramid5 : public Ioss::ElementTopology
+  class IOSS_EXPORT Pyramid5 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Quad12.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Quad12.h
index 4daf146fc3584c53a3f0c36bbcf3d0bece43f1ec..5b6a043893afeffbe89f5d674587feadfd7355fd 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Quad12.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Quad12.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Quad12 : public Ioss::ElementTopology
+  class IOSS_EXPORT Quad12 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Quad16.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Quad16.h
index b5cc42a38f9fa06418d96450546e37b6708873a4..f960975379da8cca9391911c3508d733628457e6 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Quad16.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Quad16.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Quad16 : public Ioss::ElementTopology
+  class IOSS_EXPORT Quad16 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Quad4.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Quad4.h
index 93abf030e701446f8fa870fec7099b61552f1f46..c90ca9df96ce710e010e1b3f3ca54c66379403f1 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Quad4.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Quad4.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Quad4 : public Ioss::ElementTopology
+  class IOSS_EXPORT Quad4 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Quad6.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Quad6.h
index 2d808b6aa6b5b41b253a59bab9e0d6e3f1a3b86f..631b25482f875897606a53a363a6ed77513a4a79 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Quad6.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Quad6.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Quad6 : public Ioss::ElementTopology
+  class IOSS_EXPORT Quad6 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Quad8.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Quad8.h
index f41288eec836207af0061dba3db38263d897022c..3e503bec55d82d6411794df6a5b3c880e2115f8c 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Quad8.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Quad8.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Quad8 : public Ioss::ElementTopology
+  class IOSS_EXPORT Quad8 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Quad9.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Quad9.h
index 7ad4f5f6da2b6f98ed30de40d464d22a53ca41ab..555d57b6e64644c7a30fe83313ce2b23232f99ec 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Quad9.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Quad9.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Quad9 : public Ioss::ElementTopology
+  class IOSS_EXPORT Quad9 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Shell4.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Shell4.h
index 4e958d2a7c8b3697f627320301430cdc5c0ed243..dec633d0d9ce8db12568920aaa700ee6f2a17b86 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Shell4.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Shell4.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Shell4 : public Ioss::ElementTopology
+  class IOSS_EXPORT Shell4 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Shell8.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Shell8.h
index 7dbe8612b75d318d57c29b0d29605e96d32dc9a8..539279a7fc5effbe5f05fa0ee6c1772fc3da6205 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Shell8.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Shell8.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Shell8 : public Ioss::ElementTopology
+  class IOSS_EXPORT Shell8 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Shell9.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Shell9.h
index adedd91d675914450d2722a6c9098bb3adf34d05..9d6f2d8fbd58c51bbe9ed2dcb41840cda0a6460b 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Shell9.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Shell9.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Shell9 : public Ioss::ElementTopology
+  class IOSS_EXPORT Shell9 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_ShellLine2D2.h b/ThirdParty/ioss/vtkioss/elements/Ioss_ShellLine2D2.h
index 3614ed9c7b4555749a2a2a6b52a320af4b99916d..d51a74aa018391db9941f563bb6352ec879b85f6 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_ShellLine2D2.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_ShellLine2D2.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT ShellLine2D2 : public Ioss::ElementTopology
+  class IOSS_EXPORT ShellLine2D2 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_ShellLine2D3.h b/ThirdParty/ioss/vtkioss/elements/Ioss_ShellLine2D3.h
index 09adcee7a521be0ca9bfd3d4d3c6f1285a3fa4e9..9d8edc284331fe21a9679ca2e70f3df749973551 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_ShellLine2D3.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_ShellLine2D3.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT ShellLine2D3 : public Ioss::ElementTopology
+  class IOSS_EXPORT ShellLine2D3 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Sphere.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Sphere.h
index c0d1e31477c6766c08051af3fac4ba890d47478a..312e72e9aaaf066652743a6ea84368a42f22544a 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Sphere.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Sphere.h
@@ -14,7 +14,7 @@
 #include "vtk_ioss_mangle.h"
 
 namespace Ioss {
-  class IOSS_EXPORT Sphere : public Ioss::ElementTopology
+  class IOSS_EXPORT Sphere final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Spring2.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Spring2.h
index 90a02fde812ab492165043518844528ec4f2af3c..e90e6a9b1cd3f4930dab15e1eabbd309f955ae17 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Spring2.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Spring2.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Spring2 : public Ioss::ElementTopology
+  class IOSS_EXPORT Spring2 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Spring3.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Spring3.h
index eb21a67ed3db72c7d216a5d1e942aa4105d92f4c..6a31883b10c48ac74449474e899c33abb1449fdd 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Spring3.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Spring3.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Spring3 : public Ioss::ElementTopology
+  class IOSS_EXPORT Spring3 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Super.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Super.h
index 6705a34f811e36554d11714233f55156af940f8c..ec991c466b51fac0a80b3fa5e43b9d4f96128dc0 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Super.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Super.h
@@ -21,7 +21,7 @@ namespace Ioss {
 
 namespace Ioss {
 
-  class IOSS_EXPORT Super : public Ioss::ElementTopology
+  class IOSS_EXPORT Super final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Tet10.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Tet10.h
index 162ee5d78c1b66d5b01965187ae5129426a830e9..164414fcaf3c3cb58a1b84d46c4343aa9efc528c 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Tet10.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Tet10.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Tet10 : public Ioss::ElementTopology
+  class IOSS_EXPORT Tet10 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Tet11.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Tet11.h
index aa52210f4c72c74570b750170e56ab9a52e9c974..39a5dd220797e32a37935205281216ddc7acc807 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Tet11.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Tet11.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Tet11 : public Ioss::ElementTopology
+  class IOSS_EXPORT Tet11 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Tet14.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Tet14.h
index 3b0316dfee0c0a8cf2ea7a2590662ca8ae554ccf..d9892fc96828a7a1afdc215a8b560e1d6b454562 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Tet14.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Tet14.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Tet14 : public Ioss::ElementTopology
+  class IOSS_EXPORT Tet14 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Tet15.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Tet15.h
index 0327f9f9a07d71fd6173f3f8bb02d4292c1f38ab..678fc843571d8dfb43da6dcc04873b95363e89c7 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Tet15.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Tet15.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Tet15 : public Ioss::ElementTopology
+  class IOSS_EXPORT Tet15 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Tet16.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Tet16.h
index 49914ea0459c520cff8103f62ffb086f41d77509..4b9b37498bdb950e0c60b2ed6de247ed7ada490e 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Tet16.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Tet16.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Tet16 : public Ioss::ElementTopology
+  class IOSS_EXPORT Tet16 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Tet4.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Tet4.h
index 7e774f8ff2e783900db28b454136c40544ece34c..7bc8a14b1b28cf17773fba0ccdb3042e3d069c92 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Tet4.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Tet4.h
@@ -14,7 +14,7 @@
 #include "vtk_ioss_mangle.h"
 
 namespace Ioss {
-  class IOSS_EXPORT Tet4 : public Ioss::ElementTopology
+  class IOSS_EXPORT Tet4 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Tet40.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Tet40.h
index 354e7019401c85cb11933968eca524c3581843b1..731f661cf2578fde59162788e8f62cb95dfe6d94 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Tet40.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Tet40.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Tet40 : public Ioss::ElementTopology
+  class IOSS_EXPORT Tet40 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Tet7.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Tet7.h
index 9485feda0d8e38c65dbb6872dfcb0bc3152b78a2..00b6dc23a63d85dabf1c79394fd0670fd77240ca 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Tet7.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Tet7.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Tet7 : public Ioss::ElementTopology
+  class IOSS_EXPORT Tet7 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Tet8.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Tet8.h
index f008c017b42b4b28e51350c53a24458d416c1b58..ea2f08e1990ef2a48c442bc57f5976b341cc325b 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Tet8.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Tet8.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Tet8 : public Ioss::ElementTopology
+  class IOSS_EXPORT Tet8 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Tri13.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Tri13.h
index c9b1c9093f4b61e37493cfb3d6b414535cfb66b2..71ba9e2c0a99608472790eb02e6b7dd96b80f2f6 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Tri13.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Tri13.h
@@ -14,7 +14,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Tri13 : public Ioss::ElementTopology
+  class IOSS_EXPORT Tri13 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Tri3.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Tri3.h
index 26f5493e7296b477a94afa27417fe579bb180c5f..aa80c0ad3ba4426dadf4c3bf36b3c01ef3bf33a5 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Tri3.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Tri3.h
@@ -13,7 +13,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Tri3 : public Ioss::ElementTopology
+  class IOSS_EXPORT Tri3 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Tri4.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Tri4.h
index a5b6a163bfdae75a6e5bafa9739023112dd6f967..fdfb06ac45e0ff1b2921127db3db0d59bc128c00 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Tri4.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Tri4.h
@@ -14,7 +14,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Tri4 : public Ioss::ElementTopology
+  class IOSS_EXPORT Tri4 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Tri4a.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Tri4a.h
index 67ec691be70c9e737e20eaf3ae1ada89b9898ea5..a290fdd5b72adc153374cbcf22105923d60ebd1a 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Tri4a.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Tri4a.h
@@ -14,7 +14,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Tri4a : public Ioss::ElementTopology
+  class IOSS_EXPORT Tri4a final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Tri6.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Tri6.h
index c302e06fde6d3044bd8a1370538deaa9aa137488..38e98dd1d0b7ec9d0caefd8832f7303f0be3ea49 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Tri6.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Tri6.h
@@ -14,7 +14,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Tri6 : public Ioss::ElementTopology
+  class IOSS_EXPORT Tri6 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Tri7.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Tri7.h
index 4e53caa35531f1ed93356f6277c0c9e998f60c0c..2c0b363b64f343ab739eff6c9f6ea8ce7bf2358b 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Tri7.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Tri7.h
@@ -14,7 +14,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Tri7 : public Ioss::ElementTopology
+  class IOSS_EXPORT Tri7 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Tri9.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Tri9.h
index 9a64138dfd6d957fbc6be277d39534f39e993ee3..4c53b9458bf5d1311a34f76a59e4f1ed0345f262 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Tri9.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Tri9.h
@@ -14,7 +14,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Tri9 : public Ioss::ElementTopology
+  class IOSS_EXPORT Tri9 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_TriShell3.h b/ThirdParty/ioss/vtkioss/elements/Ioss_TriShell3.h
index 22025b3ffe2db247b7ee4b926290033ad3d3903e..305a9e63bce1e649125cad359927b16a5e48de2e 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_TriShell3.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_TriShell3.h
@@ -14,7 +14,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT TriShell3 : public Ioss::ElementTopology
+  class IOSS_EXPORT TriShell3 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_TriShell4.h b/ThirdParty/ioss/vtkioss/elements/Ioss_TriShell4.h
index 4ab136382b6abe0ddfe613f5d0891fb777f159ab..f3dfc3149ebae2dab05d440528d9086fb0738229 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_TriShell4.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_TriShell4.h
@@ -14,7 +14,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT TriShell4 : public Ioss::ElementTopology
+  class IOSS_EXPORT TriShell4 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_TriShell6.h b/ThirdParty/ioss/vtkioss/elements/Ioss_TriShell6.h
index 38c710be4ea6f84ff4a4d2f98cece0913a57ff06..974032c03ebd3e05547aefc3b8abdf2a8be34a0d 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_TriShell6.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_TriShell6.h
@@ -14,7 +14,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT TriShell6 : public Ioss::ElementTopology
+  class IOSS_EXPORT TriShell6 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_TriShell7.h b/ThirdParty/ioss/vtkioss/elements/Ioss_TriShell7.h
index 8b755e57f55cfb153c9e5dd98b5d99cd932145e5..2077ebfb3c7cade48b514b2f161a4cd498af286a 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_TriShell7.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_TriShell7.h
@@ -14,7 +14,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT TriShell7 : public Ioss::ElementTopology
+  class IOSS_EXPORT TriShell7 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Unknown.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Unknown.h
index ad5b65d8fef4fb63a69fdc9cf32ba90b5a98242a..463f36289767fdbf0ece7d3e7d4f8d96f7358d34 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Unknown.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Unknown.h
@@ -14,7 +14,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Unknown : public Ioss::ElementTopology
+  class IOSS_EXPORT Unknown final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge12.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge12.h
index ebbf373ec29eca9c57247cdd108bcb49945f4e47..c8c3d0f5962a06057d0db81590c8c6ba002904eb 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge12.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge12.h
@@ -14,7 +14,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Wedge12 : public Ioss::ElementTopology
+  class IOSS_EXPORT Wedge12 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge15.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge15.h
index 99e037ee660580a4c163bdc8920f383ed406a98d..16f7e7782468755bbb394a30511126c26344796b 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge15.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge15.h
@@ -14,7 +14,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Wedge15 : public Ioss::ElementTopology
+  class IOSS_EXPORT Wedge15 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge16.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge16.h
index 601277261666aaf673f17f8fb969f4290171a274..a58093817ca5b06b3a45fed48be483294850da01 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge16.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge16.h
@@ -14,7 +14,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Wedge16 : public Ioss::ElementTopology
+  class IOSS_EXPORT Wedge16 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge18.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge18.h
index f4cc950aa794b9df78c191d46e10cde306b8c7e3..b5393aa5dc22f741cee9defa4ca0b849a6aaa67f 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge18.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge18.h
@@ -14,7 +14,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Wedge18 : public Ioss::ElementTopology
+  class IOSS_EXPORT Wedge18 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge20.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge20.h
index 661d53020bb7f6958e9811d3771c89c94ebd901f..1d3e74f0cb45ff5e6fbdbf077cf45500b84bcf3f 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge20.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge20.h
@@ -14,7 +14,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Wedge20 : public Ioss::ElementTopology
+  class IOSS_EXPORT Wedge20 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge21.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge21.h
index e7bc457e2eeee33f0428916c91f4f894d7ae8d12..1e55d52b30bd7666177ac916d90d327ebb818616 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge21.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge21.h
@@ -14,7 +14,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Wedge21 : public Ioss::ElementTopology
+  class IOSS_EXPORT Wedge21 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge24.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge24.h
index eb0dc850712c1fac664ea15d6d3eda3220f481cc..4157ff4cbb8e4f3021538f9d661fcf748ba79d82 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge24.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge24.h
@@ -14,7 +14,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Wedge24 : public Ioss::ElementTopology
+  class IOSS_EXPORT Wedge24 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge52.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge52.h
index c6ef769e989e092b8fc66fae7000f2996f99a3b9..0488b60923606ec5967b41740e5c1f7a041e3c3c 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge52.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge52.h
@@ -14,7 +14,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Wedge52 : public Ioss::ElementTopology
+  class IOSS_EXPORT Wedge52 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge6.h b/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge6.h
index 18c70e70fb8b85ca7109ed15d1d7af78be2a2ca0..4fa11b232f7d135e0328fdc0d4a4374f564830fd 100644
--- a/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge6.h
+++ b/ThirdParty/ioss/vtkioss/elements/Ioss_Wedge6.h
@@ -14,7 +14,7 @@
 #include "Ioss_ElementTopology.h" // for ElementTopology
 
 namespace Ioss {
-  class IOSS_EXPORT Wedge6 : public Ioss::ElementTopology
+  class IOSS_EXPORT Wedge6 final : public Ioss::ElementTopology
   {
 
   public:
diff --git a/ThirdParty/ioss/vtkioss/exodus/Ioex_BaseDatabaseIO.C b/ThirdParty/ioss/vtkioss/exodus/Ioex_BaseDatabaseIO.C
index 8dbab23257fbbee9d1a255013fb349fca8cbfa23..7ce27ff69be7a9c557c33cc057bf14afa890204c 100644
--- a/ThirdParty/ioss/vtkioss/exodus/Ioex_BaseDatabaseIO.C
+++ b/ThirdParty/ioss/vtkioss/exodus/Ioex_BaseDatabaseIO.C
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -166,44 +166,6 @@ namespace {
     mutable std::vector<bool>       m_visitedAssemblies;
   };
 
-  std::vector<ex_assembly> get_exodus_assemblies(int exoid)
-  {
-    std::vector<ex_assembly> assemblies;
-    int                      nassem = ex_inquire_int(exoid, EX_INQ_ASSEMBLY);
-    if (nassem > 0) {
-      assemblies.resize(nassem);
-
-      int max_name_length = ex_inquire_int(exoid, EX_INQ_DB_MAX_USED_NAME_LENGTH);
-      for (auto &assembly : assemblies) {
-        assembly.name = new char[max_name_length + 1];
-      }
-
-      int ierr = ex_get_assemblies(exoid, Data(assemblies));
-      if (ierr < 0) {
-        Ioex::exodus_error(exoid, __LINE__, __func__, __FILE__);
-      }
-
-      // Now allocate space for member list and get assemblies again...
-      for (auto &assembly : assemblies) {
-        assembly.entity_list = new int64_t[assembly.entity_count];
-      }
-
-      ierr = ex_get_assemblies(exoid, Data(assemblies));
-      if (ierr < 0) {
-        Ioex::exodus_error(exoid, __LINE__, __func__, __FILE__);
-      }
-    }
-    return assemblies;
-  }
-
-  void cleanup_exodus_assembly_vector(std::vector<ex_assembly> &assemblies)
-  {
-    for (const auto &assembly : assemblies) {
-      delete[] assembly.entity_list;
-      delete[] assembly.name;
-    }
-  }
-
 } // namespace
 
 namespace Ioex {
@@ -267,6 +229,9 @@ namespace Ioex {
 
     // See if there are any properties that need to (or can) be
     // handled prior to opening/creating database...
+    Ioss::Utils::check_set_bool_property(properties, "IOSS_TIME_FILE_OPEN_CLOSE",
+                                         timeFileOpenCloseFlush);
+
     if (properties.exists("FILE_TYPE")) {
       std::string type = properties.get("FILE_TYPE").get_string();
       type             = Ioss::Utils::lowercase(type);
@@ -438,15 +403,11 @@ namespace Ioex {
   int BaseDatabaseIO::free_file_pointer() const
   {
     if (m_exodusFilePtr != -1) {
-      bool do_timer = false;
-      if (isParallel) {
-        Ioss::Utils::check_set_bool_property(properties, "IOSS_TIME_FILE_OPEN_CLOSE", do_timer);
-      }
-      double t_begin = (do_timer ? Ioss::Utils::timer() : 0);
+      double t_begin = (timeFileOpenCloseFlush ? Ioss::Utils::timer() : 0);
 
       ex_close(m_exodusFilePtr);
       close_dw();
-      if (do_timer && isParallel) {
+      if (timeFileOpenCloseFlush) {
         double t_end    = Ioss::Utils::timer();
         double duration = util().global_minmax(t_end - t_begin, Ioss::ParallelUtils::DO_MAX);
         if (myProcessor == 0) {
@@ -803,7 +764,7 @@ namespace Ioex {
     Ioss::SerializeIO serializeIO_(this);
 
     // Query number of assemblies...
-    auto assemblies = get_exodus_assemblies(get_file_pointer());
+    auto assemblies = Ioex::get_exodus_assemblies(get_file_pointer());
     if (!assemblies.empty()) {
       Ioss::NameList exclusions;
       Ioss::NameList inclusions;
@@ -831,7 +792,7 @@ namespace Ioex {
       exclusionFilter.update_assembly_filter_list(assemblyOmissions);
       inclusionFilter.update_assembly_filter_list(assemblyInclusions);
 
-      cleanup_exodus_assembly_vector(assemblies);
+      Ioex::cleanup_exodus_assembly_vector(assemblies);
 
       Ioss::Utils::insert_sort_and_unique(exclusions, blockOmissions);
       Ioss::Utils::insert_sort_and_unique(inclusions, blockInclusions);
@@ -842,7 +803,7 @@ namespace Ioex {
   {
     Ioss::SerializeIO serializeIO_(this);
 
-    auto assemblies = get_exodus_assemblies(get_file_pointer());
+    auto assemblies = Ioex::get_exodus_assemblies(get_file_pointer());
     if (!assemblies.empty()) {
       for (const auto &assembly : assemblies) {
         auto *assem = new Ioss::Assembly(get_region()->get_database(), assembly.name);
@@ -890,7 +851,7 @@ namespace Ioex {
           m_reductionValues[EX_ASSEMBLY][assembly.id].resize(size);
         }
       }
-      cleanup_exodus_assembly_vector(assemblies);
+      Ioex::cleanup_exodus_assembly_vector(assemblies);
 
       assert(assemblyOmissions.empty() || assemblyInclusions.empty()); // Only one can be non-empty
 
@@ -1557,19 +1518,20 @@ namespace Ioex {
     }
   }
 
-  bool BaseDatabaseIO::begin_state_nl(int state, double time)
+  bool BaseDatabaseIO::begin_state_nl(int state, double a_time)
   {
     Ioss::SerializeIO serializeIO_(this);
 
-    time /= timeScaleFactor;
+    a_time /= timeScaleFactor;
 
     if (!is_input()) {
+      timeBeginStep = time(nullptr);
       if (get_file_per_state()) {
         // Close current file; create new file and output transient metadata...
         open_state_file(state);
         write_results_metadata(false, open_create_behavior());
       }
-      int ierr = ex_put_time(get_file_pointer(), get_database_step(state), &time);
+      int ierr = ex_put_time(get_file_pointer(), get_database_step(state), &a_time);
       if (ierr < 0) {
         Ioex::exodus_error(get_file_pointer(), __LINE__, __func__, __FILE__);
       }
@@ -1591,14 +1553,14 @@ namespace Ioex {
   }
 
   // common
-  bool BaseDatabaseIO::end_state_nl(int state, double time)
+  bool BaseDatabaseIO::end_state_nl(int state, double a_time)
   {
     Ioss::SerializeIO serializeIO_(this);
 
     if (!is_input()) {
       write_reduction_fields();
-      time /= timeScaleFactor;
-      finalize_write(state, time);
+      a_time /= timeScaleFactor;
+      finalize_write(state, a_time);
       if (minimizeOpenFiles) {
         free_file_pointer();
       }
@@ -1699,6 +1661,7 @@ namespace Ioex {
                                                       Ioex::VariableNameMap &variables)
   {
     int nvar = 0;
+
     {
       Ioss::SerializeIO serializeIO_(this);
 
@@ -1708,6 +1671,18 @@ namespace Ioex {
       }
     }
 
+    // Synchronize among all processors....
+    if (isParallel) {
+      std::vector<int> var_count{nvar, -nvar};
+      util().global_array_minmax(var_count, Ioss::ParallelUtils::DO_MAX);
+
+      if (var_count[0] != -var_count[1]) {
+        IOSS_ABORT(fmt::format("ERROR: Inconsistent number of {} fields ({} to {}) on file '{}'.\n",
+                               Ioss::Utils::entity_type_to_string(Ioex::map_exodus_type(type)),
+                               -var_count[1], var_count[0], get_filename()));
+      }
+    }
+
     if (nvar > 0) {
 
       if (truth_table.empty()) {
@@ -1797,7 +1772,7 @@ namespace Ioex {
                                                       ex_entity_type type, Ioss::NameList &names)
   {
     std::vector<Ioss::Field> fields;
-    if (!entity->get_database()->get_field_recognition()) {
+    if (!using_parallel_io() || !entity->get_database()->get_field_recognition()) {
       return fields;
     }
     // See if this entity is using enhanced field attributes...
@@ -1901,6 +1876,9 @@ namespace Ioex {
                 }
               }
               names[j] = "";
+              if (i == 0) {
+                field.set_index(j);
+              }
               break;
             }
           }
@@ -2091,7 +2069,7 @@ namespace Ioex {
       }
 
       // Output field metadata
-      bool do_metadata = true;
+      bool do_metadata = false;
       Ioss::Utils::check_set_bool_property(properties, "OUTPUT_FIELD_METADATA", do_metadata);
       if (do_metadata) {
         output_field_metadata();
@@ -2572,9 +2550,17 @@ namespace Ioex {
   void BaseDatabaseIO::flush_database_nl() const
   {
     if (!is_input()) {
+      double t_begin = (timeFileOpenCloseFlush ? Ioss::Utils::timer() : 0);
       if (isParallel || myProcessor == 0) {
         ex_update(get_file_pointer());
       }
+      if (timeFileOpenCloseFlush) {
+        double t_end    = Ioss::Utils::timer();
+        double duration = util().global_minmax(t_end - t_begin, Ioss::ParallelUtils::DO_MAX);
+        if (myProcessor == 0) {
+          fmt::print(Ioss::DebugOut(), "File Flush Time = {} ({})\n", duration, get_filename());
+        }
+      }
     }
   }
 
@@ -2604,6 +2590,8 @@ namespace Ioex {
     //  flushInterval == 1 -- flush every step
     //
     //  flushInterval > 1 -- flush if step % flushInterval == 0
+    //
+    //  if time between begin_state and end_state is > 10 seconds,
 
     bool do_flush = true;
     if (flushInterval == 1) {
@@ -2635,6 +2623,24 @@ namespace Ioex {
       }
     }
 
+    if (flushInterval != 0 && !do_flush) {
+      // One last check -- if output took more than 10 seconds (arbitrary)
+      // then flush since the relative flush cost is outweighted by the time
+      // it took to do the output (Basically, we have a lot of data being output...)
+      time_t cur_time = time(nullptr);
+      if (cur_time - timeBeginStep >= 10) {
+        timeLastFlush = cur_time;
+        do_flush      = true;
+      }
+#ifdef SEACAS_HAVE_MPI
+      if (isParallel) {
+        int iflush = do_flush ? 1 : 0;
+        util().broadcast(iflush);
+        do_flush = iflush == 1;
+      }
+#endif
+    }
+
     if (do_flush) {
       flush_database_nl();
     }
@@ -3111,7 +3117,7 @@ namespace Ioex {
           df_count += block->get_property("distribution_factor_count").get_int();
         }
         auto *new_entity = const_cast<Ioss::SideSet *>(set);
-        new_entity->property_add(Ioss::Property("entity_count", entity_count));
+        new_entity->reset_entity_count(entity_count);
         new_entity->property_add(Ioss::Property("distribution_factor_count", df_count));
       }
       m_groupCount[EX_SIDE_SET] = ssets.size();
@@ -3608,10 +3614,6 @@ namespace {
                                   IOSS_MAYBE_UNUSED const std::string &filename,
                                   IOSS_MAYBE_UNUSED const Ioss::ParallelUtils &util)
   {
-    IOSS_PAR_UNUSED(exo_params);
-    IOSS_PAR_UNUSED(my_processor);
-    IOSS_PAR_UNUSED(filename);
-    IOSS_PAR_UNUSED(util);
 #ifdef SEACAS_HAVE_MPI
     const int        num_types = 10;
     std::vector<int> var_counts(num_types);
diff --git a/ThirdParty/ioss/vtkioss/exodus/Ioex_BaseDatabaseIO.h b/ThirdParty/ioss/vtkioss/exodus/Ioex_BaseDatabaseIO.h
index a182fea09bb7f49eaf94a21ba3b8a8c2f985ac3d..9c011583ed7e9676548a0f97e84335d499264a4f 100644
--- a/ThirdParty/ioss/vtkioss/exodus/Ioex_BaseDatabaseIO.h
+++ b/ThirdParty/ioss/vtkioss/exodus/Ioex_BaseDatabaseIO.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -407,9 +407,11 @@ namespace Ioex {
     mutable std::map<std::string, Ioss::Int64Vector> activeNodeSetNodesIndex;
 
     time_t timeLastFlush{0};
+    time_t timeBeginStep{0};
     int    flushInterval{-1};
     int    m_timestepCount{0};
 
+    bool         timeFileOpenCloseFlush{false};
     mutable bool fileExists{false}; // False if file has never been opened/created
     mutable bool minimizeOpenFiles{false};
 
diff --git a/ThirdParty/ioss/vtkioss/exodus/Ioex_DatabaseIO.C b/ThirdParty/ioss/vtkioss/exodus/Ioex_DatabaseIO.C
index 824c7558d141760ba57642ebbf40494aa32a5c49..806f6576e6df57d84580a693595a3c5addf720d3 100644
--- a/ThirdParty/ioss/vtkioss/exodus/Ioex_DatabaseIO.C
+++ b/ThirdParty/ioss/vtkioss/exodus/Ioex_DatabaseIO.C
@@ -239,7 +239,7 @@ namespace Ioex {
           *bad_count = std::count_if(status.begin(), status.end(), [](int i) { return i < 0; });
         }
         if (abort_if_error) {
-          IOSS_ERROR(fmt::format("ERROR: Cannot {} file '{}'\n", open_create, get_filename()));
+          IOSS_ABORT(fmt::format("ERROR: Cannot {} file '{}'\n", open_create, get_filename()));
         }
       }
       return false;
@@ -266,15 +266,13 @@ namespace Ioex {
     }
 #endif
 
-    bool do_timer = false;
-    Ioss::Utils::check_set_bool_property(properties, "IOSS_TIME_FILE_OPEN_CLOSE", do_timer);
-    double t_begin = ((do_timer && isParallel) ? Ioss::Utils::timer() : 0);
+    double t_begin = (timeFileOpenCloseFlush ? Ioss::Utils::timer() : 0);
 
     int app_opt_val = ex_opts(EX_VERBOSE);
     m_exodusFilePtr = ex_open(decoded_filename().c_str(), EX_READ | mode, &cpu_word_size,
                               &io_word_size, &version);
 
-    if (do_timer && isParallel) {
+    if (timeFileOpenCloseFlush) {
       double t_end    = Ioss::Utils::timer();
       double duration = util().global_minmax(t_end - t_begin, Ioss::ParallelUtils::DO_MAX);
       if (myProcessor == 0) {
@@ -340,7 +338,8 @@ namespace Ioex {
       mode |= EX_DISKLESS;
     }
 #endif
-    int app_opt_val = ex_opts(EX_VERBOSE);
+    int    app_opt_val = ex_opts(EX_VERBOSE);
+    double t_begin     = (timeFileOpenCloseFlush ? Ioss::Utils::timer() : 0);
     if (fileExists) {
       m_exodusFilePtr = ex_open(decoded_filename().c_str(), EX_WRITE | mode, &cpu_word_size,
                                 &io_word_size, &version);
@@ -363,6 +362,14 @@ namespace Ioex {
       m_exodusFilePtr =
           ex_create(decoded_filename().c_str(), mode, &cpu_word_size, &dbRealWordSize);
     }
+    if (timeFileOpenCloseFlush) {
+      double t_end    = Ioss::Utils::timer();
+      double duration = util().global_minmax(t_end - t_begin, Ioss::ParallelUtils::DO_MAX);
+      if (myProcessor == 0) {
+        fmt::print(Ioss::DebugOut(), "File {} Time = {} ({})\n", fileExists ? "Open" : "Create",
+                   duration, decoded_filename());
+      }
+    }
 
     is_ok = check_valid_file_ptr(write_message, error_msg, bad_count, abort_if_error);
 
@@ -453,12 +460,12 @@ namespace Ioex {
     // Checks that the file is open and if not, opens it first.
     if (Ioss::SerializeIO::isEnabled()) {
       if (!Ioss::SerializeIO::inBarrier()) {
-        IOSS_ERROR(fmt::format("ERROR: Process {} is attempting to do I/O without serialized I/O",
+        IOSS_ABORT(fmt::format("ERROR: Process {} is attempting to do I/O without serialized I/O",
                                Ioss::SerializeIO::getRank()));
       }
 
       if (!Ioss::SerializeIO::inMyGroup()) {
-        IOSS_ERROR(fmt::format("ERROR: Process {} is attempting to do I/O while {} owns the token",
+        IOSS_ABORT(fmt::format("ERROR: Process {} is attempting to do I/O while {} owns the token",
                                Ioss::SerializeIO::getRank(), Ioss::SerializeIO::getOwner()));
       }
     }
@@ -586,7 +593,7 @@ namespace Ioex {
     }
     else if (nodeCount < 0) {
       // NOTE: Code will not continue past this call...
-      IOSS_ERROR(fmt::format("ERROR: Negative node count was found in the model\n"
+      IOSS_ABORT(fmt::format("ERROR: Negative node count was found in the model\n"
                              "       File: '{}'.\n",
                              decoded_filename()));
     }
@@ -598,14 +605,14 @@ namespace Ioex {
 
     if (elementCount < 0) {
       // NOTE: Code will not continue past this call...
-      IOSS_ERROR(fmt::format("ERROR: Negative element count was found in the model\n"
+      IOSS_ABORT(fmt::format("ERROR: Negative element count was found in the model\n"
                              "       File: '{}'.\n",
                              decoded_filename()));
     }
 
     if (elementCount > 0 && m_groupCount[EX_ELEM_BLOCK] <= 0) {
       // NOTE: Code will not continue past this call...
-      IOSS_ERROR(fmt::format("ERROR: No element blocks were found in the model\n"
+      IOSS_ABORT(fmt::format("ERROR: No element blocks were found in the model\n"
                              "       File: '{}'.\n",
                              decoded_filename()));
     }
@@ -723,12 +730,22 @@ namespace Ioex {
           auto max_timestep_count =
               util().global_minmax(timestepCount, Ioss::ParallelUtils::DO_MAX);
           if (max_timestep_count != 0) {
+            std::vector<int> all_counts;
+            util().gather(timestepCount, all_counts);
             if (myProcessor == 0) {
+              // Determine which rank(s) have no timesteps..
+              std::vector<size_t> ranks;
+              for (size_t i = 0; i < all_counts.size(); i++) {
+                if (all_counts[i] == 0) {
+                  ranks.push_back(i);
+                }
+              }
               // NOTE: Don't want to warn on all processors if the
               // timestep count is zero on some, but not all ranks.
               fmt::print(Ioss::WarnOut(),
-                         "At least one database has no timesteps.  No times will be read on ANY"
-                         " database for consistency.\n");
+                         "On rank(s) {}, the database `{}` has no timesteps.\n"
+                         "\tNo times will be read on ANY rank for consistency.\n\n",
+                         Ioss::Utils::format_id_list(ranks, ".."), get_filename());
             }
           }
         }
@@ -825,6 +842,15 @@ namespace Ioex {
         }
       }
 
+      std::vector<int> step_count{numSteps, -numSteps};
+      util().global_array_minmax(step_count, Ioss::ParallelUtils::DO_MIN);
+      if (step_count[0] != -step_count[1]) {
+        IOSS_ABORT(fmt::format("ERROR: The database file '{}' does not contain the same number\n"
+                               "       of timesteps (or time values) on all processors."
+                               "  The range is {} to {}.\n",
+                               get_filename(), step_count[0], -step_count[1]));
+      }
+
       tsteps.resize(numSteps);
     }
 
@@ -870,7 +896,7 @@ namespace Ioex {
       // Not a nemesis file
       nemesis_file = false;
       if (isParallel && util().parallel_size() > 1) {
-        IOSS_ERROR(fmt::format("ERROR: Exodus file '{}' does not contain nemesis information.\n",
+        IOSS_ABORT(fmt::format("ERROR: Exodus file '{}' does not contain nemesis information.\n",
                                get_filename()));
       }
       file_type[0] = 'p';
@@ -886,19 +912,19 @@ namespace Ioex {
     }
 
     if (isParallel && num_proc != util().parallel_size() && util().parallel_size() > 1) {
-      IOSS_ERROR(fmt::format(
+      IOSS_ABORT(fmt::format(
           "ERROR: Exodus file '{}' was decomposed for {} processors; application is currently "
           "being run on {} processors",
           get_filename(), num_proc, util().parallel_size()));
     }
     if (num_proc_in_file != 1) {
-      IOSS_ERROR(fmt::format(
+      IOSS_ABORT(fmt::format(
           "ERROR: Exodus file '{}' contains data for {} processors; application requires 1 "
           "processor per file.",
           get_filename(), num_proc_in_file));
     }
     if (file_type[0] != 'p') {
-      IOSS_ERROR(fmt::format(
+      IOSS_ABORT(fmt::format(
           "ERROR: Exodus file '{}' contains scalar nemesis data; application requires parallel "
           "nemesis data.",
           get_filename()));
@@ -1015,7 +1041,7 @@ namespace Ioex {
     case EX_EDGE_SET: return get_map(edgeMap, edgeCount, EX_EDGE_MAP, EX_INQ_EDGE_MAP);
 
     default:
-      IOSS_ERROR("INTERNAL ERROR: Invalid map type. "
+      IOSS_ABORT("INTERNAL ERROR: Invalid map type. "
                  "Something is wrong in the Ioex::DatabaseIO::get_map() function. "
                  "Please report.\n");
     }
@@ -1034,7 +1060,7 @@ namespace Ioex {
       case EX_FACE_MAP: read_exodus_map = !properties.exists("IGNORE_FACE_MAP"); break;
       case EX_EDGE_MAP: read_exodus_map = !properties.exists("IGNORE_EDGE_MAP"); break;
       default:
-        IOSS_ERROR("INTERNAL ERROR: Invalid map type. "
+        IOSS_ABORT("INTERNAL ERROR: Invalid map type. "
                    "Something is wrong in the Ioex::DatabaseIO::get_map() function. "
                    "Please report.\n");
       }
@@ -1262,7 +1288,7 @@ namespace Ioex {
       else {
         Ioss::SerializeIO serializeio_(this);
         block_name = Ioex::get_entity_name(get_file_pointer(), entity_type, id, basename,
-                                           maximumNameLength, db_has_name);
+                                           maximumNameLength, lowerCaseDatabaseNames, db_has_name);
       }
       if (get_use_generic_canonical_name()) {
         std::swap(block_name, alias);
@@ -1324,7 +1350,7 @@ namespace Ioex {
         get_region()->add(eblock);
       }
       else {
-        IOSS_ERROR("ERROR: Invalid type in get_blocks()");
+        IOSS_ABORT("ERROR: Invalid type in get_blocks()");
       }
 
       // See which connectivity options were defined for this block.
@@ -1552,7 +1578,6 @@ namespace Ioex {
           }
           if (ss_name[0] != '\0') {
             Ioss::Utils::fixup_name(Data(ss_name));
-            Ioex::decode_surface_name(fs_map, fs_set, Data(ss_name));
           }
         }
       }
@@ -1591,8 +1616,9 @@ namespace Ioex {
             side_set_name = alias;
           }
           else {
-            side_set_name = Ioex::get_entity_name(get_file_pointer(), EX_SIDE_SET, id, "surface",
-                                                  maximumNameLength, db_has_name);
+            side_set_name =
+                Ioex::get_entity_name(get_file_pointer(), EX_SIDE_SET, id, "surface",
+                                      maximumNameLength, lowerCaseDatabaseNames, db_has_name);
           }
 
           if (side_set_name == "universal_sideset") {
@@ -1831,7 +1857,7 @@ namespace Ioex {
               else if (split_type == Ioss::SPLIT_BY_ELEMENT_BLOCK) {
                 block = get_region()->get_element_block(topo_or_block_name);
                 if (block == nullptr || Ioss::Utils::block_is_omitted(block)) {
-                  IOSS_ERROR(fmt::format(
+                  IOSS_ABORT(fmt::format(
                       "INTERNAL ERROR: Could not find element block '{}' Something is wrong "
                       "in the Ioex::DatabaseIO class. Please report.\n",
                       topo_or_block_name));
@@ -1845,7 +1871,7 @@ namespace Ioex {
                 elem_topo = Ioss::ElementTopology::factory(topo_or_block_name);
               }
               else {
-                IOSS_ERROR(fmt::format(
+                IOSS_ABORT(fmt::format(
                     "INTERNAL ERROR: Invalid setting for `split_type` {}. Something is wrong "
                     "in the Ioex::DatabaseIO class. Please report.\n",
                     static_cast<int>(split_type)));
@@ -1996,8 +2022,9 @@ namespace Ioex {
             Xset_name = alias;
           }
           else {
-            Xset_name = Ioex::get_entity_name(get_file_pointer(), type, id, base + "list",
-                                              maximumNameLength, db_has_name);
+            Xset_name =
+                Ioex::get_entity_name(get_file_pointer(), type, id, base + "list",
+                                      maximumNameLength, lowerCaseDatabaseNames, db_has_name);
           }
 
           if (get_use_generic_canonical_name()) {
@@ -2303,11 +2330,9 @@ namespace Ioex {
                 size_t ep_data_size = ent_proc.size() * sizeof(int64_t);
                 get_field_internal(css, ep_field, Data(ent_proc), ep_data_size);
                 for (size_t i = 0; i < ent_proc.size(); i += 2) {
-                  int64_t node = ent_proc[i + 0];
-                  int64_t proc = ent_proc[i + 1];
-                  if (proc < myProcessor) {
-                    idata[node - 1] = proc;
-                  }
+                  int64_t node    = ent_proc[i + 0];
+                  int64_t proc    = ent_proc[i + 1];
+                  idata[node - 1] = std::min(idata[node - 1], static_cast<int>(proc));
                 }
               }
               else {
@@ -2317,11 +2342,9 @@ namespace Ioex {
                 size_t           ep_data_size = ent_proc.size() * sizeof(int);
                 get_field_internal(css, ep_field, Data(ent_proc), ep_data_size);
                 for (size_t i = 0; i < ent_proc.size(); i += 2) {
-                  int node = ent_proc[i + 0];
-                  int proc = ent_proc[i + 1];
-                  if (proc < myProcessor) {
-                    idata[node - 1] = proc;
-                  }
+                  int node        = ent_proc[i + 0];
+                  int proc        = ent_proc[i + 1];
+                  idata[node - 1] = std::min(idata[node - 1], proc);
                 }
               }
             }
@@ -3258,7 +3281,7 @@ namespace Ioex {
             for (int64_t iel = 0; iel < 2 * entity_count; iel += 2) {
               int64_t new_id = static_cast<int64_t>(10) * els[iel] + els[iel + 1];
               if (new_id > int_max) {
-                IOSS_ERROR(fmt::format(
+                IOSS_ABORT(fmt::format(
                     "ERROR: Process {} accessing the sideset field 'ids'\n"
                     "\t\thas exceeded the integer bounds for entity {}, local side id {}"
                     ".\n\t\tTry using 64-bit mode to read the file '{}'.\n",
@@ -3939,7 +3962,7 @@ namespace Ioex {
       // Verify that number_distribution_factors is sane...
       if (number_sides * nfnodes != number_distribution_factors &&
           number_sides != number_distribution_factors) {
-        IOSS_ERROR(fmt::format(
+        IOSS_ABORT(fmt::format(
             "ERROR: SideBlock '{}' in file '{}'\n"
             "\thas incorrect distribution factor count.\n"
             "\tThere are {} '{}' sides with "
@@ -4039,7 +4062,7 @@ namespace Ioex {
       }
 
       if (block == nullptr) {
-        IOSS_ERROR(fmt::format(
+        IOSS_ABORT(fmt::format(
             "INTERNAL ERROR: Could not find element block containing element with id {}. "
             "Something is wrong in the Ioex::DatabaseIO class. Please report.\n",
             elem_id));
@@ -4048,7 +4071,7 @@ namespace Ioex {
       const Ioss::ElementTopology *topo = block->topology()->boundary_type(side_id);
 
       if (topo == nullptr) {
-        IOSS_ERROR("INTERNAL ERROR: Could not find topology of element block boundary. "
+        IOSS_ABORT("INTERNAL ERROR: Could not find topology of element block boundary. "
                    "Something is wrong in the Ioex::DatabaseIO class. Please report.\n");
       }
 
@@ -5485,7 +5508,7 @@ namespace Ioex {
           meta->elementMap.emplace_back(id, count, 'e');
         }
         else {
-          IOSS_ERROR("Internal Program Error...");
+          IOSS_ABORT("Internal Program Error...");
         }
       }
     }
diff --git a/ThirdParty/ioss/vtkioss/exodus/Ioex_DatabaseIO.h b/ThirdParty/ioss/vtkioss/exodus/Ioex_DatabaseIO.h
index 9bfb61d46d9ff268f5dbb780d9a9848c9d0dd8eb..e1ce760f350770e322ec3a0912c71cdd85e48414 100644
--- a/ThirdParty/ioss/vtkioss/exodus/Ioex_DatabaseIO.h
+++ b/ThirdParty/ioss/vtkioss/exodus/Ioex_DatabaseIO.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -59,7 +59,7 @@ namespace Ioex {
  *  parallel exodus database format.
  */
 namespace Ioex {
-  class IOEX_EXPORT DatabaseIO : public Ioex::BaseDatabaseIO
+  class IOEX_EXPORT DatabaseIO final : public Ioex::BaseDatabaseIO
   {
   public:
     DatabaseIO(Ioss::Region *region, const std::string &filename, Ioss::DatabaseUsage db_usage,
diff --git a/ThirdParty/ioss/vtkioss/exodus/Ioex_DecompositionData.C b/ThirdParty/ioss/vtkioss/exodus/Ioex_DecompositionData.C
index e88ab3a8d4cbacbd3a277923c8e4ebe93642e8a1..ddf8175e6c79e9d58969efda6c1053d895bbb1d1 100644
--- a/ThirdParty/ioss/vtkioss/exodus/Ioex_DecompositionData.C
+++ b/ThirdParty/ioss/vtkioss/exodus/Ioex_DecompositionData.C
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -157,6 +157,7 @@ namespace Ioex {
 
     if (!m_decomposition.m_lineDecomp) {
       generate_adjacency_list(filePtr, m_decomposition);
+      generate_omitted_block_weights(filePtr, m_decomposition);
     }
 
 #if IOSS_DEBUG_OUTPUT
@@ -515,6 +516,101 @@ namespace Ioex {
     decomposition.m_pointer.push_back(decomposition.m_adjacency.size());
   }
 
+  template <typename INT>
+  void
+  DecompositionData<INT>::generate_omitted_block_weights(int                       filePtr,
+                                                         Ioss::Decomposition<INT> &decomposition)
+  {
+    // This routine is assumed to be called *after* generate_adjacency...
+    if (decomposition.m_omittedBlocks.empty() && decomposition.m_omittedBlockNames.empty()) {
+      return;
+    }
+
+    size_t           block_count = el_blocks.size();
+    std::vector<INT> ids(block_count);
+    ex_get_ids(filePtr, EX_ELEM_BLOCK, Data(ids));
+
+    if (!decomposition.m_omittedBlockNames.empty()) {
+      // Need to determine the id of each block name in the list...
+      // Probably easiest to go through each id and get its name and
+      // see if it exists in `m_omittedBlockNames`
+      int max_name_length = ex_inquire_int(filePtr, EX_INQ_DB_MAX_USED_NAME_LENGTH);
+      max_name_length     = std::max(max_name_length, 32);
+      size_t num_found    = 0;
+      for (INT id : ids) {
+        std::vector<char> buffer(max_name_length + 1);
+        buffer[0] = '\0';
+        ex_get_name(filePtr, EX_ELEM_BLOCK, id, Data(buffer));
+        if (buffer[0] != '\0') {
+          std::string name(Data(buffer));
+          bool        found = std::find(decomposition.m_omittedBlockNames.begin(),
+                                        decomposition.m_omittedBlockNames.end(),
+                                        name) != decomposition.m_omittedBlockNames.end();
+          if (found) {
+#if IOSS_DEBUG_OUTPUT
+            if (m_processor == 0) {
+              fmt::print(stderr, "Found name {} with id {}\n", name, id);
+            }
+#endif
+            decomposition.m_omittedBlocks.push_back(id);
+            num_found++;
+            if (num_found == decomposition.m_omittedBlockNames.size()) {
+              break;
+            }
+          }
+        }
+      }
+    }
+
+    m_decomposition.show_progress(__func__);
+    if (decomposition.m_fileBlockIndex.size() != block_count + 1) {
+      std::ostringstream errmsg;
+      fmt::print(errmsg, "ERROR: The `generate_adjacency` function was not called prior to calling "
+                         "`generate_omitted_block_weights`\n"
+                         "       Contact gdsjaar@sandia.gov for more details.\n");
+      IOSS_ERROR(errmsg);
+    }
+
+    // Get the global element block index list at this time also.
+    // The global element at index 'I' (0-based) is on block B
+    // if global_block_index[B] <= I && global_block_index[B+1] < I
+    std::vector<ex_block> ebs(block_count);
+    for (size_t b = 0; b < block_count; b++) {
+      el_blocks[b].id_ = ids[b];
+      ebs[b].id        = ids[b];
+      ebs[b].type      = EX_ELEM_BLOCK;
+      ex_get_block_param(filePtr, &ebs[b]);
+    }
+
+    // Now, populate the weight vector...
+    decomposition.m_weights.reserve(decomp_elem_count());
+
+    // Range of elements currently handled by this processor [)
+    size_t p_start = decomp_elem_offset();
+    size_t p_end   = p_start + decomp_elem_count();
+
+    size_t b_start = 0;
+    for (const auto &block : ebs) {
+      // Range of elements in element block b is [b_start,b_end)
+      size_t b_end = b_start + block.num_entry;
+
+      if (b_start < p_end && p_start < b_end) {
+        // Some of this blocks elements are on this processor...
+        size_t  overlap = std::min(b_end, p_end) - std::max(b_start, p_start);
+        int64_t id      = block.id;
+
+        bool omitted =
+            std::find(decomposition.m_omittedBlocks.begin(), decomposition.m_omittedBlocks.end(),
+                      id) != decomposition.m_omittedBlocks.end();
+        float weight = omitted ? 0.0f : 1.0f;
+        for (size_t elem = 0; elem < overlap; elem++) {
+          decomposition.m_weights.push_back(weight);
+        }
+      }
+      b_start = b_end;
+    }
+  }
+
   template <typename INT>
   void
   DecompositionData<INT>::get_common_set_data(int filePtr, ex_entity_type set_type,
@@ -1941,7 +2037,7 @@ namespace Ioex {
     // map for all locally-owned nodes and also determine how many
     // of my nodes are owned by which other processors.
 
-    global_implicit_map.resize(owning_proc.size());
+    global_implicit_map.resize(owning_proc.size(), -1);
 
     std::vector<int64_t> snd_count(m_processorCount);
     std::vector<int64_t> rcv_count(m_processorCount);
@@ -1970,7 +2066,9 @@ namespace Ioex {
     }
 
     for (auto &i : global_implicit_map) {
-      i += *processor_offset + 1;
+      if (i >= 0) {
+        i += *processor_offset + 1;
+      }
     }
 
     // Now, tell the other processors how many nodes I will be sending
@@ -2002,12 +2100,31 @@ namespace Ioex {
     m_decomposition.show_progress("\tCommunication 2 finished");
 
     // Iterate rcv_list and convert global ids to the global-implicit position...
+    int error_count = 0;
     for (auto &i : rcv_list) {
-      int64_t local_id     = node_map.global_to_local(i) - 1;
-      int64_t rcv_position = global_implicit_map[local_id];
-      i                    = rcv_position;
+      int64_t local_id = node_map.global_to_local(i, false, true) - 1;
+      if (local_id < 0) {
+        error_count++;
+      }
+      else {
+        SMART_ASSERT(local_id >= 0)(local_id)(i);
+        int64_t rcv_position = global_implicit_map[local_id];
+        SMART_ASSERT(rcv_position >= 0)(rcv_position)(local_id)(i);
+        i = rcv_position;
+      }
+    }
+    {
+      Ioss::ParallelUtils pu(comm_);
+      int                 total_errors = pu.global_minmax(error_count, Ioss::ParallelUtils::DO_MAX);
+      if (total_errors > 0) {
+        std::ostringstream errmsg;
+        fmt::print(errmsg,
+                   "ERROR: Ioss Mapping routines detected at least one error mapping global ids.\n"
+                   "       This usually means the node ownership is incorrect for some reason. "
+                   "This should not happen, please report.\n");
+        IOSS_ERROR(errmsg);
+      }
     }
-
     // Send the data back now...
     Ioss::MY_Alltoallv(rcv_list, rcv_count, rcv_offset, snd_list, snd_count, snd_offset, comm_);
     m_decomposition.show_progress("\tCommunication 3 finished");
diff --git a/ThirdParty/ioss/vtkioss/exodus/Ioex_DecompositionData.h b/ThirdParty/ioss/vtkioss/exodus/Ioex_DecompositionData.h
index 46a5777132227195e8d208e9b3a6b7f6650995d3..ccbc1c900a53b9eed88868179cea58776b45f033 100644
--- a/ThirdParty/ioss/vtkioss/exodus/Ioex_DecompositionData.h
+++ b/ThirdParty/ioss/vtkioss/exodus/Ioex_DecompositionData.h
@@ -1,5 +1,5 @@
 /*
- * Copyright(C) 1999-2024 National Technology & Engineering Solutions
+ * Copyright(C) 1999-2025 National Technology & Engineering Solutions
  * of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
  * NTESS, the U.S. Government retains certain rights in this software.
  *
@@ -69,6 +69,8 @@ namespace Ioex {
     IOSS_NODISCARD virtual std::vector<double> &centroids() = 0;
     IOSS_NODISCARD virtual std::vector<float>  &weights()   = 0;
 
+    virtual void set_block_omissions(const Ioss::NameList &omissions) = 0;
+
     Ioss_MPI_Comm comm_;
 
     int m_processor{0};
@@ -140,6 +142,11 @@ namespace Ioex {
     IOSS_NODISCARD std::vector<double> &centroids() { return m_decomposition.m_centroids; }
     IOSS_NODISCARD std::vector<float> &weights() { return m_decomposition.m_weights; }
 
+    void set_block_omissions(const Ioss::NameList &omissions)
+    {
+      m_decomposition.set_block_omissions(omissions);
+    }
+
     template <typename T>
     void communicate_element_data(T *file_data, T *ioss_data, size_t comp_count) const
     {
@@ -269,6 +276,7 @@ namespace Ioex {
     }
 
     void generate_adjacency_list(int filePtr, Ioss::Decomposition<INT> &decomposition);
+    void generate_omitted_block_weights(int filePtr, Ioss::Decomposition<INT> &decomposition);
 
     void get_common_set_data(int filePtr, ex_entity_type set_type,
                              std::vector<Ioss::SetDecompositionData> &sets,
diff --git a/ThirdParty/ioss/vtkioss/exodus/Ioex_Internals.C b/ThirdParty/ioss/vtkioss/exodus/Ioex_Internals.C
index 9cc834f617942ccc574f0112721eba7061fa2a1f..1fc2bc6b872f6bfe5caa03f8b75cedd0d2f82242 100644
--- a/ThirdParty/ioss/vtkioss/exodus/Ioex_Internals.C
+++ b/ThirdParty/ioss/vtkioss/exodus/Ioex_Internals.C
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -20,7 +20,7 @@ extern "C" {
 #include <array>
 #include <cstdlib>  // for exit, EXIT_FAILURE
 #include <cstring>  // for strlen
-#include <vtk_netcdf.h> // for NC_NOERR, nc_def_var, etc
+#include <vtk_netcdf.h> // for EX_NOERR, nc_def_var, etc
 #include <string>   // for string, operator==, etc
 #include <vector>   // for vector
 
@@ -78,7 +78,7 @@ Redefine::Redefine(int exoid) : exodusFilePtr(exoid)
 {
   // Enter define mode...
   int status = nc_redef(exodusFilePtr);
-  if (status != NC_NOERR) {
+  if (status != EX_NOERR) {
     ex_opts(EX_VERBOSE);
     std::string errmsg =
         fmt::format("Error: failed to put file id {} into define mode", exodusFilePtr);
@@ -91,7 +91,7 @@ Redefine::~Redefine()
 {
   try {
     int status = nc_enddef(exodusFilePtr);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg = fmt::format(
           "Error: failed to complete variable definitions in file id {}", exodusFilePtr);
@@ -393,7 +393,7 @@ int Internals::initialize_state_file(Mesh &mesh, const ex_var_params &var_params
     status = nc_put_att_text(exodusFilePtr, NC_GLOBAL, "base_database",
                              static_cast<int>(base_filename.length()) + 1, base_filename.c_str());
 
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg = fmt::format(
           "Error: failed to define 'base_database' attribute to file id {}", exodusFilePtr);
@@ -403,7 +403,7 @@ int Internals::initialize_state_file(Mesh &mesh, const ex_var_params &var_params
 
     // Time Dimension...
     int timedim;
-    if ((status = nc_def_dim(exodusFilePtr, DIM_TIME, NC_UNLIMITED, &timedim)) != NC_NOERR) {
+    if ((status = nc_def_dim(exodusFilePtr, DIM_TIME, NC_UNLIMITED, &timedim)) != EX_NOERR) {
       std::string errmsg =
           fmt::format("Error: failed to define time dimension in file id {}", exodusFilePtr);
       ex_err_fn(exodusFilePtr, __func__, errmsg.c_str(), status);
@@ -413,7 +413,7 @@ int Internals::initialize_state_file(Mesh &mesh, const ex_var_params &var_params
     // Name String Length...
     int namestrdim;
     status = nc_def_dim(exodusFilePtr, DIM_STR_NAME, maximumNameLength + 1, &namestrdim);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg =
           fmt::format("Error: failed to define 'name string length' in file id {}", exodusFilePtr);
@@ -425,7 +425,7 @@ int Internals::initialize_state_file(Mesh &mesh, const ex_var_params &var_params
     if (var_params.num_node > 0) {
       int numnoddim;
       status = nc_def_dim(exodusFilePtr, DIM_NUM_NODES, mesh.nodeblocks[0].entityCount, &numnoddim);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg =
             fmt::format("Error: failed to define number of nodes in file id {}", exodusFilePtr);
@@ -444,7 +444,7 @@ int Internals::initialize_state_file(Mesh &mesh, const ex_var_params &var_params
     if (elem_count > 0 && var_params.num_elem > 0) {
       int numelemdim;
       status = nc_def_dim(exodusFilePtr, DIM_NUM_ELEM, elem_count, &numelemdim);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg =
             fmt::format("Error: failed to define number of elements in file id {}", exodusFilePtr);
@@ -465,7 +465,7 @@ int Internals::initialize_state_file(Mesh &mesh, const ex_var_params &var_params
     if (face_count > 0 && var_params.num_face > 0) {
       int numfacedim;
       status = nc_def_dim(exodusFilePtr, DIM_NUM_FACE, face_count, &numfacedim);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg =
             fmt::format("Error: failed to define number of faces in file id {}", exodusFilePtr);
@@ -486,7 +486,7 @@ int Internals::initialize_state_file(Mesh &mesh, const ex_var_params &var_params
     if (edge_count > 0 && var_params.num_edge > 0) {
       int numedgedim;
       status = nc_def_dim(exodusFilePtr, DIM_NUM_EDGE, edge_count, &numedgedim);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg =
             fmt::format("Error: failed to define number of edges in file id {}", exodusFilePtr);
@@ -589,7 +589,7 @@ int Internals::initialize_state_file(Mesh &mesh, const ex_var_params &var_params
     int        varid;
     std::array dim{timedim};
     if ((status = nc_def_var(exodusFilePtr, VAR_WHOLE_TIME, nc_flt_code(exodusFilePtr), 1,
-                             Data(dim), &varid)) != NC_NOERR) {
+                             Data(dim), &varid)) != EX_NOERR) {
       std::string errmsg = fmt::format(
           "Error: failed to define whole time step variable in file id {}", exodusFilePtr);
       ex_err_fn(exodusFilePtr, __func__, errmsg.c_str(), status);
@@ -1060,7 +1060,7 @@ int Internals::put_metadata(const Mesh &mesh, const CommunicationMetaData &comm)
 
   int rootid = static_cast<unsigned>(exodusFilePtr) & EX_FILE_ID_MASK;
 
-  if (rootid == exodusFilePtr && nc_inq_dimid(exodusFilePtr, DIM_NUM_DIM, &numdimdim) == NC_NOERR) {
+  if (rootid == exodusFilePtr && nc_inq_dimid(exodusFilePtr, DIM_NUM_DIM, &numdimdim) == EX_NOERR) {
     std::string errmsg =
         fmt::format("Error: initialization already done for file id {}", exodusFilePtr);
     ex_err_fn(exodusFilePtr, __func__, errmsg.c_str(), EX_MSG);
@@ -1074,7 +1074,7 @@ int Internals::put_metadata(const Mesh &mesh, const CommunicationMetaData &comm)
                                  static_cast<int>(std::strlen(mesh.title)) + 1, mesh.title);
 
     // define some attributes...
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg =
           fmt::format("Error: failed to define title attribute to file id {}", exodusFilePtr);
@@ -1087,7 +1087,7 @@ int Internals::put_metadata(const Mesh &mesh, const CommunicationMetaData &comm)
     if (comm.outputNemesis && comm.processorCount > 1) {
       std::array ltempsv{comm.processorCount, comm.processorId};
       status = nc_put_att_int(rootid, NC_GLOBAL, "processor_info", NC_INT, 2, Data(ltempsv));
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg = fmt::format(
             "Error: failed to define processor info attribute to file id {}", exodusFilePtr);
@@ -1101,7 +1101,7 @@ int Internals::put_metadata(const Mesh &mesh, const CommunicationMetaData &comm)
     {
       double fake_time = -1.0e38;
       status = nc_put_att_double(rootid, NC_GLOBAL, "last_written_time", NC_DOUBLE, 1, &fake_time);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg = fmt::format(
             "Error: failed to define 'last_written_time' attribute to file id {}", exodusFilePtr);
@@ -1116,7 +1116,7 @@ int Internals::put_metadata(const Mesh &mesh, const CommunicationMetaData &comm)
     {
       int current_len = 0;
       status = nc_put_att_int(rootid, NC_GLOBAL, ATT_MAX_NAME_LENGTH, NC_INT, 1, &current_len);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg = fmt::format(
             "Error: failed to define ATT_MAX_NAME_LENGTH attribute to file id {}", exodusFilePtr);
@@ -1130,9 +1130,9 @@ int Internals::put_metadata(const Mesh &mesh, const CommunicationMetaData &comm)
   if (maximumNameLength < 32) {
     maximumNameLength = 32;
   }
-  if (nc_inq_dimid(rootid, DIM_STR_NAME, &namestrdim) != NC_NOERR) {
+  if (nc_inq_dimid(rootid, DIM_STR_NAME, &namestrdim) != EX_NOERR) {
     int status = nc_def_dim(rootid, DIM_STR_NAME, maximumNameLength + 1, &namestrdim);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg =
           fmt::format("Error: failed to define name string length in file id {}", exodusFilePtr);
@@ -1142,7 +1142,7 @@ int Internals::put_metadata(const Mesh &mesh, const CommunicationMetaData &comm)
   }
 
   int status = nc_def_dim(exodusFilePtr, DIM_NUM_DIM, mesh.dimensionality, &numdimdim);
-  if (status != NC_NOERR) {
+  if (status != EX_NOERR) {
     ex_opts(EX_VERBOSE);
     std::string errmsg =
         fmt::format("Error: failed to define number of dimensions in file id {}", exodusFilePtr);
@@ -1150,7 +1150,7 @@ int Internals::put_metadata(const Mesh &mesh, const CommunicationMetaData &comm)
     return EX_FATAL;
   }
 
-  if ((status = nc_def_dim(exodusFilePtr, DIM_TIME, NC_UNLIMITED, &timedim)) != NC_NOERR) {
+  if ((status = nc_def_dim(exodusFilePtr, DIM_TIME, NC_UNLIMITED, &timedim)) != EX_NOERR) {
     std::string errmsg =
         fmt::format("Error: failed to define time dimension in file id {}", exodusFilePtr);
     ex_err_fn(exodusFilePtr, __func__, errmsg.c_str(), status);
@@ -1159,7 +1159,7 @@ int Internals::put_metadata(const Mesh &mesh, const CommunicationMetaData &comm)
 
   std::array dim{timedim};
   if ((status = nc_def_var(exodusFilePtr, VAR_WHOLE_TIME, nc_flt_code(exodusFilePtr), 1, Data(dim),
-                           &varid)) != NC_NOERR) {
+                           &varid)) != EX_NOERR) {
     std::string errmsg = fmt::format(
         "Error: failed to define whole time step variable in file id {}", exodusFilePtr);
     ex_err_fn(exodusFilePtr, __func__, errmsg.c_str(), status);
@@ -1175,7 +1175,7 @@ int Internals::put_metadata(const Mesh &mesh, const CommunicationMetaData &comm)
 
   if (!mesh.nodeblocks.empty() && mesh.nodeblocks[0].entityCount > 0) {
     status = nc_def_dim(exodusFilePtr, DIM_NUM_NODES, mesh.nodeblocks[0].entityCount, &numnoddim);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg =
           fmt::format("Error: failed to define number of nodes in file id {}", exodusFilePtr);
@@ -1187,7 +1187,7 @@ int Internals::put_metadata(const Mesh &mesh, const CommunicationMetaData &comm)
     if (mesh.use_node_map) {
       std::array dims1{numnoddim};
       status = nc_def_var(exodusFilePtr, VAR_NODE_NUM_MAP, map_type, 1, Data(dims1), &varid);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         if (status == NC_ENAMEINUSE) {
           std::string errmsg =
@@ -1209,7 +1209,7 @@ int Internals::put_metadata(const Mesh &mesh, const CommunicationMetaData &comm)
     int numattrdim;
     status = nc_def_dim(exodusFilePtr, DIM_NUM_ATT_IN_NBLK, mesh.nodeblocks[0].attributeCount,
                         &numattrdim);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg =
           fmt::format("Error: failed to define number of attributes in node block {}"
@@ -1222,7 +1222,7 @@ int Internals::put_metadata(const Mesh &mesh, const CommunicationMetaData &comm)
     std::array dims{numnoddim, numattrdim};
     status =
         nc_def_var(exodusFilePtr, VAR_NATTRIB, nc_flt_code(exodusFilePtr), 2, Data(dims), &varid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg =
           fmt::format("Error:  failed to define attributes for node block {} in file id {}",
@@ -1237,7 +1237,7 @@ int Internals::put_metadata(const Mesh &mesh, const CommunicationMetaData &comm)
     dims[1] = namestrdim;
 
     status = nc_def_var(exodusFilePtr, VAR_NAME_NATTRIB, NC_CHAR, 2, Data(dims), &varid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg =
           fmt::format("Error: failed to define attribute name array for node block {}"
@@ -1257,7 +1257,7 @@ int Internals::put_metadata(const Mesh &mesh, const CommunicationMetaData &comm)
   if (elem_count > 0) {
     int numelemdim;
     status = nc_def_dim(exodusFilePtr, DIM_NUM_ELEM, elem_count, &numelemdim);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg =
           fmt::format("Error: failed to define number of elements in file id {}", exodusFilePtr);
@@ -1270,7 +1270,7 @@ int Internals::put_metadata(const Mesh &mesh, const CommunicationMetaData &comm)
       std::array dims{numelemdim};
       varid  = 0;
       status = nc_def_var(exodusFilePtr, VAR_ELEM_NUM_MAP, map_type, 1, Data(dims), &varid);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         if (status == NC_ENAMEINUSE) {
           std::string errmsg = fmt::format(
@@ -1296,7 +1296,7 @@ int Internals::put_metadata(const Mesh &mesh, const CommunicationMetaData &comm)
   if (face_count > 0) {
     int numfacedim;
     status = nc_def_dim(exodusFilePtr, DIM_NUM_FACE, face_count, &numfacedim);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg =
           fmt::format("Error: failed to define number of faces in file id {}", exodusFilePtr);
@@ -1309,7 +1309,7 @@ int Internals::put_metadata(const Mesh &mesh, const CommunicationMetaData &comm)
       std::array dims{numfacedim};
       varid  = 0;
       status = nc_def_var(exodusFilePtr, VAR_FACE_NUM_MAP, map_type, 1, Data(dims), &varid);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         if (status == NC_ENAMEINUSE) {
           std::string errmsg =
@@ -1335,7 +1335,7 @@ int Internals::put_metadata(const Mesh &mesh, const CommunicationMetaData &comm)
   if (edge_count > 0) {
     int numedgedim;
     status = nc_def_dim(exodusFilePtr, DIM_NUM_EDGE, edge_count, &numedgedim);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg =
           fmt::format("Error: failed to define number of edges in file id {}", exodusFilePtr);
@@ -1348,7 +1348,7 @@ int Internals::put_metadata(const Mesh &mesh, const CommunicationMetaData &comm)
       std::array dims{numedgedim};
       varid  = 0;
       status = nc_def_var(exodusFilePtr, VAR_EDGE_NUM_MAP, map_type, 1, Data(dims), &varid);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         if (status == NC_ENAMEINUSE) {
           std::string errmsg =
@@ -1425,10 +1425,10 @@ int Internals::put_metadata(const Mesh &mesh, const CommunicationMetaData &comm)
     if (comm.processorCount > 0) {
       int procdim;
       status = nc_inq_dimid(exodusFilePtr, DIM_NUM_PROCS, &procdim);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         int ltempsv = comm.processorCount;
         status      = nc_def_dim(exodusFilePtr, DIM_NUM_PROCS, ltempsv, &procdim);
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg = fmt::format("Error: failed to dimension \"{}\" in file ID {}",
                                            DIM_NUM_PROCS, exodusFilePtr);
@@ -1441,10 +1441,10 @@ int Internals::put_metadata(const Mesh &mesh, const CommunicationMetaData &comm)
     // If this is a parallel file then the status vectors are size 1
     int dimid_npf;
     status = nc_inq_dimid(exodusFilePtr, DIM_NUM_PROCS_F, &dimid_npf);
-    if ((status) != NC_NOERR) {
+    if ((status) != EX_NOERR) {
       int ltempsv = 1; // 1 processor per file...
       status      = nc_def_dim(exodusFilePtr, DIM_NUM_PROCS_F, ltempsv, &dimid_npf);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg = fmt::format("Error: failed to dimension \"{}\" in file ID {}",
                                          DIM_NUM_PROCS_F, exodusFilePtr);
@@ -1455,9 +1455,9 @@ int Internals::put_metadata(const Mesh &mesh, const CommunicationMetaData &comm)
 
     // Define the file type variable...
     status = nc_inq_varid(exodusFilePtr, VAR_FILE_TYPE, &varid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       status = nc_def_var(exodusFilePtr, VAR_FILE_TYPE, NC_INT, 0, nullptr, &varid);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg =
             fmt::format("Error: failed to define file type in file ID {}", exodusFilePtr);
@@ -1478,7 +1478,7 @@ int Internals::put_metadata(const Mesh &mesh, const CommunicationMetaData &comm)
       size_t ltempsv   = comm.globalNodes;
       int    glonoddim = 0;
       status           = nc_def_dim(exodusFilePtr, DIM_NUM_NODES_GLOBAL, ltempsv, &glonoddim);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg = fmt::format("Error: failed to dimension \"{}\" in file ID {}",
                                          DIM_NUM_NODES_GLOBAL, exodusFilePtr);
@@ -1492,7 +1492,7 @@ int Internals::put_metadata(const Mesh &mesh, const CommunicationMetaData &comm)
       size_t ltempsv    = comm.globalElements;
       int    gloelemdim = 0;
       status            = nc_def_dim(exodusFilePtr, DIM_NUM_ELEMS_GLOBAL, ltempsv, &gloelemdim);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg = fmt::format("Error: failed to dimension \"{}\" in file ID {}",
                                          DIM_NUM_ELEMS_GLOBAL, exodusFilePtr);
@@ -1702,7 +1702,7 @@ int Internals::put_metadata(const std::vector<Assembly> &assemblies)
     /* define dimensions and variables */
     int dimid;
     status = nc_def_dim(exodusFilePtr, numentryptr, assembly.entityCount, &dimid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg = fmt::format(
           "Error: failed to define number of entities in assembly in file id {}", exodusFilePtr);
@@ -1714,7 +1714,7 @@ int Internals::put_metadata(const std::vector<Assembly> &assemblies)
     int        entlst_id;
     std::array dims{dimid};
     if ((status = nc_def_var(exodusFilePtr, VAR_ENTITY_ASSEMBLY(assembly.id), int_type, 1,
-                             Data(dims), &entlst_id)) != NC_NOERR) {
+                             Data(dims), &entlst_id)) != EX_NOERR) {
       std::string errmsg = fmt::format(
           "Error: failed to define entity assembly variable in file id {}", exodusFilePtr);
       ex_err_fn(exodusFilePtr, __func__, errmsg.c_str(), status);
@@ -1730,7 +1730,7 @@ int Internals::put_metadata(const std::vector<Assembly> &assemblies)
       int id = assembly.id;
       status = nc_put_att_int(exodusFilePtr, entlst_id, EX_ATTRIBUTE_ID, NC_INT, 1, &id);
     }
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg = fmt::format("Error: failed to define '{}' attribute to file id {}",
                                        EX_ATTRIBUTE_ID, exodusFilePtr);
@@ -1740,7 +1740,7 @@ int Internals::put_metadata(const std::vector<Assembly> &assemblies)
 
     int type = assembly.type;
     status   = nc_put_att_int(exodusFilePtr, entlst_id, EX_ATTRIBUTE_TYPE, NC_INT, 1, &type);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg = fmt::format("Error: failed to define '{}' attribute to file id {}",
                                        EX_ATTRIBUTE_TYPE, exodusFilePtr);
@@ -1750,7 +1750,7 @@ int Internals::put_metadata(const std::vector<Assembly> &assemblies)
 
     status = nc_put_att_text(exodusFilePtr, entlst_id, EX_ATTRIBUTE_NAME, assembly.name.size() + 1,
                              assembly.name.c_str());
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg = fmt::format("Error: failed to define '{}' attribute to file id {}",
                                        EX_ATTRIBUTE_NAME, exodusFilePtr);
@@ -1762,7 +1762,7 @@ int Internals::put_metadata(const std::vector<Assembly> &assemblies)
       char *contains = ex_name_of_object(assembly.type);
       status         = nc_put_att_text(exodusFilePtr, entlst_id, EX_ATTRIBUTE_TYPENAME,
                                        strlen(contains) + 1, contains);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg = fmt::format("Error: failed to define '{}' attribute to file id {}",
                                          EX_ATTRIBUTE_TYPENAME, exodusFilePtr);
@@ -1789,7 +1789,7 @@ int Internals::put_metadata(const std::vector<Blob> &blobs)
   int status;
 
   int n1dim;
-  if ((status = nc_def_dim(exodusFilePtr, DIM_N1, 1L, &n1dim)) != NC_NOERR) {
+  if ((status = nc_def_dim(exodusFilePtr, DIM_N1, 1L, &n1dim)) != EX_NOERR) {
     ex_opts(EX_VERBOSE);
     std::string errmsg =
         fmt::format("Error: failed to define number \"1\" dimension in file id {}", exodusFilePtr);
@@ -1802,7 +1802,7 @@ int Internals::put_metadata(const std::vector<Blob> &blobs)
 
     // define dimensions and variables
     int dimid;
-    if ((status = nc_def_dim(exodusFilePtr, numentryptr, blob.entityCount, &dimid)) != NC_NOERR) {
+    if ((status = nc_def_dim(exodusFilePtr, numentryptr, blob.entityCount, &dimid)) != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg =
           fmt::format("Error: failed to define number of entries in blob {} in file id {}", blob.id,
@@ -1816,7 +1816,7 @@ int Internals::put_metadata(const std::vector<Blob> &blobs)
     std::array dims{n1dim};
     int        entlst;
     if ((status = nc_def_var(exodusFilePtr, VAR_ENTITY_BLOB(blob.id), NC_INT, 1, Data(dims),
-                             &entlst)) != NC_NOERR) {
+                             &entlst)) != EX_NOERR) {
       std::string errmsg = fmt::format("Error: failed to create entity for blob {} in file id {}",
                                        blob.id, exodusFilePtr);
       ex_err_fn(exodusFilePtr, __func__, errmsg.c_str(), status);
@@ -1832,7 +1832,7 @@ int Internals::put_metadata(const std::vector<Blob> &blobs)
       int id = blob.id;
       status = nc_put_att_int(exodusFilePtr, entlst, EX_ATTRIBUTE_ID, NC_INT, 1, &id);
     }
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       std::string errmsg =
           fmt::format("Error: failed to store blob id {} in file id {}", blob.id, exodusFilePtr);
       ex_err_fn(exodusFilePtr, __func__, errmsg.c_str(), status);
@@ -1840,7 +1840,7 @@ int Internals::put_metadata(const std::vector<Blob> &blobs)
     }
 
     if ((status = nc_put_att_text(exodusFilePtr, entlst, EX_ATTRIBUTE_NAME, blob.name.length() + 1,
-                                  blob.name.c_str())) != NC_NOERR) {
+                                  blob.name.c_str())) != EX_NOERR) {
       std::string errmsg = fmt::format("Error: failed to store blob name {} in file id {}",
                                        blob.name, exodusFilePtr);
       ex_err_fn(exodusFilePtr, __func__, errmsg.c_str(), status);
@@ -1864,7 +1864,7 @@ int Internals::put_metadata(const std::vector<ElemBlock> &blocks, bool count_onl
   int    dimid;
   size_t num_elem_blk = 0;
   status              = nc_inq_dimid(exodusFilePtr, DIM_NUM_EL_BLK, &dimid);
-  if (status != NC_NOERR) {
+  if (status != EX_NOERR) {
     ex_opts(EX_VERBOSE);
     std::string errmsg =
         fmt::format("Error: no element blocks defined in file id {}", exodusFilePtr);
@@ -1874,7 +1874,7 @@ int Internals::put_metadata(const std::vector<ElemBlock> &blocks, bool count_onl
 
   int namestrdim;
   status = nc_inq_dimid(exodusFilePtr, DIM_STR_NAME, &namestrdim);
-  if (status != NC_NOERR) {
+  if (status != EX_NOERR) {
     ex_opts(EX_VERBOSE);
     std::string errmsg =
         fmt::format("Error: failed to get string length in file id {}", exodusFilePtr);
@@ -1883,7 +1883,7 @@ int Internals::put_metadata(const std::vector<ElemBlock> &blocks, bool count_onl
   }
 
   status = nc_inq_dimlen(exodusFilePtr, dimid, &num_elem_blk);
-  if (status != NC_NOERR) {
+  if (status != EX_NOERR) {
     ex_opts(EX_VERBOSE);
     std::string errmsg =
         fmt::format("Error: failed to get number of element blocks in file id {}", exodusFilePtr);
@@ -1905,7 +1905,7 @@ int Internals::put_metadata(const std::vector<ElemBlock> &blocks, bool count_onl
     int numelbdim;
     status = nc_def_dim(exodusFilePtr, DIM_NUM_EL_IN_BLK(iblk + 1), blocks[iblk].entityCount,
                         &numelbdim);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       if (status == NC_ENAMEINUSE) { // duplicate entry
         ex_opts(EX_VERBOSE);
         std::string errmsg = fmt::format("Error: element block {} already defined in file id {}",
@@ -1929,7 +1929,7 @@ int Internals::put_metadata(const std::vector<ElemBlock> &blocks, bool count_onl
     int nelnoddim;
     status = nc_def_dim(exodusFilePtr, DIM_NUM_NOD_PER_EL(iblk + 1), blocks[iblk].nodesPerEntity,
                         &nelnoddim);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg =
           fmt::format("Error: failed to define number of nodes/element for block {}"
@@ -1944,7 +1944,7 @@ int Internals::put_metadata(const std::vector<ElemBlock> &blocks, bool count_onl
       std::array dims{numelbdim, nelnoddim};
       int        connid = 0;
       status = nc_def_var(exodusFilePtr, VAR_CONN(iblk + 1), bulk_type, 2, Data(dims), &connid);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg = fmt::format("Error: failed to create connectivity array for block {}"
                                          " in file id {}",
@@ -1958,7 +1958,7 @@ int Internals::put_metadata(const std::vector<ElemBlock> &blocks, bool count_onl
       status = nc_put_att_text(exodusFilePtr, connid, ATT_NAME_ELB,
                                static_cast<int>(std::strlen(blocks[iblk].elType)) + 1,
                                blocks[iblk].elType);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg =
             fmt::format("Error: failed to store element type name {} in file id {}",
@@ -1972,7 +1972,7 @@ int Internals::put_metadata(const std::vector<ElemBlock> &blocks, bool count_onl
       int neledgdim;
       status = nc_def_dim(exodusFilePtr, DIM_NUM_EDG_PER_EL(iblk + 1), blocks[iblk].edgesPerEntity,
                           &neledgdim);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg =
             fmt::format("Error: failed to define number of edges/element for block {}"
@@ -1987,7 +1987,7 @@ int Internals::put_metadata(const std::vector<ElemBlock> &blocks, bool count_onl
 
       int connid = 0;
       status = nc_def_var(exodusFilePtr, VAR_ECONN(iblk + 1), bulk_type, 2, Data(dims), &connid);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg =
             fmt::format("Error: failed to create element->edge connectivity array for block {}"
@@ -2003,7 +2003,7 @@ int Internals::put_metadata(const std::vector<ElemBlock> &blocks, bool count_onl
       int nelfacdim;
       status = nc_def_dim(exodusFilePtr, DIM_NUM_FAC_PER_EL(iblk + 1), blocks[iblk].facesPerEntity,
                           &nelfacdim);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg =
             fmt::format("Error: failed to define number of faces/element for block {}"
@@ -2018,7 +2018,7 @@ int Internals::put_metadata(const std::vector<ElemBlock> &blocks, bool count_onl
 
       int connid = 0;
       status = nc_def_var(exodusFilePtr, VAR_FCONN(iblk + 1), bulk_type, 2, Data(dims), &connid);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg =
             fmt::format("Error: failed to create element->edge connectivity array for block {}"
@@ -2035,7 +2035,7 @@ int Internals::put_metadata(const std::vector<ElemBlock> &blocks, bool count_onl
       int numattrdim;
       status = nc_def_dim(exodusFilePtr, DIM_NUM_ATT_IN_BLK(iblk + 1), blocks[iblk].attributeCount,
                           &numattrdim);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg = fmt::format("Error: failed to define number of attributes in block {}"
                                          " in file id {}",
@@ -2049,7 +2049,7 @@ int Internals::put_metadata(const std::vector<ElemBlock> &blocks, bool count_onl
         int        varid = 0;
         status = nc_def_var(exodusFilePtr, VAR_ATTRIB(iblk + 1), nc_flt_code(exodusFilePtr), 2,
                             Data(dims), &varid);
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg =
               fmt::format("Error:  failed to define attributes for element block {}"
@@ -2080,7 +2080,7 @@ int Internals::put_metadata(const std::vector<ElemBlock> &blocks, bool count_onl
         int        varid = 0;
         status =
             nc_def_var(exodusFilePtr, VAR_NAME_ATTRIB(iblk + 1), NC_CHAR, 2, Data(dims), &varid);
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg =
               fmt::format("Error: failed to define attribute name array for element block {}"
@@ -2110,7 +2110,7 @@ int Internals::put_metadata(const std::vector<FaceBlock> &blocks, bool count_onl
   int    dimid;
   size_t num_face_blk = 0;
   status              = nc_inq_dimid(exodusFilePtr, DIM_NUM_FA_BLK, &dimid);
-  if (status != NC_NOERR) {
+  if (status != EX_NOERR) {
     ex_opts(EX_VERBOSE);
     std::string errmsg = fmt::format("Error: no face blocks defined in file id {}", exodusFilePtr);
     ex_err_fn(exodusFilePtr, __func__, errmsg.c_str(), status);
@@ -2119,7 +2119,7 @@ int Internals::put_metadata(const std::vector<FaceBlock> &blocks, bool count_onl
 
   int namestrdim;
   status = nc_inq_dimid(exodusFilePtr, DIM_STR_NAME, &namestrdim);
-  if (status != NC_NOERR) {
+  if (status != EX_NOERR) {
     ex_opts(EX_VERBOSE);
     std::string errmsg =
         fmt::format("Error: failed to get string length in file id {}", exodusFilePtr);
@@ -2128,7 +2128,7 @@ int Internals::put_metadata(const std::vector<FaceBlock> &blocks, bool count_onl
   }
 
   status = nc_inq_dimlen(exodusFilePtr, dimid, &num_face_blk);
-  if (status != NC_NOERR) {
+  if (status != EX_NOERR) {
     ex_opts(EX_VERBOSE);
     std::string errmsg =
         fmt::format("Error: failed to get number of face blocks in file id {}", exodusFilePtr);
@@ -2150,7 +2150,7 @@ int Internals::put_metadata(const std::vector<FaceBlock> &blocks, bool count_onl
     int numelbdim;
     status = nc_def_dim(exodusFilePtr, DIM_NUM_FA_IN_FBLK(iblk + 1), blocks[iblk].entityCount,
                         &numelbdim);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       if (status == NC_ENAMEINUSE) { // duplicate entry
         ex_opts(EX_VERBOSE);
         std::string errmsg = fmt::format("Error: face block {} already defined in file id {}",
@@ -2174,7 +2174,7 @@ int Internals::put_metadata(const std::vector<FaceBlock> &blocks, bool count_onl
     int nelnoddim;
     status = nc_def_dim(exodusFilePtr, DIM_NUM_NOD_PER_FA(iblk + 1), blocks[iblk].nodesPerEntity,
                         &nelnoddim);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg = fmt::format("Error: failed to define number of nodes/face for block {}"
                                        " in file id {}",
@@ -2188,7 +2188,7 @@ int Internals::put_metadata(const std::vector<FaceBlock> &blocks, bool count_onl
       int numattrdim;
       status = nc_def_dim(exodusFilePtr, DIM_NUM_ATT_IN_FBLK(iblk + 1), blocks[iblk].attributeCount,
                           &numattrdim);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg = fmt::format("Error: failed to define number of attributes in block {}"
                                          " in file id {}",
@@ -2202,7 +2202,7 @@ int Internals::put_metadata(const std::vector<FaceBlock> &blocks, bool count_onl
         int        varid = 0;
         status = nc_def_var(exodusFilePtr, VAR_FATTRIB(iblk + 1), nc_flt_code(exodusFilePtr), 2,
                             Data(dims), &varid);
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg =
               fmt::format("Error:  failed to define attributes for face block {} in file id {}",
@@ -2219,7 +2219,7 @@ int Internals::put_metadata(const std::vector<FaceBlock> &blocks, bool count_onl
 
         status =
             nc_def_var(exodusFilePtr, VAR_NAME_FATTRIB(iblk + 1), NC_CHAR, 2, Data(dims), &varid);
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg =
               fmt::format("Error: failed to define attribute name array for face block {}"
@@ -2237,7 +2237,7 @@ int Internals::put_metadata(const std::vector<FaceBlock> &blocks, bool count_onl
       std::array dims{numelbdim, nelnoddim};
       int        connid = 0;
       status = nc_def_var(exodusFilePtr, VAR_FBCONN(iblk + 1), bulk_type, 2, Data(dims), &connid);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg =
             fmt::format("Error: failed to create connectivity array for block {} in file id {}",
@@ -2251,7 +2251,7 @@ int Internals::put_metadata(const std::vector<FaceBlock> &blocks, bool count_onl
       status = nc_put_att_text(exodusFilePtr, connid, ATT_NAME_ELB,
                                static_cast<int>(std::strlen(blocks[iblk].elType)) + 1,
                                blocks[iblk].elType);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg =
             fmt::format("Error: failed to store element type name {} in file id {}",
@@ -2274,7 +2274,7 @@ int Internals::put_metadata(const std::vector<EdgeBlock> &blocks, bool count_onl
   int    dimid;
   size_t num_edge_blk = 0;
   int    status       = nc_inq_dimid(exodusFilePtr, DIM_NUM_ED_BLK, &dimid);
-  if (status != NC_NOERR) {
+  if (status != EX_NOERR) {
     ex_opts(EX_VERBOSE);
     std::string errmsg = fmt::format("Error: no edge blocks defined in file id {}", exodusFilePtr);
     ex_err_fn(exodusFilePtr, __func__, errmsg.c_str(), status);
@@ -2283,7 +2283,7 @@ int Internals::put_metadata(const std::vector<EdgeBlock> &blocks, bool count_onl
 
   int namestrdim;
   status = nc_inq_dimid(exodusFilePtr, DIM_STR_NAME, &namestrdim);
-  if (status != NC_NOERR) {
+  if (status != EX_NOERR) {
     ex_opts(EX_VERBOSE);
     std::string errmsg =
         fmt::format("Error: failed to get string length in file id {}", exodusFilePtr);
@@ -2292,7 +2292,7 @@ int Internals::put_metadata(const std::vector<EdgeBlock> &blocks, bool count_onl
   }
 
   status = nc_inq_dimlen(exodusFilePtr, dimid, &num_edge_blk);
-  if (status != NC_NOERR) {
+  if (status != EX_NOERR) {
     ex_opts(EX_VERBOSE);
     std::string errmsg =
         fmt::format("Error: failed to get number of edge blocks in file id {}", exodusFilePtr);
@@ -2314,7 +2314,7 @@ int Internals::put_metadata(const std::vector<EdgeBlock> &blocks, bool count_onl
     int numelbdim;
     status = nc_def_dim(exodusFilePtr, DIM_NUM_ED_IN_EBLK(iblk + 1), blocks[iblk].entityCount,
                         &numelbdim);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       if (status == NC_ENAMEINUSE) { // duplicate entry
         ex_opts(EX_VERBOSE);
         std::string errmsg = fmt::format("Error: edge block {} already defined in file id {}",
@@ -2338,7 +2338,7 @@ int Internals::put_metadata(const std::vector<EdgeBlock> &blocks, bool count_onl
     int nelnoddim;
     status = nc_def_dim(exodusFilePtr, DIM_NUM_NOD_PER_ED(iblk + 1), blocks[iblk].nodesPerEntity,
                         &nelnoddim);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg =
           fmt::format("Error: failed to define number of nodes/edge ({}) for block {}"
@@ -2353,7 +2353,7 @@ int Internals::put_metadata(const std::vector<EdgeBlock> &blocks, bool count_onl
       int numattrdim;
       status = nc_def_dim(exodusFilePtr, DIM_NUM_ATT_IN_EBLK(iblk + 1), blocks[iblk].attributeCount,
                           &numattrdim);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg = fmt::format("Error: failed to define number of attributes in block {}"
                                          " in file id {}",
@@ -2366,7 +2366,7 @@ int Internals::put_metadata(const std::vector<EdgeBlock> &blocks, bool count_onl
       int        varid = 0;
       status = nc_def_var(exodusFilePtr, VAR_EATTRIB(iblk + 1), nc_flt_code(exodusFilePtr), 2,
                           Data(dims), &varid);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg =
             fmt::format("Error:  failed to define attributes for edge block {} in file id {}",
@@ -2382,7 +2382,7 @@ int Internals::put_metadata(const std::vector<EdgeBlock> &blocks, bool count_onl
 
       status =
           nc_def_var(exodusFilePtr, VAR_NAME_EATTRIB(iblk + 1), NC_CHAR, 2, Data(dims), &varid);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg =
             fmt::format("Error: failed to define attribute name array for edge block {}"
@@ -2400,7 +2400,7 @@ int Internals::put_metadata(const std::vector<EdgeBlock> &blocks, bool count_onl
     int connid    = 0;
     int bulk_type = get_type(exodusFilePtr, EX_BULK_INT64_DB);
     status = nc_def_var(exodusFilePtr, VAR_EBCONN(iblk + 1), bulk_type, 2, Data(dims), &connid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg =
           fmt::format("Error: failed to create connectivity array for block {} in file id {}",
@@ -2414,7 +2414,7 @@ int Internals::put_metadata(const std::vector<EdgeBlock> &blocks, bool count_onl
     status = nc_put_att_text(exodusFilePtr, connid, ATT_NAME_ELB,
                              static_cast<int>(std::strlen(blocks[iblk].elType)) + 1,
                              blocks[iblk].elType);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg = fmt::format("Error: failed to store element type name {} in file id {}",
                                        blocks[iblk].elType, exodusFilePtr);
@@ -2434,7 +2434,7 @@ int Internals::put_non_define_data(const CommunicationMetaData &comm, bool full_
     // Output the file type
     int varid;
     status = nc_inq_varid(exodusFilePtr, VAR_FILE_TYPE, &varid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg =
           fmt::format("Error: failed to locate file type in file ID {}", exodusFilePtr);
@@ -2444,7 +2444,7 @@ int Internals::put_non_define_data(const CommunicationMetaData &comm, bool full_
 
     int lftype = 0; // Parallel file...
     status     = nc_put_var1_int(exodusFilePtr, varid, nullptr, &lftype);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg =
           fmt::format("Error: unable to output file type variable in file ID {}", exodusFilePtr);
@@ -2455,7 +2455,7 @@ int Internals::put_non_define_data(const CommunicationMetaData &comm, bool full_
     if (full_nemesis_data) {
       int nmstat = comm.nodesInternal == 0 ? 0 : 1;
       status     = nc_put_var_int(exodusFilePtr, nodeMapVarID[0], &nmstat);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg = fmt::format(
             "Error: failed to output status for internal node map in file ID {}", exodusFilePtr);
@@ -2465,7 +2465,7 @@ int Internals::put_non_define_data(const CommunicationMetaData &comm, bool full_
 
       nmstat = comm.nodesBorder == 0 ? 0 : 1;
       status = nc_put_var_int(exodusFilePtr, nodeMapVarID[1], &nmstat);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg = fmt::format(
             "Error: failed to output status for border node map in file ID {}", exodusFilePtr);
@@ -2475,7 +2475,7 @@ int Internals::put_non_define_data(const CommunicationMetaData &comm, bool full_
 
       nmstat = comm.nodesExternal == 0 ? 0 : 1;
       status = nc_put_var_int(exodusFilePtr, nodeMapVarID[2], &nmstat);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg = fmt::format(
             "Error: failed to output status for external node map in file ID {}", exodusFilePtr);
@@ -2485,7 +2485,7 @@ int Internals::put_non_define_data(const CommunicationMetaData &comm, bool full_
 
       nmstat = comm.elementsInternal == 0 ? 0 : 1;
       status = nc_put_var_int(exodusFilePtr, elementMapVarID[0], &nmstat);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg = fmt::format(
             "Error: failed to output status for internal elem map in file ID {}", exodusFilePtr);
@@ -2495,7 +2495,7 @@ int Internals::put_non_define_data(const CommunicationMetaData &comm, bool full_
 
       nmstat = comm.elementsBorder == 0 ? 0 : 1;
       status = nc_put_var_int(exodusFilePtr, elementMapVarID[1], &nmstat);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg = fmt::format(
             "Error: failed to output status for border elem map in file ID {}", exodusFilePtr);
@@ -2512,7 +2512,7 @@ int Internals::put_non_define_data(const CommunicationMetaData &comm, bool full_
     if (!comm.nodeMap.empty() && ncnt_cmap > 0) {
       int n_varid;
       status = nc_inq_varid(exodusFilePtr, VAR_N_COMM_STAT, &n_varid);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg =
             fmt::format("Error: failed to find variable ID for \"{}\" in file ID {}",
@@ -2527,7 +2527,7 @@ int Internals::put_non_define_data(const CommunicationMetaData &comm, bool full_
         std::array start{icm};
         int        nmstat = comm.nodeMap[icm].entityCount > 0 ? 1 : 0;
         status            = nc_put_var1_int(exodusFilePtr, n_varid, Data(start), &nmstat);
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg =
               fmt::format("Error: unable to output variable in file ID {}", exodusFilePtr);
@@ -2540,7 +2540,7 @@ int Internals::put_non_define_data(const CommunicationMetaData &comm, bool full_
 
         // fill the cmap data index
         status = nc_inq_varid(exodusFilePtr, VAR_N_COMM_DATA_IDX, &commIndexVar);
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg = fmt::format(
               "Error: failed to locate node communication map in file id {}", exodusFilePtr);
@@ -2549,7 +2549,7 @@ int Internals::put_non_define_data(const CommunicationMetaData &comm, bool full_
         }
         status = nc_put_var1_longlong(exodusFilePtr, commIndexVar, Data(start), &nl_ncnt_cmap);
 
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg = fmt::format(
               "Error: failed to output node communication map index in file ID {}", exodusFilePtr);
@@ -2563,7 +2563,7 @@ int Internals::put_non_define_data(const CommunicationMetaData &comm, bool full_
       for (size_t i = 0; i < comm.nodeMap.size(); i++) {
         node_cmap_ids[i] = comm.nodeMap[i].id;
       }
-      if (put_id_array(exodusFilePtr, VAR_N_COMM_IDS, node_cmap_ids) != NC_NOERR) {
+      if (put_id_array(exodusFilePtr, VAR_N_COMM_IDS, node_cmap_ids) != EX_NOERR) {
         return EX_FATAL;
       }
     }
@@ -2578,7 +2578,7 @@ int Internals::put_non_define_data(const CommunicationMetaData &comm, bool full_
       // Get variable ID for elemental status vector
       int e_varid;
       status = nc_inq_varid(exodusFilePtr, VAR_E_COMM_STAT, &e_varid);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg =
             fmt::format("Error: failed to find variable ID for \"{}\" in file ID {}",
@@ -2594,7 +2594,7 @@ int Internals::put_non_define_data(const CommunicationMetaData &comm, bool full_
         auto       nmstat = comm.elementMap[icm].entityCount > 0 ? 1 : 0;
 
         status = nc_put_var1_int(exodusFilePtr, e_varid, Data(start), &nmstat);
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg =
               fmt::format("Error: unable to output variable in file ID {}", exodusFilePtr);
@@ -2607,7 +2607,7 @@ int Internals::put_non_define_data(const CommunicationMetaData &comm, bool full_
 
         // fill the cmap data index
         status = nc_inq_varid(exodusFilePtr, VAR_E_COMM_DATA_IDX, &elemCommIndexVar);
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg = fmt::format(
               "Error: failed to locate element communication map in file id {}", exodusFilePtr);
@@ -2615,7 +2615,7 @@ int Internals::put_non_define_data(const CommunicationMetaData &comm, bool full_
           return EX_FATAL;
         }
         status = nc_put_var1_longlong(exodusFilePtr, elemCommIndexVar, Data(start), &nl_ecnt_cmap);
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg = fmt::format(
               "Error: failed to output int elem map index in file ID {}", exodusFilePtr);
@@ -2629,7 +2629,7 @@ int Internals::put_non_define_data(const CommunicationMetaData &comm, bool full_
       for (size_t i = 0; i < comm.elementMap.size(); i++) {
         elem_cmap_ids[i] = comm.elementMap[i].id;
       }
-      if (put_id_array(exodusFilePtr, VAR_E_COMM_IDS, elem_cmap_ids) != NC_NOERR) {
+      if (put_id_array(exodusFilePtr, VAR_E_COMM_IDS, elem_cmap_ids) != EX_NOERR) {
         return EX_FATAL;
       }
     }
@@ -2645,7 +2645,7 @@ int Internals::put_non_define_data(const std::vector<Blob> &blobs)
   size_t name_length = 0;
   for (const auto &blob : blobs) {
     name_length = std::max(name_length, blob.name.length());
-    if ((status = nc_inq_varid(exodusFilePtr, VAR_ENTITY_BLOB(blob.id), &entlst_id)) != NC_NOERR) {
+    if ((status = nc_inq_varid(exodusFilePtr, VAR_ENTITY_BLOB(blob.id), &entlst_id)) != EX_NOERR) {
       std::string errmsg =
           fmt::format("Error: failed to locate entity list array for blob {} in file id {}",
                       blob.id, exodusFilePtr);
@@ -2708,12 +2708,12 @@ int Internals::put_non_define_data(const std::vector<ElemBlock> &blocks, bool ou
       elem_blk_id[iblk] = blocks[iblk].id;
     }
 
-    if (put_id_array(exodusFilePtr, VAR_ID_EL_BLK, elem_blk_id) != NC_NOERR) {
+    if (put_id_array(exodusFilePtr, VAR_ID_EL_BLK, elem_blk_id) != EX_NOERR) {
       return EX_FATAL;
     }
 
     if (output_global_data) {
-      if (put_id_array(exodusFilePtr, VAR_ELBLK_IDS_GLOBAL, elem_blk_id) != NC_NOERR) {
+      if (put_id_array(exodusFilePtr, VAR_ELBLK_IDS_GLOBAL, elem_blk_id) != EX_NOERR) {
         return EX_FATAL;
       }
 
@@ -2721,7 +2721,7 @@ int Internals::put_non_define_data(const std::vector<ElemBlock> &blocks, bool ou
       for (int iblk = 0; iblk < num_elem_blk; iblk++) {
         counts[iblk] = blocks[iblk].globalEntityCount;
       }
-      if (put_int_array(exodusFilePtr, VAR_ELBLK_CNT_GLOBAL, counts) != NC_NOERR) {
+      if (put_int_array(exodusFilePtr, VAR_ELBLK_CNT_GLOBAL, counts) != EX_NOERR) {
         return EX_FATAL;
       }
     }
@@ -2732,7 +2732,7 @@ int Internals::put_non_define_data(const std::vector<ElemBlock> &blocks, bool ou
       elem_blk_status[iblk] = blocks[iblk].entityCount > 0 ? 1 : 0;
     }
 
-    if (put_int_array(exodusFilePtr, VAR_STAT_EL_BLK, elem_blk_status) != NC_NOERR) {
+    if (put_int_array(exodusFilePtr, VAR_STAT_EL_BLK, elem_blk_status) != EX_NOERR) {
       return EX_FATAL;
     }
 
@@ -2745,7 +2745,7 @@ int Internals::put_non_define_data(const std::vector<ElemBlock> &blocks, bool ou
       if (blocks[iblk].attributeCount > 0 && blocks[iblk].entityCount > 0) {
         int varid;
         int status = nc_inq_varid(exodusFilePtr, VAR_NAME_ATTRIB(iblk + 1), &varid);
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg = fmt::format(
               "Error: failed to locate variable name attribute in file id {}", exodusFilePtr);
@@ -2774,7 +2774,7 @@ int Internals::put_non_define_data(const std::vector<FaceBlock> &blocks)
       face_blk_id[iblk] = blocks[iblk].id;
     }
 
-    if (put_id_array(exodusFilePtr, VAR_ID_FA_BLK, face_blk_id) != NC_NOERR) {
+    if (put_id_array(exodusFilePtr, VAR_ID_FA_BLK, face_blk_id) != EX_NOERR) {
       return EX_FATAL;
     }
 
@@ -2784,7 +2784,7 @@ int Internals::put_non_define_data(const std::vector<FaceBlock> &blocks)
       face_blk_status[iblk] = blocks[iblk].entityCount > 0 ? 1 : 0;
     }
 
-    if (put_int_array(exodusFilePtr, VAR_STAT_FA_BLK, face_blk_status) != NC_NOERR) {
+    if (put_int_array(exodusFilePtr, VAR_STAT_FA_BLK, face_blk_status) != EX_NOERR) {
       return EX_FATAL;
     }
 
@@ -2797,7 +2797,7 @@ int Internals::put_non_define_data(const std::vector<FaceBlock> &blocks)
       if (blocks[iblk].attributeCount > 0 && blocks[iblk].entityCount > 0) {
         int varid;
         int status = nc_inq_varid(exodusFilePtr, VAR_NAME_FATTRIB(iblk + 1), &varid);
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg = fmt::format(
               "Error: failed to locate face variable name attribute in file id {}", exodusFilePtr);
@@ -2826,7 +2826,7 @@ int Internals::put_non_define_data(const std::vector<EdgeBlock> &blocks)
       edge_blk_id[iblk] = blocks[iblk].id;
     }
 
-    if (put_id_array(exodusFilePtr, VAR_ID_ED_BLK, edge_blk_id) != NC_NOERR) {
+    if (put_id_array(exodusFilePtr, VAR_ID_ED_BLK, edge_blk_id) != EX_NOERR) {
       return EX_FATAL;
     }
 
@@ -2836,7 +2836,7 @@ int Internals::put_non_define_data(const std::vector<EdgeBlock> &blocks)
       edge_blk_status[iblk] = blocks[iblk].entityCount > 0 ? 1 : 0;
     }
 
-    if (put_int_array(exodusFilePtr, VAR_STAT_ED_BLK, edge_blk_status) != NC_NOERR) {
+    if (put_int_array(exodusFilePtr, VAR_STAT_ED_BLK, edge_blk_status) != EX_NOERR) {
       return EX_FATAL;
     }
 
@@ -2848,7 +2848,7 @@ int Internals::put_non_define_data(const std::vector<EdgeBlock> &blocks)
       if (blocks[iblk].attributeCount > 0 && blocks[iblk].entityCount > 0) {
         int varid;
         int status = nc_inq_varid(exodusFilePtr, VAR_NAME_EATTRIB(iblk + 1), &varid);
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg =
               fmt::format("Error: failed to locate element variable name attribute in file id {}",
@@ -2880,7 +2880,7 @@ int Internals::put_metadata(const std::vector<NodeSet> &nodesets, bool count_onl
   int dimid;
   int num_node_sets = 0;
   int status        = nc_inq_dimid(exodusFilePtr, DIM_NUM_NS, &dimid);
-  if (status != NC_NOERR) {
+  if (status != EX_NOERR) {
     ex_opts(EX_VERBOSE);
     if (status == NC_EBADDIM) {
       std::string errmsg = fmt::format("Error: no node sets defined for file id {}", exodusFilePtr);
@@ -2899,7 +2899,7 @@ int Internals::put_metadata(const std::vector<NodeSet> &nodesets, bool count_onl
 
   int namestrdim;
   status = nc_inq_dimid(exodusFilePtr, DIM_STR_NAME, &namestrdim);
-  if (status != NC_NOERR) {
+  if (status != EX_NOERR) {
     ex_opts(EX_VERBOSE);
     std::string errmsg =
         fmt::format("Error: failed to get string length in file id {}", exodusFilePtr);
@@ -2921,7 +2921,7 @@ int Internals::put_metadata(const std::vector<NodeSet> &nodesets, bool count_onl
 
     status = nc_def_dim(exodusFilePtr, DIM_NUM_NOD_NS(cur_num_node_sets + 1),
                         nodesets[i].entityCount, &dimid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       if (status == NC_ENAMEINUSE) {
         std::string errmsg = fmt::format("Error: node set {} already defined in file id {}",
@@ -2945,7 +2945,7 @@ int Internals::put_metadata(const std::vector<NodeSet> &nodesets, bool count_onl
     int        varid;
     status = nc_def_var(exodusFilePtr, VAR_NODE_NS(cur_num_node_sets + 1), bulk_type, 1,
                         Data(dims1), &varid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       if (status == NC_ENAMEINUSE) {
         std::string errmsg =
@@ -2979,7 +2979,7 @@ int Internals::put_metadata(const std::vector<NodeSet> &nodesets, bool count_onl
       // create variable for distribution factors
       status = nc_def_var(exodusFilePtr, VAR_FACT_NS(cur_num_node_sets + 1),
                           nc_flt_code(exodusFilePtr), 1, Data(dims1), &varid);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         if (status == NC_ENAMEINUSE) {
           std::string errmsg =
@@ -3002,7 +3002,7 @@ int Internals::put_metadata(const std::vector<NodeSet> &nodesets, bool count_onl
       int numattrdim;
       status = nc_def_dim(exodusFilePtr, DIM_NUM_ATT_IN_NS(cur_num_node_sets + 1),
                           nodesets[i].attributeCount, &numattrdim);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg =
             fmt::format("Error: failed to define number of attributes in nodeset {}"
@@ -3016,7 +3016,7 @@ int Internals::put_metadata(const std::vector<NodeSet> &nodesets, bool count_onl
         std::array dims{dimid, numattrdim};
         status = nc_def_var(exodusFilePtr, VAR_NSATTRIB(cur_num_node_sets + 1),
                             nc_flt_code(exodusFilePtr), 2, Data(dims), &varid);
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg =
               fmt::format("Error:  failed to define attributes for element nodeset {}"
@@ -3034,7 +3034,7 @@ int Internals::put_metadata(const std::vector<NodeSet> &nodesets, bool count_onl
 
         status = nc_def_var(exodusFilePtr, VAR_NAME_NSATTRIB(cur_num_node_sets + 1), NC_CHAR, 2,
                             Data(dims), &varid);
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg =
               fmt::format("Error: failed to define attribute name array for nodeset {}"
@@ -3062,7 +3062,7 @@ int Internals::put_metadata(const std::vector<EdgeSet> &edgesets, bool count_onl
   int dimid;
   int num_edge_sets = 0;
   int status        = nc_inq_dimid(exodusFilePtr, DIM_NUM_ES, &dimid);
-  if (status != NC_NOERR) {
+  if (status != EX_NOERR) {
     ex_opts(EX_VERBOSE);
     if (status == NC_EBADDIM) {
       std::string errmsg = fmt::format("Error: no edge sets defined for file id {}", exodusFilePtr);
@@ -3083,7 +3083,7 @@ int Internals::put_metadata(const std::vector<EdgeSet> &edgesets, bool count_onl
 
   int namestrdim;
   status = nc_inq_dimid(exodusFilePtr, DIM_STR_NAME, &namestrdim);
-  if (status != NC_NOERR) {
+  if (status != EX_NOERR) {
     ex_opts(EX_VERBOSE);
     std::string errmsg =
         fmt::format("Error: failed to get string length in file id {}", exodusFilePtr);
@@ -3103,7 +3103,7 @@ int Internals::put_metadata(const std::vector<EdgeSet> &edgesets, bool count_onl
 
     status = nc_def_dim(exodusFilePtr, DIM_NUM_EDGE_ES(cur_num_edge_sets + 1),
                         edgesets[i].entityCount, &dimid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       if (status == NC_ENAMEINUSE) {
         std::string errmsg = fmt::format("Error: edge set {} already defined in file id {}",
@@ -3127,7 +3127,7 @@ int Internals::put_metadata(const std::vector<EdgeSet> &edgesets, bool count_onl
     int        varid;
     status = nc_def_var(exodusFilePtr, VAR_EDGE_ES(cur_num_edge_sets + 1), bulk_type, 1,
                         Data(dims1), &varid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       if (status == NC_ENAMEINUSE) {
         std::string errmsg =
@@ -3148,7 +3148,7 @@ int Internals::put_metadata(const std::vector<EdgeSet> &edgesets, bool count_onl
     // Orientation variable
     status = nc_def_var(exodusFilePtr, VAR_ORNT_ES(cur_num_edge_sets + 1), bulk_type, 1,
                         Data(dims1), &varid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       if (status == NC_ENAMEINUSE) {
         std::string errmsg =
@@ -3182,7 +3182,7 @@ int Internals::put_metadata(const std::vector<EdgeSet> &edgesets, bool count_onl
       // create variable for distribution factors
       status = nc_def_var(exodusFilePtr, VAR_FACT_ES(cur_num_edge_sets + 1),
                           nc_flt_code(exodusFilePtr), 1, Data(dims1), &varid);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         if (status == NC_ENAMEINUSE) {
           std::string errmsg =
@@ -3204,7 +3204,7 @@ int Internals::put_metadata(const std::vector<EdgeSet> &edgesets, bool count_onl
       int numattrdim;
       status = nc_def_dim(exodusFilePtr, DIM_NUM_ATT_IN_ES(cur_num_edge_sets + 1),
                           edgesets[i].attributeCount, &numattrdim);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg =
             fmt::format("Error: failed to define number of attributes in edgeset {}"
@@ -3218,7 +3218,7 @@ int Internals::put_metadata(const std::vector<EdgeSet> &edgesets, bool count_onl
         std::array dims{dimid, numattrdim};
         status = nc_def_var(exodusFilePtr, VAR_ESATTRIB(cur_num_edge_sets + 1),
                             nc_flt_code(exodusFilePtr), 2, Data(dims), &varid);
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg =
               fmt::format("Error:  failed to define attributes for element edgeset {}"
@@ -3236,7 +3236,7 @@ int Internals::put_metadata(const std::vector<EdgeSet> &edgesets, bool count_onl
 
         status = nc_def_var(exodusFilePtr, VAR_NAME_ESATTRIB(cur_num_edge_sets + 1), NC_CHAR, 2,
                             Data(dims), &varid);
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg =
               fmt::format("Error: failed to define attribute name array for edgeset {}"
@@ -3264,7 +3264,7 @@ int Internals::put_metadata(const std::vector<FaceSet> &facesets, bool count_onl
   int dimid;
   int num_face_sets = 0;
   int status        = nc_inq_dimid(exodusFilePtr, DIM_NUM_FS, &dimid);
-  if (status != NC_NOERR) {
+  if (status != EX_NOERR) {
     ex_opts(EX_VERBOSE);
     if (status == NC_EBADDIM) {
       std::string errmsg = fmt::format("Error: no face sets defined for file id {}", exodusFilePtr);
@@ -3285,7 +3285,7 @@ int Internals::put_metadata(const std::vector<FaceSet> &facesets, bool count_onl
 
   int namestrdim;
   status = nc_inq_dimid(exodusFilePtr, DIM_STR_NAME, &namestrdim);
-  if (status != NC_NOERR) {
+  if (status != EX_NOERR) {
     ex_opts(EX_VERBOSE);
     std::string errmsg =
         fmt::format("Error: failed to get string length in file id {}", exodusFilePtr);
@@ -3305,7 +3305,7 @@ int Internals::put_metadata(const std::vector<FaceSet> &facesets, bool count_onl
 
     status = nc_def_dim(exodusFilePtr, DIM_NUM_FACE_FS(cur_num_face_sets + 1),
                         facesets[i].entityCount, &dimid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       if (status == NC_ENAMEINUSE) {
         std::string errmsg = fmt::format("Error: face set {} already defined in file id {}",
@@ -3329,7 +3329,7 @@ int Internals::put_metadata(const std::vector<FaceSet> &facesets, bool count_onl
     int        varid;
     status = nc_def_var(exodusFilePtr, VAR_FACE_FS(cur_num_face_sets + 1), bulk_type, 1,
                         Data(dims1), &varid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       if (status == NC_ENAMEINUSE) {
         std::string errmsg =
@@ -3350,7 +3350,7 @@ int Internals::put_metadata(const std::vector<FaceSet> &facesets, bool count_onl
     // Orientation variable
     status = nc_def_var(exodusFilePtr, VAR_ORNT_FS(cur_num_face_sets + 1), bulk_type, 1,
                         Data(dims1), &varid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       if (status == NC_ENAMEINUSE) {
         std::string errmsg =
@@ -3384,7 +3384,7 @@ int Internals::put_metadata(const std::vector<FaceSet> &facesets, bool count_onl
       // create variable for distribution factors
       status = nc_def_var(exodusFilePtr, VAR_FACT_FS(cur_num_face_sets + 1),
                           nc_flt_code(exodusFilePtr), 1, Data(dims1), &varid);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         if (status == NC_ENAMEINUSE) {
           std::string errmsg =
@@ -3406,7 +3406,7 @@ int Internals::put_metadata(const std::vector<FaceSet> &facesets, bool count_onl
       int numattrdim;
       status = nc_def_dim(exodusFilePtr, DIM_NUM_ATT_IN_FS(cur_num_face_sets + 1),
                           facesets[i].attributeCount, &numattrdim);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg =
             fmt::format("Error: failed to define number of attributes in faceset {}"
@@ -3420,7 +3420,7 @@ int Internals::put_metadata(const std::vector<FaceSet> &facesets, bool count_onl
         std::array dims{dimid, numattrdim};
         status = nc_def_var(exodusFilePtr, VAR_FSATTRIB(cur_num_face_sets + 1),
                             nc_flt_code(exodusFilePtr), 2, Data(dims), &varid);
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg =
               fmt::format("Error:  failed to define attributes for element faceset {}"
@@ -3438,7 +3438,7 @@ int Internals::put_metadata(const std::vector<FaceSet> &facesets, bool count_onl
 
         status = nc_def_var(exodusFilePtr, VAR_NAME_FSATTRIB(cur_num_face_sets + 1), NC_CHAR, 2,
                             Data(dims), &varid);
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg =
               fmt::format("Error: failed to define attribute name array for faceset {}"
@@ -3464,7 +3464,7 @@ int Internals::put_metadata(const std::vector<ElemSet> &elemsets, bool count_onl
   int dimid;
   int num_elem_sets = 0;
   int status        = nc_inq_dimid(exodusFilePtr, DIM_NUM_ELS, &dimid);
-  if (status != NC_NOERR) {
+  if (status != EX_NOERR) {
     ex_opts(EX_VERBOSE);
     if (status == NC_EBADDIM) {
       std::string errmsg =
@@ -3486,7 +3486,7 @@ int Internals::put_metadata(const std::vector<ElemSet> &elemsets, bool count_onl
 
   int namestrdim;
   status = nc_inq_dimid(exodusFilePtr, DIM_STR_NAME, &namestrdim);
-  if (status != NC_NOERR) {
+  if (status != EX_NOERR) {
     ex_opts(EX_VERBOSE);
     std::string errmsg =
         fmt::format("Error: failed to get string length in file id {}", exodusFilePtr);
@@ -3506,7 +3506,7 @@ int Internals::put_metadata(const std::vector<ElemSet> &elemsets, bool count_onl
 
     status = nc_def_dim(exodusFilePtr, DIM_NUM_ELE_ELS(cur_num_elem_sets + 1),
                         elemsets[i].entityCount, &dimid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       if (status == NC_ENAMEINUSE) {
         std::string errmsg = fmt::format("Error: elem set {} already defined in file id {}",
@@ -3531,7 +3531,7 @@ int Internals::put_metadata(const std::vector<ElemSet> &elemsets, bool count_onl
     status = nc_def_var(exodusFilePtr, VAR_ELEM_ELS(cur_num_elem_sets + 1),
                         get_type(exodusFilePtr, EX_BULK_INT64_DB), 1, Data(dims1), &varid);
 
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       if (status == NC_ENAMEINUSE) {
         std::string errmsg =
@@ -3565,7 +3565,7 @@ int Internals::put_metadata(const std::vector<ElemSet> &elemsets, bool count_onl
       // create variable for distribution factors
       status = nc_def_var(exodusFilePtr, VAR_FACT_ELS(cur_num_elem_sets + 1),
                           nc_flt_code(exodusFilePtr), 1, Data(dims1), &varid);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         if (status == NC_ENAMEINUSE) {
           std::string errmsg =
@@ -3587,7 +3587,7 @@ int Internals::put_metadata(const std::vector<ElemSet> &elemsets, bool count_onl
       int numattrdim;
       status = nc_def_dim(exodusFilePtr, DIM_NUM_ATT_IN_ES(cur_num_elem_sets + 1),
                           elemsets[i].attributeCount, &numattrdim);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg =
             fmt::format("Error: failed to define number of attributes in elemset {}"
@@ -3601,7 +3601,7 @@ int Internals::put_metadata(const std::vector<ElemSet> &elemsets, bool count_onl
         std::array dims{dimid, numattrdim};
         status = nc_def_var(exodusFilePtr, VAR_ESATTRIB(cur_num_elem_sets + 1),
                             nc_flt_code(exodusFilePtr), 2, Data(dims), &varid);
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg =
               fmt::format("Error:  failed to define attributes for element elemset {}"
@@ -3619,7 +3619,7 @@ int Internals::put_metadata(const std::vector<ElemSet> &elemsets, bool count_onl
 
         status = nc_def_var(exodusFilePtr, VAR_NAME_ESATTRIB(cur_num_elem_sets + 1), NC_CHAR, 2,
                             Data(dims), &varid);
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg =
               fmt::format("Error: failed to define attribute name array for elemset {}"
@@ -3648,12 +3648,12 @@ int Internals::put_non_define_data(const std::vector<NodeSet> &nodesets, bool ou
     nodeset_id[i] = nodesets[i].id;
   }
 
-  if (put_id_array(exodusFilePtr, VAR_NS_IDS, nodeset_id) != NC_NOERR) {
+  if (put_id_array(exodusFilePtr, VAR_NS_IDS, nodeset_id) != EX_NOERR) {
     return EX_FATAL;
   }
 
   if (output_global_data) {
-    if (put_id_array(exodusFilePtr, VAR_NS_IDS_GLOBAL, nodeset_id) != NC_NOERR) {
+    if (put_id_array(exodusFilePtr, VAR_NS_IDS_GLOBAL, nodeset_id) != EX_NOERR) {
       return EX_FATAL;
     }
 
@@ -3661,7 +3661,7 @@ int Internals::put_non_define_data(const std::vector<NodeSet> &nodesets, bool ou
     for (size_t iset = 0; iset < num_nodesets; iset++) {
       counts[iset] = nodesets[iset].globalEntityCount;
     }
-    if (put_int_array(exodusFilePtr, VAR_NS_NODE_CNT_GLOBAL, counts) != NC_NOERR) {
+    if (put_int_array(exodusFilePtr, VAR_NS_NODE_CNT_GLOBAL, counts) != EX_NOERR) {
       return EX_FATAL;
     }
   }
@@ -3672,7 +3672,7 @@ int Internals::put_non_define_data(const std::vector<NodeSet> &nodesets, bool ou
     status[i] = nodesets[i].entityCount > 0 ? 1 : 0;
   }
 
-  if (put_int_array(exodusFilePtr, VAR_NS_STAT, status) != NC_NOERR) {
+  if (put_int_array(exodusFilePtr, VAR_NS_STAT, status) != EX_NOERR) {
     return EX_FATAL;
   }
 
@@ -3692,7 +3692,7 @@ int Internals::put_non_define_data(const std::vector<EdgeSet> &edgesets)
     edgeset_id[i] = edgesets[i].id;
   }
 
-  if (put_id_array(exodusFilePtr, VAR_ES_IDS, edgeset_id) != NC_NOERR) {
+  if (put_id_array(exodusFilePtr, VAR_ES_IDS, edgeset_id) != EX_NOERR) {
     return EX_FATAL;
   }
 
@@ -3702,7 +3702,7 @@ int Internals::put_non_define_data(const std::vector<EdgeSet> &edgesets)
     status[i] = edgesets[i].entityCount > 0 ? 1 : 0;
   }
 
-  if (put_int_array(exodusFilePtr, VAR_ES_STAT, status) != NC_NOERR) {
+  if (put_int_array(exodusFilePtr, VAR_ES_STAT, status) != EX_NOERR) {
     return EX_FATAL;
   }
 
@@ -3722,7 +3722,7 @@ int Internals::put_non_define_data(const std::vector<FaceSet> &facesets)
     faceset_id[i] = facesets[i].id;
   }
 
-  if (put_id_array(exodusFilePtr, VAR_FS_IDS, faceset_id) != NC_NOERR) {
+  if (put_id_array(exodusFilePtr, VAR_FS_IDS, faceset_id) != EX_NOERR) {
     return EX_FATAL;
   }
 
@@ -3732,7 +3732,7 @@ int Internals::put_non_define_data(const std::vector<FaceSet> &facesets)
     status[i] = facesets[i].entityCount > 0 ? 1 : 0;
   }
 
-  if (put_int_array(exodusFilePtr, VAR_FS_STAT, status) != NC_NOERR) {
+  if (put_int_array(exodusFilePtr, VAR_FS_STAT, status) != EX_NOERR) {
     return EX_FATAL;
   }
 
@@ -3752,7 +3752,7 @@ int Internals::put_non_define_data(const std::vector<ElemSet> &elemsets)
     elemset_id[i] = elemsets[i].id;
   }
 
-  if (put_id_array(exodusFilePtr, VAR_ELS_IDS, elemset_id) != NC_NOERR) {
+  if (put_id_array(exodusFilePtr, VAR_ELS_IDS, elemset_id) != EX_NOERR) {
     return EX_FATAL;
   }
 
@@ -3762,7 +3762,7 @@ int Internals::put_non_define_data(const std::vector<ElemSet> &elemsets)
     status[i] = elemsets[i].entityCount > 0 ? 1 : 0;
   }
 
-  if (put_int_array(exodusFilePtr, VAR_ELS_STAT, status) != NC_NOERR) {
+  if (put_int_array(exodusFilePtr, VAR_ELS_STAT, status) != EX_NOERR) {
     return EX_FATAL;
   }
 
@@ -3781,7 +3781,7 @@ int Internals::put_metadata(const std::vector<SideSet> &sidesets, bool count_onl
   int dimid;
   int num_side_sets = 0;
   int status        = nc_inq_dimid(exodusFilePtr, DIM_NUM_SS, &dimid);
-  if (status != NC_NOERR) {
+  if (status != EX_NOERR) {
     ex_opts(EX_VERBOSE);
     if (status == NC_EBADDIM) {
       std::string errmsg = fmt::format("Error: no side sets defined for file id {}", exodusFilePtr);
@@ -3812,7 +3812,7 @@ int Internals::put_metadata(const std::vector<SideSet> &sidesets, bool count_onl
 
     status = nc_def_dim(exodusFilePtr, DIM_NUM_SIDE_SS(cur_num_side_sets + 1),
                         sidesets[i].entityCount, &dimid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       if (status == NC_ENAMEINUSE) {
         std::string errmsg = fmt::format("Error: side set {} already defined in file id {}",
@@ -3835,7 +3835,7 @@ int Internals::put_metadata(const std::vector<SideSet> &sidesets, bool count_onl
     int        varid = 0;
     status = nc_def_var(exodusFilePtr, VAR_ELEM_SS(cur_num_side_sets + 1), bulk_type, 1, Data(dims),
                         &varid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       if (status == NC_ENAMEINUSE) {
         std::string errmsg =
@@ -3856,7 +3856,7 @@ int Internals::put_metadata(const std::vector<SideSet> &sidesets, bool count_onl
     // create side list variable for side set
     status = nc_def_var(exodusFilePtr, VAR_SIDE_SS(cur_num_side_sets + 1), bulk_type, 1, Data(dims),
                         &varid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       if (status == NC_ENAMEINUSE) {
         std::string errmsg =
@@ -3878,7 +3878,7 @@ int Internals::put_metadata(const std::vector<SideSet> &sidesets, bool count_onl
     if (sidesets[i].dfCount > 0) {
       status = nc_def_dim(exodusFilePtr, DIM_NUM_DF_SS(cur_num_side_sets + 1), sidesets[i].dfCount,
                           &dimid);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         if (status == NC_ENAMEINUSE) {
           std::string errmsg =
@@ -3899,7 +3899,7 @@ int Internals::put_metadata(const std::vector<SideSet> &sidesets, bool count_onl
       dims[0] = dimid;
       status  = nc_def_var(exodusFilePtr, VAR_FACT_SS(cur_num_side_sets + 1),
                            nc_flt_code(exodusFilePtr), 1, Data(dims), &varid);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         if (status == NC_ENAMEINUSE) {
           std::string errmsg = fmt::format("Error: dist factor list already exists for side set {}"
@@ -3935,12 +3935,12 @@ int Internals::put_non_define_data(const std::vector<SideSet> &sidesets, bool ou
     sideset_id[i] = sidesets[i].id;
   }
 
-  if (put_id_array(exodusFilePtr, VAR_SS_IDS, sideset_id) != NC_NOERR) {
+  if (put_id_array(exodusFilePtr, VAR_SS_IDS, sideset_id) != EX_NOERR) {
     return EX_FATAL;
   }
 
   if (output_global_data) {
-    if (put_id_array(exodusFilePtr, VAR_SS_IDS_GLOBAL, sideset_id) != NC_NOERR) {
+    if (put_id_array(exodusFilePtr, VAR_SS_IDS_GLOBAL, sideset_id) != EX_NOERR) {
       return EX_FATAL;
     }
 
@@ -3948,7 +3948,7 @@ int Internals::put_non_define_data(const std::vector<SideSet> &sidesets, bool ou
     for (int iset = 0; iset < num_sidesets; iset++) {
       counts[iset] = sidesets[iset].globalEntityCount;
     }
-    if (put_int_array(exodusFilePtr, VAR_SS_SIDE_CNT_GLOBAL, counts) != NC_NOERR) {
+    if (put_int_array(exodusFilePtr, VAR_SS_SIDE_CNT_GLOBAL, counts) != EX_NOERR) {
       return EX_FATAL;
     }
   }
@@ -3959,7 +3959,7 @@ int Internals::put_non_define_data(const std::vector<SideSet> &sidesets, bool ou
     status[i] = sidesets[i].entityCount > 0 ? 1 : 0;
   }
 
-  if (put_int_array(exodusFilePtr, VAR_SS_STAT, status) != NC_NOERR) {
+  if (put_int_array(exodusFilePtr, VAR_SS_STAT, status) != EX_NOERR) {
     return EX_FATAL;
   }
 
@@ -3994,9 +3994,9 @@ namespace {
                                   nc_type type)
   {
     int status = nc_inq_varid(exodusFilePtr, var, varid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       status = nc_def_var(exodusFilePtr, var, type, 1, &dimid, varid);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg = fmt::format("Error: Failed to define variable \"{}\" in file ID {}",
                                          var, exodusFilePtr);
@@ -4015,7 +4015,7 @@ namespace {
     if (size > 0) {
       std::array<int, 1> dimid;
       int                status = nc_def_dim(exodusFilePtr, dim, size, Data(dimid));
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg = fmt::format("Error: failed to dimension \"{}\" in file id {}",
                                          DIM_NUM_BOR_ELEMS, exodusFilePtr);
@@ -4025,7 +4025,7 @@ namespace {
 
       int varid;
       status = nc_def_var(exodusFilePtr, var, type, 1, Data(dimid), &varid);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg = fmt::format("Error: failed to define variable \"{}\" in file ID {}",
                                          VAR_ELEM_MAP_BOR, exodusFilePtr);
@@ -4043,7 +4043,7 @@ namespace {
     if (size > 0) {
       std::array<int, 1> dimid;
       int                status = nc_def_dim(exodusFilePtr, dim, size, Data(dimid));
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg = fmt::format("Error: failed to dimension \"{}\" in file id {}",
                                          DIM_NUM_BOR_ELEMS, exodusFilePtr);
@@ -4055,7 +4055,7 @@ namespace {
       while (var[i] != nullptr) {
         int varid;
         status = nc_def_var(exodusFilePtr, var[i], types[i], 1, Data(dimid), &varid);
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg = fmt::format("Error: failed to define variable \"{}\" in file ID {}",
                                            var[i], exodusFilePtr);
@@ -4073,7 +4073,7 @@ namespace {
   {
     int var_id;
     int status = nc_inq_varid(exoid, var_type, &var_id);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg = fmt::format("Error: failed to locate {} in file id {}", var_type, exoid);
       ex_err_fn(exoid, __func__, errmsg.c_str(), status);
@@ -4081,7 +4081,7 @@ namespace {
     }
 
     status = nc_put_var_int(exoid, var_id, Data(array));
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg =
           fmt::format("Error: failed to write {} array in file id {}", var_type, exoid);
@@ -4095,7 +4095,7 @@ namespace {
   {
     int var_id;
     int status = nc_inq_varid(exoid, var_type, &var_id);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg = fmt::format("Error: failed to locate {} in file id {}", var_type, exoid);
       ex_err_fn(exoid, __func__, errmsg.c_str(), status);
@@ -4103,7 +4103,7 @@ namespace {
     }
 
     status = nc_put_var_longlong(exoid, var_id, (long long *)Data(array));
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg =
           fmt::format("Error: failed to write {} array in file id {}", var_type, exoid);
@@ -4117,7 +4117,7 @@ namespace {
   {
     int var_id;
     int status = nc_inq_varid(exoid, var_type, &var_id);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg = fmt::format("Error: failed to locate {} in file id {}", var_type, exoid);
       ex_err_fn(exoid, __func__, errmsg.c_str(), status);
@@ -4143,7 +4143,7 @@ namespace {
       status = nc_put_var_int(exoid, var_id, Data(int_ids));
     }
 
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg =
           fmt::format("Error: failed to write {} array in file id {}", var_type, exoid);
@@ -4164,7 +4164,7 @@ namespace {
       if (dimension > 0) {
         int status = nc_def_var(exodusFilePtr, VAR_COORD_X, nc_flt_code(exodusFilePtr), 1,
                                 Data(dim), &varid);
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg = fmt::format(
               "Error: failed to define node x coordinate array in file id {}", exodusFilePtr);
@@ -4177,7 +4177,7 @@ namespace {
       if (dimension > 1) {
         int status = nc_def_var(exodusFilePtr, VAR_COORD_Y, nc_flt_code(exodusFilePtr), 1,
                                 Data(dim), &varid);
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg = fmt::format(
               "Error: failed to define node y coordinate array in file id {}", exodusFilePtr);
@@ -4190,7 +4190,7 @@ namespace {
       if (dimension > 2) {
         int status = nc_def_var(exodusFilePtr, VAR_COORD_Z, nc_flt_code(exodusFilePtr), 1,
                                 Data(dim), &varid);
-        if (status != NC_NOERR) {
+        if (status != EX_NOERR) {
           ex_opts(EX_VERBOSE);
           std::string errmsg = fmt::format(
               "Error: failed to define node z coordinate array in file id {}", exodusFilePtr);
@@ -4205,7 +4205,7 @@ namespace {
     std::array dim{dim_dim, str_dim};
 
     int status = nc_def_var(exodusFilePtr, VAR_NAME_COOR, NC_CHAR, 2, Data(dim), &varid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg =
           fmt::format("Error: failed to define coordinate name array in file id {}", exodusFilePtr);
@@ -4229,14 +4229,14 @@ namespace {
     int    namestrdim    = 0;
 
     int status = nc_inq_dimid(exoid, DIM_STR_NAME, &namestrdim);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       std::string errmsg = fmt::format("Error: failed to get string length in file id {}", exoid);
       ex_err_fn(exoid, __func__, errmsg.c_str(), status);
       return EX_FATAL;
     }
 
     status = nc_def_dim(exoid, dim_num, count, &dimid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg =
           fmt::format("Error: failed to define number of {}s in file id {}", type, exoid);
@@ -4247,7 +4247,7 @@ namespace {
     // id status array:
     std::array dim1{dimid};
     status = nc_def_var(exoid, stat_var, NC_INT, 1, Data(dim1), &varid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg =
           fmt::format("Error: failed to define side {} status in file id {}", type, exoid);
@@ -4262,7 +4262,7 @@ namespace {
     int ids_type = get_type(exoid, EX_IDS_INT64_DB);
     int ids_size = ids_type == NC_INT ? 4 : 8;
     status       = nc_def_var(exoid, id_var, ids_type, 1, Data(dim1), &varid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg =
           fmt::format("Error: failed to define {} property in file id {}", type, exoid);
@@ -4275,7 +4275,7 @@ namespace {
 
     // store property name as attribute of property array variable
     status = nc_put_att_text(exoid, varid, ATT_PROP_NAME, 3, "ID");
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       ex_opts(EX_VERBOSE);
       std::string errmsg = fmt::format("Error: failed to store {} property name {} in file id {}",
                                        type, "ID", exoid);
@@ -4286,7 +4286,7 @@ namespace {
     if (name_var != nullptr) {
       std::array dim{dimid, namestrdim};
       status = nc_def_var(exoid, name_var, NC_CHAR, 2, Data(dim), &varid);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         std::string errmsg =
             fmt::format("Error: failed to define {} name array in file id {}", type, exoid);
diff --git a/ThirdParty/ioss/vtkioss/exodus/Ioex_ParallelDatabaseIO.C b/ThirdParty/ioss/vtkioss/exodus/Ioex_ParallelDatabaseIO.C
index 1230c394dbbbd2de30dfeeb3037d55121bb61ec9..48febefe382fe182bfe86bca42637fdf731238a3 100644
--- a/ThirdParty/ioss/vtkioss/exodus/Ioex_ParallelDatabaseIO.C
+++ b/ThirdParty/ioss/vtkioss/exodus/Ioex_ParallelDatabaseIO.C
@@ -5,7 +5,7 @@
 //    strange cases
 //
 //
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -528,15 +528,13 @@ namespace Ioex {
     }
 #endif
 
-    bool do_timer = false;
-    Ioss::Utils::check_set_bool_property(properties, "IOSS_TIME_FILE_OPEN_CLOSE", do_timer);
-    double t_begin = (do_timer ? Ioss::Utils::timer() : 0);
+    double t_begin = (timeFileOpenCloseFlush ? Ioss::Utils::timer() : 0);
 
     int app_opt_val = ex_opts(EX_VERBOSE);
     m_exodusFilePtr = ex_open_par(filename.c_str(), EX_READ | mode, &cpu_word_size, &io_word_size,
                                   &version, util().communicator(), info);
 
-    if (do_timer) {
+    if (timeFileOpenCloseFlush) {
       double t_end    = Ioss::Utils::timer();
       double duration = util().global_minmax(t_end - t_begin, Ioss::ParallelUtils::DO_MAX);
       if (myProcessor == 0) {
@@ -625,9 +623,7 @@ namespace Ioex {
     (void)chdir(path.c_str());
 #endif
 
-    bool do_timer = false;
-    Ioss::Utils::check_set_bool_property(properties, "IOSS_TIME_FILE_OPEN_CLOSE", do_timer);
-    double t_begin = (do_timer ? Ioss::Utils::timer() : 0);
+    double t_begin = (timeFileOpenCloseFlush ? Ioss::Utils::timer() : 0);
 
     if (fileExists) {
       m_exodusFilePtr = ex_open_par(filename.c_str(), EX_WRITE | mode, &cpu_word_size,
@@ -667,7 +663,7 @@ namespace Ioex {
                                       util().communicator(), info);
     }
 
-    if (do_timer) {
+    if (timeFileOpenCloseFlush) {
       double      t_end       = Ioss::Utils::timer();
       double      duration    = util().global_minmax(t_end - t_begin, Ioss::ParallelUtils::DO_MAX);
       std::string open_create = fileExists ? "Open" : "Create";
@@ -809,6 +805,19 @@ namespace Ioex {
       decomp = std::make_unique<DecompositionData<int>>(properties, util().communicator());
     }
     assert(decomp != nullptr);
+
+    if (!blockInclusions.empty()) {
+      fmt::print(Ioss::WarnOut(), "Parallel Decomposition does not handle block Inclusions; only "
+                                  "element block Omissions.\n");
+    }
+    if (!assemblyInclusions.empty() || !assemblyOmissions.empty()) {
+      fmt::print(Ioss::WarnOut(), "Parallel Decomposition does not handle assembly "
+                                  "Omissions/Inclusions; only element block Omissions.\n");
+    }
+    if (!blockOmissions.empty()) {
+      decomp->set_block_omissions(blockOmissions);
+    }
+
     decomp->decompose_model(exoid, get_filename());
 
     read_region();
@@ -1221,7 +1230,7 @@ namespace Ioex {
       }
       else {
         block_name = Ioex::get_entity_name(get_file_pointer(), entity_type, id, basename,
-                                           maximumNameLength, db_has_name);
+                                           maximumNameLength, lowerCaseDatabaseNames, db_has_name);
       }
       if (get_use_generic_canonical_name()) {
         std::swap(block_name, alias);
@@ -1503,7 +1512,6 @@ namespace Ioex {
           }
           if (ss_name[0] != '\0') {
             Ioss::Utils::fixup_name(ss_name.data());
-            Ioex::decode_surface_name(ss_map, ss_set, ss_name.data());
           }
         }
       }
@@ -1540,8 +1548,9 @@ namespace Ioex {
             side_set_name = alias;
           }
           else {
-            side_set_name = Ioex::get_entity_name(get_file_pointer(), EX_SIDE_SET, id, "surface",
-                                                  maximumNameLength, db_has_name);
+            side_set_name =
+                Ioex::get_entity_name(get_file_pointer(), EX_SIDE_SET, id, "surface",
+                                      maximumNameLength, lowerCaseDatabaseNames, db_has_name);
           }
 
           if (side_set_name == "universal_sideset") {
@@ -1903,7 +1912,7 @@ namespace Ioex {
       }
       else {
         Xset_name = Ioex::get_entity_name(get_file_pointer(), type, id, base + "list",
-                                          maximumNameLength, db_has_name);
+                                          maximumNameLength, lowerCaseDatabaseNames, db_has_name);
       }
 
       if (get_use_generic_canonical_name()) {
@@ -2055,11 +2064,9 @@ namespace Ioex {
           size_t               ep_data_size = ent_proc.size() * sizeof(int64_t);
           get_field_internal(css, ep_field, ent_proc.data(), ep_data_size);
           for (size_t i = 0; i < ent_proc.size(); i += 2) {
-            int64_t node = ent_proc[i + 0];
-            int64_t proc = ent_proc[i + 1];
-            if (proc < idata[node - 1]) {
-              idata[node - 1] = proc;
-            }
+            int64_t node    = ent_proc[i + 0];
+            int64_t proc    = ent_proc[i + 1];
+            idata[node - 1] = std::min(idata[node - 1], static_cast<int>(proc));
           }
         }
         else {
@@ -2069,11 +2076,9 @@ namespace Ioex {
           size_t           ep_data_size = ent_proc.size() * sizeof(int);
           get_field_internal(css, ep_field, ent_proc.data(), ep_data_size);
           for (size_t i = 0; i < ent_proc.size(); i += 2) {
-            int node = ent_proc[i + 0];
-            int proc = ent_proc[i + 1];
-            if (proc < idata[node - 1]) {
-              idata[node - 1] = proc;
-            }
+            int node        = ent_proc[i + 0];
+            int proc        = ent_proc[i + 1];
+            idata[node - 1] = std::min(idata[node - 1], proc);
           }
         }
       }
@@ -4916,9 +4921,7 @@ namespace Ioex {
 
     if (metaDataWritten) {
       const Ioss::NodeBlockContainer &node_blocks = get_region()->get_node_blocks();
-      if (node_blocks.empty()) {
-        return;
-      }
+      assert(!node_blocks.empty());
       assert(node_blocks[0]->property_exists("_processor_offset"));
       assert(node_blocks[0]->property_exists("locally_owned_count"));
       size_t processor_offset    = node_blocks[0]->get_property("_processor_offset").get_int();
diff --git a/ThirdParty/ioss/vtkioss/exodus/Ioex_ParallelDatabaseIO.h b/ThirdParty/ioss/vtkioss/exodus/Ioex_ParallelDatabaseIO.h
index 863537deb5e9a9c2ee1aaa377007bdbef71b20c1..1588e91de67f491c5d4047de8e09407116c82fb5 100644
--- a/ThirdParty/ioss/vtkioss/exodus/Ioex_ParallelDatabaseIO.h
+++ b/ThirdParty/ioss/vtkioss/exodus/Ioex_ParallelDatabaseIO.h
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -64,7 +64,7 @@ namespace Ioss {
  *  parallel exodus database format.
  */
 namespace Ioex {
-  class IOEX_EXPORT ParallelDatabaseIO : public Ioex::BaseDatabaseIO
+  class IOEX_EXPORT ParallelDatabaseIO final : public Ioex::BaseDatabaseIO
   {
   public:
     ParallelDatabaseIO(Ioss::Region *region, const std::string &filename,
diff --git a/ThirdParty/ioss/vtkioss/exodus/Ioex_SuperElement.C b/ThirdParty/ioss/vtkioss/exodus/Ioex_SuperElement.C
index ffdbf4e18e3259bd54f8740a559cebf216fc8e92..7d7be068125f153023bb5e3280d491ff1f9829aa 100644
--- a/ThirdParty/ioss/vtkioss/exodus/Ioex_SuperElement.C
+++ b/ThirdParty/ioss/vtkioss/exodus/Ioex_SuperElement.C
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2020, 2023, 2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2020, 2023, 2024, 2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -13,6 +13,7 @@
 #include "exodus/Ioex_SuperElement.h" // for SuperElement
 #include <cassert>
 #include <cstddef>
+#include <vtk_exodusII.h>
 #include "vtk_fmt.h"
 #include VTK_FMT(fmt/ostream.h)
 #include <iosfwd>
@@ -29,7 +30,7 @@ namespace {
 
     int varid  = 0;
     int status = nc_inq_varid(ncid, name, &varid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       return status;
     }
 
@@ -43,7 +44,7 @@ namespace {
     int dimid = -1;
 
     int status = nc_inq_dimid(ncid, DIMENSION, &dimid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       if (status == NC_EBADDIM) {
         // Value is zero if the dimension is not defined.
         *count = 0;
@@ -53,7 +54,7 @@ namespace {
     }
 
     status = nc_inq_dimlen(ncid, dimid, count);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       IOSS_ERROR(fmt::format("ERROR: Failed to get number of {} in superelement file.", label));
     }
     return status;
@@ -73,7 +74,7 @@ Ioex::SuperElement::SuperElement(std::string filename, const std::string &my_nam
   std::string local_filename = fileName;
 
   int status = nc_open(local_filename.c_str(), NC_NOWRITE, &filePtr);
-  if (status != NC_NOERR) {
+  if (status != EX_NOERR) {
     IOSS_ERROR(fmt::format("ERROR: Failed to open superelement file '{}'.", local_filename));
   }
 
diff --git a/ThirdParty/ioss/vtkioss/exodus/Ioex_Utils.C b/ThirdParty/ioss/vtkioss/exodus/Ioex_Utils.C
index 34c35bd88e8222c33eb935c7a15564e3b46c848f..22b0dae485c028befa9a9e900de19b82cad74d3b 100644
--- a/ThirdParty/ioss/vtkioss/exodus/Ioex_Utils.C
+++ b/ThirdParty/ioss/vtkioss/exodus/Ioex_Utils.C
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -19,7 +19,7 @@
 #include <vtk_netcdf.h> // for NC_NOERR, nc_def_var, etc
 #if defined(_WIN32) && !defined(__MINGW32__)
 #include <string.h>
-#define strcasecmp _stricmp
+#define strcasecmp  _stricmp
 #define strncasecmp _strnicmp
 #else
 #include <strings.h>
@@ -117,9 +117,9 @@ namespace Ioex {
     int    rootid = static_cast<unsigned>(exodusFilePtr) & EX_FILE_ID_MASK;
     int    status = nc_get_att_double(rootid, NC_GLOBAL, "last_written_time", &tmp);
 
-    if (status == NC_NOERR && value > tmp) {
+    if (status == EX_NOERR && value > tmp) {
       status = nc_put_att_double(rootid, NC_GLOBAL, "last_written_time", NC_DOUBLE, 1, &value);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         auto errmsg = fmt::format(
             "Error: failed to define 'last_written_time' attribute to file id {}", exodusFilePtr);
@@ -346,7 +346,7 @@ namespace Ioex {
     }
   }
 
-  char **get_name_array(size_t count, int size)
+  char **get_name_array(size_t count, size_t size)
   {
     auto *names = new char *[count];
     for (size_t i = 0; i < count; i++) {
@@ -356,9 +356,9 @@ namespace Ioex {
     return names;
   }
 
-  void delete_name_array(char **names, int count)
+  void delete_name_array(char **names, size_t count)
   {
-    for (int i = 0; i < count; i++) {
+    for (size_t i = 0; i < count; i++) {
       delete[] names[i];
     }
     delete[] names;
@@ -410,11 +410,11 @@ namespace Ioex {
     nc_type att_type = NC_NAT;
     size_t  att_len  = 0;
     int     status   = nc_inq_att(rootid, NC_GLOBAL, "last_written_time", &att_type, &att_len);
-    if (status == NC_NOERR && att_type == NC_DOUBLE) {
+    if (status == EX_NOERR && att_type == NC_DOUBLE) {
       // Attribute exists on this database, read it...
       double tmp = 0.0;
       status     = nc_get_att_double(rootid, NC_GLOBAL, "last_written_time", &tmp);
-      if (status == NC_NOERR) {
+      if (status == EX_NOERR) {
         *value = tmp;
         found  = true;
       }
@@ -446,12 +446,12 @@ namespace Ioex {
     nc_type att_type = NC_NAT;
     size_t  att_len  = 0;
     int     status   = nc_inq_att(exodusFilePtr, NC_GLOBAL, "processor_info", &att_type, &att_len);
-    if (status == NC_NOERR && att_type == NC_INT) {
+    if (status == EX_NOERR && att_type == NC_INT) {
       // Attribute exists on this database, read it and check that the information
       // matches the current processor count and processor id.
       int proc_info[2];
       status = nc_get_att_int(exodusFilePtr, NC_GLOBAL, "processor_info", proc_info);
-      if (status == NC_NOERR) {
+      if (status == EX_NOERR) {
         if (proc_info[0] != processor_count && proc_info[0] > 1) {
           fmt::print(Ioss::WarnOut(),
                      "Processor decomposition count in file ({}) does not match current "
@@ -497,44 +497,6 @@ namespace Ioex {
     return true;
   }
 
-  void decode_surface_name(Ioex::SideSetMap &fs_map, Ioex::SideSetSet &fs_set,
-                           const std::string &name)
-  {
-    auto tokens = Ioss::tokenize(name, "_");
-    if (tokens.size() >= 4) {
-      // Name of form: "name_eltopo_sidetopo_id" or
-      // "name_block_id_sidetopo_id" "name" is typically "surface".
-      // The sideset containing this should then be called "name_id"
-
-      // Check whether the second-last token is a side topology and
-      // the third-last token is an element topology.
-      const Ioss::ElementTopology *side_topo =
-          Ioss::ElementTopology::factory(tokens[tokens.size() - 2], true);
-      if (side_topo != nullptr) {
-        const Ioss::ElementTopology *element_topo =
-            Ioss::ElementTopology::factory(tokens[tokens.size() - 3], true);
-        if (element_topo != nullptr || tokens[tokens.size() - 4] == "block") {
-          // The remainder of the tokens will be used to create
-          // a side set name and then this sideset will be
-          // a side block in that set.
-          std::string fs_name;
-          size_t      last_token = tokens.size() - 3;
-          if (element_topo == nullptr) {
-            last_token--;
-          }
-          for (size_t tok = 0; tok < last_token; tok++) {
-            fs_name += tokens[tok];
-          }
-          fs_name += "_";
-          fs_name += tokens[tokens.size() - 1]; // Add on the id.
-
-          fs_set.insert(fs_name);
-          fs_map.insert(Ioex::SideSetMap::value_type(name, fs_name));
-        }
-      }
-    }
-  }
-
   bool set_id(const Ioss::GroupingEntity *entity, Ioex::EntityIdSet *idset)
   {
     // See description of 'get_id' function.  This function just primes
@@ -697,7 +659,8 @@ namespace Ioex {
   }
 
   std::string get_entity_name(int exoid, ex_entity_type type, int64_t id,
-                              const std::string &basename, int length, bool &db_has_name)
+                              const std::string &basename, int length, bool lowercase_names,
+                              bool &db_has_name)
   {
     std::vector<char> buffer(length + 1);
     buffer[0] = '\0';
@@ -706,16 +669,18 @@ namespace Ioex {
       exodus_error(exoid, __LINE__, __func__, __FILE__);
     }
     if (buffer[0] != '\0') {
-      Ioss::Utils::fixup_name(Data(buffer));
+      std::string name{Data(buffer)};
+      if (lowercase_names) {
+        Ioss::Utils::fixup_name(name);
+      }
       // Filter out names of the form "basename_id" if the name
       // id doesn't match the id in the name...
-      size_t base_size = basename.size();
-      if (std::strncmp(basename.c_str(), Data(buffer), base_size) == 0) {
-        int64_t name_id = extract_id(Data(buffer));
+      if (Ioss::Utils::substr_equal(basename, name)) {
+        int64_t name_id = extract_id(name);
 
         // See if name is truly of form "basename_name_id" (e.g. "surface_{id}")
         std::string tmp_name = Ioss::Utils::encode_entity_name(basename, name_id);
-        if (tmp_name == Data(buffer)) {
+        if (tmp_name == name) {
           if (name_id > 0) {
             db_has_name = false;
             if (name_id != id) {
@@ -725,7 +690,7 @@ namespace Ioex {
                          "embedded id {}.\n"
                          "         This can cause issues later; the entity will be renamed to '{}' "
                          "(IOSS)\n\n",
-                         Data(buffer), id, name_id, new_name);
+                         name, id, name_id, new_name);
               return new_name;
             }
             return tmp_name;
@@ -733,7 +698,7 @@ namespace Ioex {
         }
       }
       db_has_name = true;
-      return {Data(buffer)};
+      return name;
     }
     db_has_name = false;
     return Ioss::Utils::encode_entity_name(basename, id);
@@ -762,7 +727,7 @@ namespace Ioex {
     fmt::print(errmsg, " Please report to gdsjaar@sandia.gov if you need help.");
 
     ex_err_fn(exoid, nullptr, nullptr, EX_PRTLASTMSG);
-    IOSS_ERROR(errmsg);
+    IOSS_ABORT(errmsg);
   }
 
   int add_map_fields(int exoid, Ioss::ElementBlock *block, int64_t my_element_count,
@@ -849,6 +814,44 @@ namespace Ioex {
     }
   }
 
+  std::vector<ex_assembly> get_exodus_assemblies(int exoid)
+  {
+    std::vector<ex_assembly> assemblies;
+    int                      nassem = ex_inquire_int(exoid, EX_INQ_ASSEMBLY);
+    if (nassem > 0) {
+      assemblies.resize(nassem);
+
+      int max_name_length = ex_inquire_int(exoid, EX_INQ_DB_MAX_USED_NAME_LENGTH);
+      for (auto &assembly : assemblies) {
+        assembly.name = new char[max_name_length + 1];
+      }
+
+      int ierr = ex_get_assemblies(exoid, Data(assemblies));
+      if (ierr < 0) {
+        Ioex::exodus_error(exoid, __LINE__, __func__, __FILE__);
+      }
+
+      // Now allocate space for member list and get assemblies again...
+      for (auto &assembly : assemblies) {
+        assembly.entity_list = new int64_t[assembly.entity_count];
+      }
+
+      ierr = ex_get_assemblies(exoid, Data(assemblies));
+      if (ierr < 0) {
+        Ioex::exodus_error(exoid, __LINE__, __func__, __FILE__);
+      }
+    }
+    return assemblies;
+  }
+
+  void cleanup_exodus_assembly_vector(std::vector<ex_assembly> &assemblies)
+  {
+    for (const auto &assembly : assemblies) {
+      delete[] assembly.entity_list;
+      delete[] assembly.name;
+    }
+  }
+
   bool filter_node_list(Ioss::Int64Vector                &nodes,
                         const std::vector<unsigned char> &node_connectivity_status)
   {
@@ -928,7 +931,7 @@ namespace Ioex {
       for (size_t iel = 0; iel < element.size(); iel++) {
         int64_t elem_id = element[iel];
         if (elem_id <= 0) {
-          IOSS_ERROR(fmt::format(
+          IOSS_ABORT(fmt::format(
               "ERROR: In sideset/surface '{}' an element with id {} is specified.  Element "
               "ids must be greater than zero. ({})",
               surface_name, elem_id, __func__));
@@ -949,7 +952,7 @@ namespace Ioex {
         if (common_ftopo == nullptr && sides[iel] != current_side) {
           current_side = sides[iel];
           if (current_side <= 0 || current_side > block->topology()->number_boundaries()) {
-            IOSS_ERROR(fmt::format(
+            IOSS_ABORT(fmt::format(
                 "ERROR: In sideset/surface '{}' for the element with id {} of topology '{}';\n\t"
                 "an invalid face index '{}' is specified.\n\tFace indices "
                 "must be between 1 and {}. ({})",
diff --git a/ThirdParty/ioss/vtkioss/exodus/Ioex_Utils.h b/ThirdParty/ioss/vtkioss/exodus/Ioex_Utils.h
index 80d220607f5be39c4c662ceb60b4a2f42599bc17..eb83b0f9d35198a3abd5f2138ddf237debfb5ac5 100644
--- a/ThirdParty/ioss/vtkioss/exodus/Ioex_Utils.h
+++ b/ThirdParty/ioss/vtkioss/exodus/Ioex_Utils.h
@@ -1,5 +1,5 @@
 /*
- * Copyright(C) 1999-2020, 2022, 2023, 2024 National Technology & Engineering Solutions
+ * Copyright(C) 1999-2020, 2022, 2023, 2024, 2025 National Technology & Engineering Solutions
  * of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
  * NTESS, the U.S. Government retains certain rights in this software.
  *
@@ -102,8 +102,6 @@ namespace Ioex {
   IOSS_NODISCARD IOEX_EXPORT int64_t extract_id(const std::string &name_id);
   IOEX_EXPORT bool    set_id(const Ioss::GroupingEntity *entity, Ioex::EntityIdSet *idset);
   IOEX_EXPORT int64_t get_id(const Ioss::GroupingEntity *entity, Ioex::EntityIdSet *idset);
-  IOEX_EXPORT void    decode_surface_name(Ioex::SideSetMap &fs_map, Ioex::SideSetSet &fs_set,
-                                          const std::string &name);
   IOEX_EXPORT void    fix_bad_name(char *name);
 
   IOEX_EXPORT void exodus_error(int exoid, int lineno, const char *function, const char *filename);
@@ -113,8 +111,8 @@ namespace Ioex {
   IOEX_EXPORT int add_map_fields(int exoid, Ioss::ElementBlock *block, int64_t my_element_count,
                                  size_t name_length);
 
-  IOSS_NODISCARD IOEX_EXPORT char **get_name_array(size_t count, int size);
-  IOEX_EXPORT void                  delete_name_array(char **names, int count);
+  IOSS_NODISCARD IOEX_EXPORT char **get_name_array(size_t count, size_t size);
+  IOEX_EXPORT void                  delete_name_array(char **names, size_t count);
   IOSS_NODISCARD IOEX_EXPORT Ioss::NameList get_variable_names(int nvar, int maximumNameLength,
                                                                int exoid, ex_entity_type type);
   IOSS_NODISCARD IOEX_EXPORT                Ioss::NameList
@@ -129,7 +127,10 @@ namespace Ioex {
 
   IOSS_NODISCARD IOEX_EXPORT std::string get_entity_name(int exoid, ex_entity_type type, int64_t id,
                                                          const std::string &basename, int length,
-                                                         bool &db_has_name);
+                                                         bool lowercase_names, bool &db_has_name);
+
+  IOEX_EXPORT std::vector<ex_assembly> get_exodus_assemblies(int exoid);
+  IOEX_EXPORT void cleanup_exodus_assembly_vector(std::vector<ex_assembly> &assemblies);
 
   IOEX_EXPORT bool filter_node_list(Ioss::Int64Vector                &nodes,
                                     const std::vector<unsigned char> &node_connectivity_status);
diff --git a/ThirdParty/ioss/vtkioss/exonull/Ioexnl_BaseDatabaseIO.C b/ThirdParty/ioss/vtkioss/exonull/Ioexnl_BaseDatabaseIO.C
index b4a3b7ccf135907b5cce1484dc57261d4f1f0a1e..9e6b35b1e225db8ee817083fc8e46b34019cdd8b 100644
--- a/ThirdParty/ioss/vtkioss/exonull/Ioexnl_BaseDatabaseIO.C
+++ b/ThirdParty/ioss/vtkioss/exonull/Ioexnl_BaseDatabaseIO.C
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -71,7 +71,7 @@ namespace {
   template <typename T>
   void write_attribute_names(int exoid, ex_entity_type type, const std::vector<T *> &entities);
 
-  char **get_name_array(size_t count, int size)
+  char **get_name_array(size_t count, size_t size)
   {
     auto *names = new char *[count];
     for (size_t i = 0; i < count; i++) {
@@ -81,9 +81,9 @@ namespace {
     return names;
   }
 
-  void delete_name_array(char **names, int count)
+  void delete_name_array(char **names, size_t count)
   {
-    for (int i = 0; i < count; i++) {
+    for (size_t i = 0; i < count; i++) {
       delete[] names[i];
     }
     delete[] names;
@@ -1592,10 +1592,6 @@ namespace {
                                   IOSS_MAYBE_UNUSED const std::string &filename,
                                   IOSS_MAYBE_UNUSED const Ioss::ParallelUtils &util)
   {
-    IOSS_PAR_UNUSED(exo_params);
-    IOSS_PAR_UNUSED(my_processor);
-    IOSS_PAR_UNUSED(filename);
-    IOSS_PAR_UNUSED(util);
 #ifdef SEACAS_HAVE_MPI
     const int        num_types = 10;
     std::vector<int> var_counts(num_types);
diff --git a/ThirdParty/ioss/vtkioss/exonull/Ioexnl_SuperElement.C b/ThirdParty/ioss/vtkioss/exonull/Ioexnl_SuperElement.C
index d2be61a6b92f2a47021b42f50c14866fea23b57f..109a04578a98148759a3c33d330d6047329c4d9d 100644
--- a/ThirdParty/ioss/vtkioss/exonull/Ioexnl_SuperElement.C
+++ b/ThirdParty/ioss/vtkioss/exonull/Ioexnl_SuperElement.C
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2020, 2023 National Technology & Engineering Solutions
+// Copyright(C) 1999-2020, 2023, 2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -13,6 +13,7 @@
 #include "exonull/Ioexnl_SuperElement.h" // for SuperElement
 #include <cassert>
 #include <cstddef>
+#include <vtk_exodusII.h>
 #include "vtk_fmt.h"
 #include VTK_FMT(fmt/ostream.h)
 #include <iosfwd>
@@ -29,7 +30,7 @@ namespace {
 
     int varid  = 0;
     int status = nc_inq_varid(ncid, name, &varid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       return status;
     }
 
@@ -45,7 +46,7 @@ namespace {
     int dimid = -1;
 
     int status = nc_inq_dimid(ncid, DIMENSION, &dimid);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       if (status == NC_EBADDIM) {
         // Value is zero if the dimension is not defined.
         *count = 0;
@@ -56,7 +57,7 @@ namespace {
     }
 
     status = nc_inq_dimlen(ncid, dimid, count);
-    if (status != NC_NOERR) {
+    if (status != EX_NOERR) {
       fmt::print(errmsg, "ERROR: Failed to get number of {} in superelement file.", label);
       IOSS_ERROR(errmsg);
     }
@@ -77,7 +78,7 @@ Ioexnl::SuperElement::SuperElement(std::string filename, const std::string &my_n
   std::string local_filename = fileName;
 
   int status = nc_open(local_filename.c_str(), NC_NOWRITE, &filePtr);
-  if (status != NC_NOERR) {
+  if (status != EX_NOERR) {
     std::ostringstream errmsg;
     fmt::print(errmsg, "ERROR: Failed to open superelement file '{}'.", local_filename);
     IOSS_ERROR(errmsg);
diff --git a/ThirdParty/ioss/vtkioss/exonull/Ioexnl_Utils.C b/ThirdParty/ioss/vtkioss/exonull/Ioexnl_Utils.C
index 24f1bc048d97bd1fa02ea8c13e9efe95e462cf74..624c4ab5200538f4a0b05d27618c8025e1ab2840 100644
--- a/ThirdParty/ioss/vtkioss/exonull/Ioexnl_Utils.C
+++ b/ThirdParty/ioss/vtkioss/exonull/Ioexnl_Utils.C
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -82,9 +82,9 @@ namespace Ioexnl {
     int    rootid = static_cast<unsigned>(exodusFilePtr) & EX_FILE_ID_MASK;
     int    status = nc_get_att_double(rootid, NC_GLOBAL, "last_written_time", &tmp);
 
-    if (status == NC_NOERR && value > tmp) {
+    if (status == EX_NOERR && value > tmp) {
       status = nc_put_att_double(rootid, NC_GLOBAL, "last_written_time", NC_DOUBLE, 1, &value);
-      if (status != NC_NOERR) {
+      if (status != EX_NOERR) {
         ex_opts(EX_VERBOSE);
         auto errmsg = fmt::format(
             "Error: failed to define 'last_written_time' attribute to file id {}", exodusFilePtr);
@@ -144,11 +144,11 @@ namespace Ioexnl {
     nc_type att_type = NC_NAT;
     size_t  att_len  = 0;
     int     status   = nc_inq_att(rootid, NC_GLOBAL, "last_written_time", &att_type, &att_len);
-    if (status == NC_NOERR && att_type == NC_DOUBLE) {
+    if (status == EX_NOERR && att_type == NC_DOUBLE) {
       // Attribute exists on this database, read it...
       double tmp = 0.0;
       status     = nc_get_att_double(rootid, NC_GLOBAL, "last_written_time", &tmp);
-      if (status == NC_NOERR) {
+      if (status == EX_NOERR) {
         *value = tmp;
         found  = true;
       }
@@ -180,12 +180,12 @@ namespace Ioexnl {
     nc_type att_type = NC_NAT;
     size_t  att_len  = 0;
     int     status   = nc_inq_att(exodusFilePtr, NC_GLOBAL, "processor_info", &att_type, &att_len);
-    if (status == NC_NOERR && att_type == NC_INT) {
+    if (status == EX_NOERR && att_type == NC_INT) {
       // Attribute exists on this database, read it and check that the information
       // matches the current processor count and processor id.
       int proc_info[2];
       status = nc_get_att_int(exodusFilePtr, NC_GLOBAL, "processor_info", proc_info);
-      if (status == NC_NOERR) {
+      if (status == EX_NOERR) {
         if (proc_info[0] != processor_count && proc_info[0] > 1) {
           fmt::print(Ioss::WarnOut(),
                      "Processor decomposition count in file ({}) does not match current "
@@ -231,44 +231,6 @@ namespace Ioexnl {
     return true;
   }
 
-  void decode_surface_name(Ioexnl::SideSetMap &fs_map, Ioexnl::SideSetSet &fs_set,
-                           const std::string &name)
-  {
-    auto tokens = Ioss::tokenize(name, "_");
-    if (tokens.size() >= 4) {
-      // Name of form: "name_eltopo_sidetopo_id" or
-      // "name_block_id_sidetopo_id" "name" is typically "surface".
-      // The sideset containing this should then be called "name_id"
-
-      // Check whether the second-last token is a side topology and
-      // the third-last token is an element topology.
-      const Ioss::ElementTopology *side_topo =
-          Ioss::ElementTopology::factory(tokens[tokens.size() - 2], true);
-      if (side_topo != nullptr) {
-        const Ioss::ElementTopology *element_topo =
-            Ioss::ElementTopology::factory(tokens[tokens.size() - 3], true);
-        if (element_topo != nullptr || tokens[tokens.size() - 4] == "block") {
-          // The remainder of the tokens will be used to create
-          // a side set name and then this sideset will be
-          // a side block in that set.
-          std::string fs_name;
-          size_t      last_token = tokens.size() - 3;
-          if (element_topo == nullptr) {
-            last_token--;
-          }
-          for (size_t tok = 0; tok < last_token; tok++) {
-            fs_name += tokens[tok];
-          }
-          fs_name += "_";
-          fs_name += tokens[tokens.size() - 1]; // Add on the id.
-
-          fs_set.insert(fs_name);
-          fs_map.insert(Ioexnl::SideSetMap::value_type(name, fs_name));
-        }
-      }
-    }
-  }
-
   bool set_id(const Ioss::GroupingEntity *entity, Ioexnl::EntityIdSet *idset)
   {
     // See description of 'get_id' function.  This function just primes
diff --git a/ThirdParty/ioss/vtkioss/exonull/Ioexnl_Utils.h b/ThirdParty/ioss/vtkioss/exonull/Ioexnl_Utils.h
index 3643ab48d62efe011b1710237e06d58c896305b6..a15db6c4949d2b6a29302f83dadeaa53fc60157f 100644
--- a/ThirdParty/ioss/vtkioss/exonull/Ioexnl_Utils.h
+++ b/ThirdParty/ioss/vtkioss/exonull/Ioexnl_Utils.h
@@ -1,5 +1,5 @@
 /*
- * Copyright(C) 1999-2020, 2022, 2023, 2024 National Technology & Engineering Solutions
+ * Copyright(C) 1999-2020, 2022, 2023, 2024, 2025 National Technology & Engineering Solutions
  * of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
  * NTESS, the U.S. Government retains certain rights in this software.
  *
@@ -97,8 +97,6 @@ namespace Ioexnl {
   IOSS_NODISCARD IOEXNL_EXPORT int64_t extract_id(const std::string &name_id);
   IOEXNL_EXPORT bool    set_id(const Ioss::GroupingEntity *entity, Ioexnl::EntityIdSet *idset);
   IOEXNL_EXPORT int64_t get_id(const Ioss::GroupingEntity *entity, Ioexnl::EntityIdSet *idset);
-  IOEXNL_EXPORT void    decode_surface_name(Ioexnl::SideSetMap &fs_map, Ioexnl::SideSetSet &fs_set,
-                                            const std::string &name);
   IOEXNL_EXPORT void    fix_bad_name(char *name);
 
   IOEXNL_EXPORT void exodus_error(int exoid, int lineno, const char *function,
diff --git a/ThirdParty/ioss/vtkioss/heartbeat/Iohb_Layout.C b/ThirdParty/ioss/vtkioss/heartbeat/Iohb_Layout.C
index b524de17caa3d1a2b77ac519a14605306ba401b4..6f874ebf8690451a2ee71cbc634c1cde278412cb 100644
--- a/ThirdParty/ioss/vtkioss/heartbeat/Iohb_Layout.C
+++ b/ThirdParty/ioss/vtkioss/heartbeat/Iohb_Layout.C
@@ -1,4 +1,4 @@
-// Copyright(C) 1999-2022, 2024 National Technology & Engineering Solutions
+// Copyright(C) 1999-2022, 2024, 2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -37,10 +37,12 @@ namespace Iohb {
     }
   }
 
+#ifndef DOXYGEN_SKIP_THIS
   template void Layout::add(const std::string &name, const std::string &value);
   template void Layout::add(const std::string &name, const int &value);
   template void Layout::add(const std::string &name, const int64_t &value);
   template void Layout::add(const std::string &name, const size_t &value);
+#endif
 
   // Ideally, this would be in the include file, but when building in Sierra, we
   // need to keep all `fmt` includes out of the include file due to some TPLs
@@ -72,9 +74,11 @@ namespace Iohb {
     }
   }
 
+#ifndef DOXYGEN_SKIP_THIS
   template void Layout::add(const std::string &name, const std::vector<int> &value);
   template void Layout::add(const std::string &name, const std::vector<int64_t> &value);
   template void Layout::add(const std::string &name, const std::vector<size_t> &value);
+#endif
 
   template <typename T> void Layout::add(const std::string &name, const std::vector<T> &value)
   {
diff --git a/ThirdParty/ioss/vtkioss/hopscotch_hash.h b/ThirdParty/ioss/vtkioss/hopscotch_hash.h
index 00f421125d3def41b44c8dcde71cbc59140bce93..868d157d7c506c0e12e0e76e9a7e75f6119f6245 100644
--- a/ThirdParty/ioss/vtkioss/hopscotch_hash.h
+++ b/ThirdParty/ioss/vtkioss/hopscotch_hash.h
@@ -1717,7 +1717,7 @@ namespace tsl {
         while (neighborhood_infos != 0) {
           if ((neighborhood_infos & 1) == 1) {
             // Check StoreHash before calling bucket_hash_equal. Functionally it
-            // doesn't change anythin. If StoreHash is false, bucket_hash_equal is a
+            // doesn't change anything. If StoreHash is false, bucket_hash_equal is a
             // no-op. Avoiding the call is there to help GCC optimizes `my_hash`
             // parameter away, it seems to not be able to do without this hint.
             if ((!StoreHash || bucket_for_hash->bucket_hash_equal(my_hash)) &&
diff --git a/ThirdParty/ioss/vtkioss/null/Ionull_DatabaseIO.h b/ThirdParty/ioss/vtkioss/null/Ionull_DatabaseIO.h
index f49ff746a5d55f5b84a70d2c6cd3aa510c960c29..182351731793c742a86fead31a30306aa3d0acfc 100644
--- a/ThirdParty/ioss/vtkioss/null/Ionull_DatabaseIO.h
+++ b/ThirdParty/ioss/vtkioss/null/Ionull_DatabaseIO.h
@@ -1,4 +1,4 @@
-// Copyright(C) 2023, 2024 National Technology & Engineering Solutions
+// Copyright(C) 2023, 2024, 2025 National Technology & Engineering Solutions
 // of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 // NTESS, the U.S. Government retains certain rights in this software.
 //
@@ -70,7 +70,7 @@ namespace Ionull {
     IOSS_NODISCARD bool ok_nl(bool, std::string *, int *) const override { return true; }
 
   private:
-    // Input only database -- these will never be called...
+    // Output only database -- these will never be called...
     IOSS_NOOP_GFI(Ioss::Region)
     IOSS_NOOP_GFI(Ioss::NodeBlock)
     IOSS_NOOP_GFI(Ioss::EdgeBlock)
